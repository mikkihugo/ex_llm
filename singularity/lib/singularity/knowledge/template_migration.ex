defmodule Singularity.Knowledge.TemplateMigration do
  @moduledoc """
  Template Migration System - Upgrade code when templates evolve.

  Extracted from Copier's migration pattern, adapted for Singularity using Solid (Handlebars).

  ## Migration Schema (in template JSON)

  ```json
  {
    "type": "quality_template",
    "content": {
      "migrations": [
        {
          "version": "2.0.0",
          "when": "{{#if (eq _stage 'before')}}true{{/if}}",
          "command": "mix format {{_file_path}}"
        },
        {
          "version": "2.1.0",
          "before": [
            "mv lib/old_structure lib/new_structure",
            "sed -i 's/OldModule/NewModule/g' {{ _file_path }}"
          ],
          "after": [
            "mix compile --warnings-as-errors",
            "mix test {{ _test_file }}"
          ]
        }
      ]
    }
  }
  ```

  ## Migration Stages

  - `before`: Run before rendering new template (e.g., rename files)
  - `after`: Run after rendering new template (e.g., format, test)

  ## Available Variables in Migration Commands (Solid/Handlebars syntax)

  - `{{_file_path}}` - Path to generated file
  - `{{_template_id}}` - Template identifier
  - `{{_version_from}}` - Old template version
  - `{{_version_to}}` - New template version
  - `{{_stage}}` - Current stage (before/after)
  - All question answers from original generation

  ## Usage

  ```elixir
  # Upgrade all files generated by template v1.0 to v2.0
  TemplateMigration.upgrade_template(
    template_id: "quality_template:elixir-genserver",
    from_version: "1.0.0",
    to_version: "2.0.0"
  )

  # Run migrations for single file
  TemplateMigration.migrate_file(
    file_path: "lib/my_app/worker.ex",
    to_version: "2.0.0"
  )
  ```

  ## Example: Migrate GenServer to use new OTP pattern

  ```json
  {
    "migrations": [
      {
        "version": "2.0.0",
        "before": [
          "# Backup old file",
          "cp {{ _file_path }} {{ _file_path }}.backup"
        ],
        "after": [
          "# Verify new code compiles",
          "mix compile {{ _file_path }}",
          "# Run tests",
          "mix test test/{{ _test_path }}",
          "# Remove backup if successful",
          "rm {{ _file_path }}.backup"
        ]
      }
    ]
  }
  ```
  """

  require Logger

  alias Singularity.Knowledge.{ArtifactStore, TemplateGeneration}

  @type migration :: %{
          version: String.t(),
          before: list(String.t()) | nil,
          after: list(String.t()) | nil,
          when: String.t() | nil,
          command: String.t() | list(String.t()) | nil,
          working_directory: String.t() | nil
        }

  @doc """
  Upgrade all files generated by a template to new version.
  """
  def upgrade_template(opts) do
    template_id = Keyword.fetch!(opts, :template_id)
    from_version = Keyword.get(opts, :from_version)
    to_version = Keyword.fetch!(opts, :to_version)

    Logger.info("Upgrading template #{template_id} from #{from_version} to #{to_version}")

    # Get template with migrations
    {:ok, template} = ArtifactStore.get_by_identifier(template_id)
    migrations = get_migrations(template, from_version, to_version)

    # Find all files generated by this template version
    generations =
      if from_version do
        TemplateGeneration.list_by_template(template_id)
        |> Enum.filter(&(&1.template_version == from_version))
      else
        TemplateGeneration.list_by_template(template_id)
      end

    # Run migrations for each file
    results =
      Enum.map(generations, fn gen ->
        migrate_file(gen, migrations, template, to_version)
      end)

    success_count = Enum.count(results, &match?({:ok, _}, &1))
    total_count = length(results)

    Logger.info("Migration complete: #{success_count}/#{total_count} successful")

    {:ok, %{success: success_count, total: total_count, results: results}}
  end

  @doc """
  Migrate a single file to new template version.
  """
  def migrate_file(opts) when is_list(opts) do
    file_path = Keyword.fetch!(opts, :file_path)
    to_version = Keyword.fetch!(opts, :to_version)

    case TemplateGeneration.find_by_file(file_path) do
      {:ok, gen} ->
        {:ok, template} = ArtifactStore.get_by_identifier(gen.template_id)
        migrations = get_migrations(template, gen.template_version, to_version)
        migrate_file(gen, migrations, template, to_version)

      error ->
        error
    end
  end

  def migrate_file(generation, migrations, template, to_version) do
    file_path = generation.file_path
    Logger.info("Migrating #{file_path} to version #{to_version}")

    context = build_migration_context(generation, to_version)

    with :ok <- run_stage(migrations, :before, context),
         {:ok, merged_answers} <- re_ask_questions_if_needed(template, generation.answers),
         {:ok, new_code} <- regenerate_code(template, merged_answers),
         :ok <- write_file(file_path, new_code),
         :ok <- update_answer_file(generation, to_version, merged_answers),
         :ok <- run_stage(migrations, :after, context) do
      # Record successful migration
      TemplateGeneration.record(
        template_id: generation.template_id,
        template_version: to_version,
        file_path: file_path,
        answers: merged_answers,
        success: true
      )

      Logger.info("Migration successful: #{file_path} upgraded to #{to_version}")
      {:ok, %{file_path: file_path, version: to_version, answers: merged_answers}}
    else
      {:error, reason} = error ->
        Logger.error("Migration failed for #{file_path}: #{inspect(reason)}")

        TemplateGeneration.record(
          template_id: generation.template_id,
          template_version: to_version,
          file_path: file_path,
          answers: generation.answers,
          success: false,
          error_message: inspect(reason)
        )

        error
    end
  end

  # Private

  defp get_migrations(template, from_version, to_version) do
    migrations = get_in(template.content, ["migrations"]) || []

    migrations
    |> Enum.filter(&should_run_migration?(&1, from_version, to_version))
    |> Enum.sort_by(&version_to_comparable(&1["version"]))
  end

  defp should_run_migration?(migration, from_version, to_version) do
    migration_version = migration["version"]

    cond do
      is_nil(migration_version) ->
        # Migration without version - always run
        true

      is_nil(from_version) ->
        # No from_version - run if migration version <= to_version
        version_compare(migration_version, to_version) in [:lt, :eq]

      true ->
        # Run if: from_version < migration_version <= to_version
        version_compare(migration_version, from_version) == :gt &&
          version_compare(migration_version, to_version) in [:lt, :eq]
    end
  end

  defp version_compare(v1, v2) do
    # Simple version comparison (can be enhanced with Version module)
    cond do
      v1 < v2 -> :lt
      v1 > v2 -> :gt
      true -> :eq
    end
  end

  defp version_to_comparable(version) when is_binary(version) do
    # Convert "2.1.0" to [2, 1, 0] for sorting
    version
    |> String.split(".")
    |> Enum.map(&String.to_integer/1)
  end

  defp build_migration_context(generation, to_version) do
    Map.merge(generation.answers, %{
      "_file_path" => generation.file_path,
      "_template_id" => generation.template_id,
      "_version_from" => generation.template_version,
      "_version_to" => to_version,
      "_test_file" =>
        String.replace(generation.file_path, ~r/lib\/(.*)\.ex$/, "test/\\1_test.exs")
    })
  end

  defp run_stage(migrations, stage, context) do
    stage_key = Atom.to_string(stage)

    migrations
    |> Enum.filter(&has_stage?(&1, stage_key))
    |> Enum.reduce_while(:ok, fn migration, :ok ->
      context_with_stage = Map.put(context, "_stage", stage_key)

      case run_migration_stage(migration, stage_key, context_with_stage) do
        :ok -> {:cont, :ok}
        error -> {:halt, error}
      end
    end)
  end

  defp has_stage?(migration, stage) do
    Map.has_key?(migration, stage) ||
      (Map.has_key?(migration, "when") && Map.has_key?(migration, "command"))
  end

  defp run_migration_stage(migration, stage, context) do
    commands =
      cond do
        migration[stage] -> List.wrap(migration[stage])
        migration["command"] -> List.wrap(migration["command"])
        true -> []
      end

    # Check condition
    if should_run?(migration["when"], context) do
      working_dir = migration["working_directory"] || System.get_env("PWD")

      Enum.reduce_while(commands, :ok, fn command, :ok ->
        case run_command(command, context, working_dir) do
          :ok -> {:cont, :ok}
          error -> {:halt, error}
        end
      end)
    else
      :ok
    end
  end

  defp should_run?(nil, _context), do: true
  defp should_run?(true, _context), do: true
  defp should_run?(false, _context), do: false

  defp should_run?(condition, context) when is_binary(condition) do
    # Render Solid (Handlebars) condition template
    case render_solid_template(condition, context) do
      {:ok, result} -> result =~ "true"
      {:error, _} -> false
    end
  end

  defp run_command(command, context, working_dir) when is_binary(command) do
    # Render command template with context (Solid/Handlebars)
    rendered_command = render_template(command, context)

    Logger.debug("Running: #{rendered_command} (cwd: #{working_dir})")

    case System.cmd("sh", ["-c", rendered_command], cd: working_dir, stderr_to_stdout: true) do
      {output, 0} ->
        Logger.debug("Command succeeded: #{output}")
        :ok

      {output, code} ->
        Logger.error("Command failed (exit #{code}): #{output}")
        {:error, {:command_failed, code, output}}
    end
  end

  defp run_command(command, context, working_dir) when is_list(command) do
    # Array form: ["mix", "test", "{{ _test_file }}"]
    rendered_command = Enum.map(command, &render_template(&1, context))

    Logger.debug("Running: #{inspect(rendered_command)} (cwd: #{working_dir})")

    case System.cmd(hd(rendered_command), tl(rendered_command),
           cd: working_dir,
           stderr_to_stdout: true
         ) do
      {output, 0} ->
        Logger.debug("Command succeeded: #{output}")
        :ok

      {output, code} ->
        Logger.error("Command failed (exit #{code}): #{output}")
        {:error, {:command_failed, code, output}}
    end
  end

  defp render_template(template, context) do
    # Render with Solid (Handlebars) for advanced features
    case render_solid_template(template, context) do
      {:ok, rendered} -> rendered
      {:error, _} -> fallback_render(template, context)
    end
  end

  defp render_solid_template(template, context) when is_binary(template) do
    # Use Solid for rich templating
    case Solid.parse(template) do
      {:ok, parsed} ->
        case Solid.render(parsed, context) do
          {:ok, iodata} -> {:ok, IO.iodata_to_binary(iodata)}
          error -> error
        end

      error ->
        error
    end
  end

  defp fallback_render(template, context) do
    # Fallback: Simple {{variable}} replacement
    Enum.reduce(context, template, fn {key, value}, acc ->
      acc
      |> String.replace("{{#{key}}}", to_string(value))
      |> String.replace("{{ #{key} }}", to_string(value))
    end)
  end

  defp re_ask_questions_if_needed(template, old_answers) do
    # Get questions from new template
    questions = Map.get(template, "questions", [])

    if Enum.empty?(questions) do
      # No questions in template, use old answers as-is
      {:ok, old_answers}
    else
      # Re-ask questions, preserving old answers where possible
      new_questions =
        questions
        |> Enum.filter(fn q ->
          question_name = Map.get(q, "name")
          # Only ask if question is new (not in old answers)
          not Map.has_key?(old_answers, question_name)
        end)

      if Enum.empty?(new_questions) do
        # All questions already answered, use old answers
        Logger.debug("All questions already answered, using existing answers")
        {:ok, old_answers}
      else
        Logger.info("Re-asking #{length(new_questions)} new questions for template upgrade")

        # Ask new questions via LLM
        case Singularity.Knowledge.TemplateQuestion.ask_via_llm(
               new_questions,
               context: old_answers,
               template_id: template["template_id"]
             ) do
          {:ok, new_answers} ->
            # Merge old and new answers
            merged = Map.merge(old_answers, new_answers)
            Logger.debug("Merged answers: #{inspect(Map.keys(merged))}")
            {:ok, merged}

          {:error, reason} ->
            Logger.warning("Failed to ask new questions: #{inspect(reason)}, using old answers")
            {:ok, old_answers}
        end
      end
    end
  end

  defp regenerate_code(template, answers) do
    # Regenerate code using template's prompt_template
    prompt_template = Map.get(template, "prompt_template", "")

    if String.trim(prompt_template) == "" do
      Logger.warning("Template has no prompt_template, cannot regenerate code")
      {:error, :no_prompt_template}
    else
      # Render prompt template with answers
      case render_solid_template(prompt_template, answers) do
        {:ok, rendered_prompt} ->
          # Use LLM to generate code
          case Singularity.LLM.Service.call_with_prompt(:complex, rendered_prompt,
                 task_type: :coder
               ) do
            {:ok, generated_code} ->
              Logger.debug("Successfully regenerated code (#{String.length(generated_code)} chars)")
              {:ok, generated_code}

            {:error, reason} ->
              Logger.error("Failed to regenerate code via LLM: #{inspect(reason)}")
              {:error, {:llm_error, reason}}
          end

        {:error, reason} ->
          Logger.error("Failed to render prompt template: #{inspect(reason)}")
          {:error, {:template_render_error, reason}}
      end
    end
  end

  defp update_answer_file(generation, new_version, merged_answers) do
    # Update .template-answers.yml with new version and answers
    answer_file_path = generation.file_path <> ".template-answers.yml"

    yaml_content = format_answer_file_yaml(
      generation.template_id,
      new_version,
      merged_answers,
      DateTime.utc_now()
    )

    case File.write(answer_file_path, yaml_content) do
      :ok ->
        Logger.debug("Updated answer file: #{answer_file_path}")
        :ok

      {:error, reason} ->
        Logger.warning("Failed to update answer file: #{inspect(reason)}")
        # Don't fail migration if answer file write fails
        :ok
    end
  end

  defp format_answer_file_yaml(template_id, version, answers, timestamp) do
    header = """
    # Template Answer File (UPGRADED)
    # Generated by Singularity - Tracks code generation for upgrades and learning
    # To regenerate: mix template.regenerate #{template_id}
    # Upgraded at: #{DateTime.to_iso8601(timestamp)}

    _template_id: #{template_id}
    _template_version: #{version}
    _generated_at: #{DateTime.to_iso8601(timestamp)}
    _upgraded: true

    # Answers (preserved + new):
    """

    answers_yaml =
      answers
      |> Enum.sort_by(fn {key, _value} -> key end)
      |> Enum.map(fn {key, value} ->
        "#{key}: #{format_yaml_value(value)}"
      end)
      |> Enum.join("\n")

    header <> answers_yaml <> "\n"
  end

  defp format_yaml_value(value) when is_binary(value), do: "\"#{value}\""
  defp format_yaml_value(value) when is_boolean(value), do: to_string(value)
  defp format_yaml_value(value) when is_number(value), do: to_string(value)
  defp format_yaml_value(value) when is_list(value), do: inspect(value)
  defp format_yaml_value(value), do: inspect(value)

  defp write_file(path, content) do
    File.write(path, content)
  end
end
