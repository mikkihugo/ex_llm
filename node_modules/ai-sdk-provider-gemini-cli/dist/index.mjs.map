{"version":3,"sources":["../src/gemini-provider.ts","../src/gemini-language-model.ts","../src/client.ts","../src/message-mapper.ts","../src/tool-mapper.ts","../src/error.ts","../src/extract-json.ts","../src/validation.ts"],"sourcesContent":["import type {\n  ProviderV2,\n  LanguageModelV2,\n  EmbeddingModelV2,\n  ImageModelV2,\n} from '@ai-sdk/provider';\nimport { NoSuchModelError } from '@ai-sdk/provider';\nimport { GeminiLanguageModel } from './gemini-language-model';\nimport type { GeminiProviderOptions } from './types';\nimport { validateAuthOptions } from './validation';\n\nexport interface GeminiProvider extends ProviderV2 {\n  (modelId: string, settings?: Record<string, unknown>): LanguageModelV2;\n  languageModel(\n    modelId: string,\n    settings?: Record<string, unknown>\n  ): LanguageModelV2;\n  chat(modelId: string, settings?: Record<string, unknown>): LanguageModelV2;\n  textEmbeddingModel(modelId: string): EmbeddingModelV2<string>;\n  imageModel(modelId: string): ImageModelV2;\n}\n\n/**\n * Creates a new Gemini provider instance.\n *\n * @param options - Configuration options for the provider\n * @returns A configured provider function\n * @throws Error if authentication options are invalid\n *\n * @example\n * ```typescript\n * // Using API key authentication\n * const gemini = createGeminiProvider({\n *   authType: 'gemini-api-key',\n *   apiKey: process.env.GEMINI_API_KEY\n * });\n *\n * // Use with Vercel AI SDK\n * const model = gemini('gemini-1.5-flash');\n * const result = await generateText({\n *   model,\n *   prompt: 'Hello, world!'\n * });\n * ```\n */\nexport function createGeminiProvider(\n  options: GeminiProviderOptions = {}\n): GeminiProvider {\n  // Validate authentication options\n  const validatedOptions = validateAuthOptions(options);\n\n  // Create the language model factory function\n  const createLanguageModel = (\n    modelId: string,\n    settings?: Record<string, unknown>\n  ) => {\n    return new GeminiLanguageModel({\n      modelId,\n      providerOptions: validatedOptions,\n      settings: {\n        maxOutputTokens: 65536, // 64K output tokens for Gemini 2.5 models\n        ...settings,\n      },\n    });\n  };\n\n  // Create the provider function\n  const provider = Object.assign(\n    function (modelId: string, settings?: Record<string, unknown>) {\n      if (new.target) {\n        throw new Error(\n          'The provider function cannot be called with the new keyword.'\n        );\n      }\n\n      return createLanguageModel(modelId, settings);\n    },\n    {\n      languageModel: createLanguageModel,\n      chat: createLanguageModel,\n      textEmbeddingModel: (modelId: string): never => {\n        throw new NoSuchModelError({\n          modelId,\n          modelType: 'textEmbeddingModel',\n          message: `Gemini provider does not support text embedding models.`,\n        });\n      },\n      imageModel: (modelId: string): never => {\n        throw new NoSuchModelError({\n          modelId,\n          modelType: 'imageModel',\n          message: `Gemini provider does not support image models.`,\n        });\n      },\n    }\n  ) as GeminiProvider;\n\n  return provider;\n}\n","import { randomUUID } from 'node:crypto';\nimport type {\n  LanguageModelV2,\n  LanguageModelV2CallOptions,\n  LanguageModelV2CallWarning,\n  LanguageModelV2FinishReason,\n  LanguageModelV2FunctionTool,\n  LanguageModelV2StreamPart,\n  LanguageModelV2Content,\n  LanguageModelV2Usage,\n} from '@ai-sdk/provider';\nimport type {\n  ContentGenerator,\n  ContentGeneratorConfig,\n} from '@google/gemini-cli-core';\nimport type {\n  GenerateContentParameters,\n  GenerateContentConfig,\n} from '@google/genai';\nimport { initializeGeminiClient } from './client';\nimport { mapPromptToGeminiFormat } from './message-mapper';\nimport { mapGeminiToolConfig, mapToolsToGeminiFormat } from './tool-mapper';\nimport { mapGeminiError } from './error';\nimport { extractJson } from './extract-json';\nimport type { GeminiProviderOptions } from './types';\n\nexport interface GeminiLanguageModelOptions {\n  modelId: string;\n  providerOptions: GeminiProviderOptions;\n  settings?: Record<string, unknown>;\n}\n\n/**\n * Map Gemini finish reasons to Vercel AI SDK finish reasons\n */\nfunction mapGeminiFinishReason(\n  geminiReason?: string\n): LanguageModelV2FinishReason {\n  switch (geminiReason) {\n    case 'STOP':\n      return 'stop';\n    case 'MAX_TOKENS':\n      return 'length';\n    case 'SAFETY':\n    case 'RECITATION':\n      return 'content-filter';\n    case 'OTHER':\n      return 'other';\n    default:\n      return 'unknown';\n  }\n}\n\nexport class GeminiLanguageModel implements LanguageModelV2 {\n  readonly specificationVersion = 'v2' as const;\n  readonly provider = 'gemini-cli-core';\n  readonly defaultObjectGenerationMode = 'json' as const;\n  readonly supportsImageUrls = false; // CLI Core uses base64 data, not URLs\n  readonly supportedUrls = {}; // No native URL support\n  readonly supportsStructuredOutputs = false; // V2 structured outputs not supported yet\n\n  private contentGenerator?: ContentGenerator;\n  private config?: ContentGeneratorConfig;\n  private initPromise?: Promise<void>;\n\n  readonly modelId: string;\n  readonly settings?: Record<string, unknown>;\n  private providerOptions: GeminiProviderOptions;\n\n  constructor(options: GeminiLanguageModelOptions) {\n    this.modelId = options.modelId;\n    this.providerOptions = options.providerOptions;\n    this.settings = options.settings;\n  }\n\n  private async ensureInitialized(): Promise<{\n    contentGenerator: ContentGenerator;\n    config: ContentGeneratorConfig;\n  }> {\n    if (this.contentGenerator && this.config) {\n      return { contentGenerator: this.contentGenerator, config: this.config };\n    }\n\n    if (!this.initPromise) {\n      this.initPromise = this.initialize();\n    }\n\n    await this.initPromise;\n    return { contentGenerator: this.contentGenerator!, config: this.config! };\n  }\n\n  private async initialize(): Promise<void> {\n    try {\n      const { client, config } = await initializeGeminiClient(\n        this.providerOptions,\n        this.modelId\n      );\n      this.contentGenerator = client;\n      this.config = config;\n    } catch (error) {\n      throw new Error(`Failed to initialize Gemini model: ${String(error)}`);\n    }\n  }\n\n  /**\n   * Non-streaming generation method\n   */\n  async doGenerate(options: LanguageModelV2CallOptions): Promise<{\n    content: LanguageModelV2Content[];\n    finishReason: LanguageModelV2FinishReason;\n    usage: LanguageModelV2Usage;\n    rawCall: {\n      rawPrompt: unknown;\n      rawSettings: Record<string, unknown>;\n    };\n    rawResponse?: {\n      body?: unknown;\n    };\n    response?: {\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    };\n    warnings: LanguageModelV2CallWarning[];\n  }> {\n    try {\n      const { contentGenerator } = await this.ensureInitialized();\n\n      // Map the prompt to Gemini format\n      const { contents, systemInstruction } = mapPromptToGeminiFormat(options);\n\n      // Prepare generation config\n      const generationConfig: GenerateContentConfig = {\n        temperature:\n          options.temperature ??\n          (this.settings?.temperature as number | undefined),\n        topP: options.topP ?? (this.settings?.topP as number | undefined),\n        topK: options.topK ?? (this.settings?.topK as number | undefined),\n        maxOutputTokens:\n          options.maxOutputTokens ??\n          (this.settings?.maxOutputTokens as number | undefined),\n        stopSequences: options.stopSequences,\n        responseMimeType:\n          options.responseFormat?.type === 'json'\n            ? 'application/json'\n            : 'text/plain',\n        toolConfig: mapGeminiToolConfig(options),\n      };\n\n      // Map tools if provided in regular mode\n      let tools;\n      if (options.tools) {\n        // Filter to only function tools (not provider-defined tools)\n        const functionTools = options.tools.filter(\n          (tool): tool is LanguageModelV2FunctionTool =>\n            tool.type === 'function'\n        );\n        if (functionTools.length > 0) {\n          tools = mapToolsToGeminiFormat(functionTools);\n        }\n      }\n\n      // Create the request parameters\n      const request: GenerateContentParameters = {\n        model: this.modelId,\n        contents,\n        config: {\n          ...generationConfig,\n          systemInstruction: systemInstruction,\n          tools: tools,\n        },\n      };\n\n      // Set up abort handling\n      let abortListener: (() => void) | undefined;\n      if (options.abortSignal) {\n        // Check if already aborted\n        if (options.abortSignal.aborted) {\n          const abortError = new Error('Request aborted');\n          abortError.name = 'AbortError';\n          throw abortError;\n        }\n\n        // Set up listener for abort signal\n        // LIMITATION: The gemini-cli-core library doesn't expose request cancellation\n        // We can only check abort status before/after the request, not cancel in-flight\n        abortListener = () => {\n          // Track abort state - actual cancellation happens via status checks\n        };\n        options.abortSignal.addEventListener('abort', abortListener, {\n          once: true,\n        });\n      }\n\n      // Generate content (new signature requires userPromptId)\n      let response;\n      try {\n        response = await contentGenerator.generateContent(\n          request,\n          randomUUID()\n        );\n\n        // Check if aborted during generation\n        if (options.abortSignal?.aborted) {\n          const abortError = new Error('Request aborted');\n          abortError.name = 'AbortError';\n          throw abortError;\n        }\n      } finally {\n        // Clean up abort listener\n        if (options.abortSignal && abortListener) {\n          options.abortSignal.removeEventListener('abort', abortListener);\n        }\n      }\n\n      // Extract the result\n      const candidate = response.candidates?.[0];\n      const responseContent = candidate?.content;\n\n      // Build content array for v2 format\n      const content: LanguageModelV2Content[] = [];\n\n      if (responseContent?.parts) {\n        for (const part of responseContent.parts) {\n          if (part.text) {\n            let text = part.text;\n            // Extract JSON if in object-json mode\n            if (options.responseFormat?.type === 'json') {\n              text = extractJson(text);\n            }\n            content.push({\n              type: 'text',\n              text: text,\n            });\n          } else if (part.functionCall) {\n            content.push({\n              type: 'tool-call',\n              toolCallId: randomUUID(),\n              toolName: part.functionCall.name || '',\n              input: JSON.stringify(part.functionCall.args || {}),\n            } as LanguageModelV2Content);\n          }\n        }\n      }\n\n      // Calculate token usage\n      const inputTokens = response.usageMetadata?.promptTokenCount || 0;\n      const outputTokens = response.usageMetadata?.candidatesTokenCount || 0;\n      const totalTokens = inputTokens + outputTokens;\n\n      const usage: LanguageModelV2Usage = {\n        inputTokens,\n        outputTokens,\n        totalTokens,\n      };\n\n      return {\n        content,\n        finishReason: mapGeminiFinishReason(candidate?.finishReason),\n        usage,\n        rawCall: {\n          rawPrompt: { contents, systemInstruction, generationConfig, tools },\n          rawSettings: generationConfig as Record<string, unknown>,\n        },\n        rawResponse: {\n          body: response,\n        },\n        response: {\n          id: randomUUID(),\n          timestamp: new Date(),\n          modelId: this.modelId,\n        },\n        warnings: [],\n      };\n    } catch (error) {\n      throw mapGeminiError(error);\n    }\n  }\n\n  /**\n   * Streaming generation method\n   */\n  async doStream(options: LanguageModelV2CallOptions): Promise<{\n    stream: ReadableStream<LanguageModelV2StreamPart>;\n    rawCall: {\n      rawPrompt: unknown;\n      rawSettings: Record<string, unknown>;\n    };\n  }> {\n    try {\n      const { contentGenerator } = await this.ensureInitialized();\n\n      // Map the prompt to Gemini format\n      const { contents, systemInstruction } = mapPromptToGeminiFormat(options);\n\n      // Prepare generation config\n      const generationConfig: GenerateContentConfig = {\n        temperature:\n          options.temperature ??\n          (this.settings?.temperature as number | undefined),\n        topP: options.topP ?? (this.settings?.topP as number | undefined),\n        topK: options.topK ?? (this.settings?.topK as number | undefined),\n        maxOutputTokens:\n          options.maxOutputTokens ??\n          (this.settings?.maxOutputTokens as number | undefined),\n        stopSequences: options.stopSequences,\n        responseMimeType:\n          options.responseFormat?.type === 'json'\n            ? 'application/json'\n            : 'text/plain',\n        toolConfig: mapGeminiToolConfig(options),\n      };\n\n      // Map tools if provided in regular mode\n      let tools;\n      if (options.tools) {\n        // Filter to only function tools (not provider-defined tools)\n        const functionTools = options.tools.filter(\n          (tool): tool is LanguageModelV2FunctionTool =>\n            tool.type === 'function'\n        );\n        if (functionTools.length > 0) {\n          tools = mapToolsToGeminiFormat(functionTools);\n        }\n      }\n\n      // Create the request parameters\n      const request: GenerateContentParameters = {\n        model: this.modelId,\n        contents,\n        config: {\n          ...generationConfig,\n          systemInstruction: systemInstruction,\n          tools: tools,\n        },\n      };\n\n      // Set up abort handling\n      let abortListener: (() => void) | undefined;\n      if (options.abortSignal) {\n        // Check if already aborted\n        if (options.abortSignal.aborted) {\n          const abortError = new Error('Request aborted');\n          abortError.name = 'AbortError';\n          throw abortError;\n        }\n\n        // Set up listener for abort signal\n        // LIMITATION: The gemini-cli-core library doesn't expose stream cancellation\n        // We can only check abort status during iteration, not cancel the underlying stream\n        abortListener = () => {\n          // Track abort state - actual cancellation happens via status checks\n        };\n        options.abortSignal.addEventListener('abort', abortListener, {\n          once: true,\n        });\n      }\n\n      // Create streaming response (new signature requires userPromptId)\n      let streamResponse;\n      try {\n        streamResponse = await contentGenerator.generateContentStream(\n          request,\n          randomUUID()\n        );\n\n        // Check if aborted during stream creation\n        if (options.abortSignal?.aborted) {\n          const abortError = new Error('Request aborted');\n          abortError.name = 'AbortError';\n          throw abortError;\n        }\n      } catch (error) {\n        // Clean up abort listener on error\n        if (options.abortSignal && abortListener) {\n          options.abortSignal.removeEventListener('abort', abortListener);\n        }\n        throw error;\n      }\n\n      // Capture modelId for use in stream\n      const modelId = this.modelId;\n\n      // Transform the stream to AI SDK v5 format\n      const stream = new ReadableStream<LanguageModelV2StreamPart>({\n        async start(controller) {\n          try {\n            // Check for abort signal in stream\n            if (options.abortSignal?.aborted) {\n              const abortError = new Error('Request aborted');\n              abortError.name = 'AbortError';\n              controller.error(abortError);\n              return;\n            }\n            let accumulatedText = '';\n            const isObjectJsonMode = options.responseFormat?.type === 'json';\n            let currentToolCallId: string | undefined;\n            let totalInputTokens = 0;\n            let totalOutputTokens = 0;\n\n            // Emit stream-start event\n            controller.enqueue({\n              type: 'stream-start',\n              warnings: [],\n            });\n\n            for await (const chunk of streamResponse) {\n              // Check if aborted during streaming\n              if (options.abortSignal?.aborted) {\n                const abortError = new Error('Request aborted');\n                abortError.name = 'AbortError';\n                controller.error(abortError);\n                break;\n              }\n\n              const candidate = chunk.candidates?.[0];\n              const content = candidate?.content;\n\n              // Update token counts if available\n              if (chunk.usageMetadata) {\n                totalInputTokens = chunk.usageMetadata.promptTokenCount || 0;\n                totalOutputTokens =\n                  chunk.usageMetadata.candidatesTokenCount || 0;\n              }\n\n              if (content?.parts) {\n                for (const part of content.parts) {\n                  if (part.text) {\n                    if (isObjectJsonMode) {\n                      // In object-json mode, accumulate text\n                      accumulatedText += part.text;\n                    } else {\n                      // In regular mode, stream text directly\n                      controller.enqueue({\n                        type: 'text-delta',\n                        id: randomUUID(),\n                        delta: part.text,\n                      });\n                    }\n                  } else if (part.functionCall) {\n                    // Emit tool call as a single event\n                    currentToolCallId = randomUUID();\n                    controller.enqueue({\n                      type: 'tool-call',\n                      toolCallId: currentToolCallId,\n                      toolName: part.functionCall.name || '',\n                      input: JSON.stringify(part.functionCall.args || {}),\n                    });\n                    currentToolCallId = undefined;\n                  }\n                }\n              }\n\n              if (candidate?.finishReason) {\n                // If in object-json mode, extract and emit the JSON before finishing\n                if (isObjectJsonMode && accumulatedText) {\n                  const extractedJson = extractJson(accumulatedText);\n                  controller.enqueue({\n                    type: 'text-delta',\n                    id: randomUUID(),\n                    delta: extractedJson,\n                  });\n                }\n\n                // Emit response metadata\n                controller.enqueue({\n                  type: 'response-metadata',\n                  id: randomUUID(),\n                  timestamp: new Date(),\n                  modelId: modelId,\n                });\n\n                // Emit finish event\n                controller.enqueue({\n                  type: 'finish',\n                  finishReason: mapGeminiFinishReason(candidate.finishReason),\n                  usage: {\n                    inputTokens: totalInputTokens,\n                    outputTokens: totalOutputTokens,\n                    totalTokens: totalInputTokens + totalOutputTokens,\n                  },\n                });\n              }\n            }\n\n            // Final check for object-json mode if we didn't get a finish reason\n            if (\n              isObjectJsonMode &&\n              accumulatedText &&\n              !controller.desiredSize\n            ) {\n              const extractedJson = extractJson(accumulatedText);\n              controller.enqueue({\n                type: 'text-delta',\n                id: randomUUID(),\n                delta: extractedJson,\n              });\n\n              // Emit response metadata and finish\n              controller.enqueue({\n                type: 'response-metadata',\n                id: randomUUID(),\n                timestamp: new Date(),\n                modelId: modelId,\n              });\n              controller.enqueue({\n                type: 'finish',\n                finishReason: 'stop',\n                usage: {\n                  inputTokens: totalInputTokens,\n                  outputTokens: totalOutputTokens,\n                  totalTokens: totalInputTokens + totalOutputTokens,\n                },\n              });\n            }\n\n            controller.close();\n          } catch (error) {\n            controller.error(mapGeminiError(error));\n          } finally {\n            // Clean up abort listener\n            if (options.abortSignal && abortListener) {\n              options.abortSignal.removeEventListener('abort', abortListener);\n            }\n          }\n        },\n        cancel: () => {\n          // Clean up abort listener on cancel\n          if (options.abortSignal && abortListener) {\n            options.abortSignal.removeEventListener('abort', abortListener);\n          }\n        },\n      });\n\n      return {\n        stream,\n        rawCall: {\n          rawPrompt: { contents, systemInstruction, generationConfig, tools },\n          rawSettings: generationConfig as Record<string, unknown>,\n        },\n      };\n    } catch (error) {\n      throw mapGeminiError(error);\n    }\n  }\n}\n","import { randomUUID } from 'node:crypto';\nimport type {\n  ContentGenerator,\n  ContentGeneratorConfig,\n} from '@google/gemini-cli-core';\nimport {\n  createContentGenerator,\n  createContentGeneratorConfig,\n  AuthType,\n} from '@google/gemini-cli-core';\nimport type { GeminiProviderOptions } from './types';\n\nexport interface GeminiClient {\n  client: ContentGenerator;\n  config: ContentGeneratorConfig;\n  sessionId: string;\n}\n\n/**\n * Initializes the Gemini client with the provided authentication options\n */\nexport async function initializeGeminiClient(\n  options: GeminiProviderOptions,\n  modelId: string\n): Promise<GeminiClient> {\n  // Map our auth types to Gemini CLI Core auth types\n  let authType: AuthType | undefined;\n\n  if (options.authType === 'api-key' || options.authType === 'gemini-api-key') {\n    authType = AuthType.USE_GEMINI;\n  } else if (options.authType === 'vertex-ai') {\n    authType = AuthType.USE_VERTEX_AI;\n  } else if (\n    options.authType === 'oauth' ||\n    options.authType === 'oauth-personal'\n  ) {\n    authType = AuthType.LOGIN_WITH_GOOGLE;\n  } else if (options.authType === 'google-auth-library') {\n    // Google Auth Library is not directly supported by AuthType enum\n    // We'll need to handle this differently or use a default\n    authType = AuthType.USE_GEMINI;\n  }\n\n  // Generate a stable session ID for this provider instance\n  const sessionId = randomUUID();\n\n  // Phase 1: Core config methods with safe defaults\n  const baseConfig = {\n    // Required methods (currently working)\n    getModel: () => modelId,\n    getProxy: () =>\n      options.proxy ||\n      process.env.HTTP_PROXY ||\n      process.env.HTTPS_PROXY ||\n      undefined,\n    getUsageStatisticsEnabled: () => false, // Disable telemetry by default\n    getContentGeneratorConfig: () => ({\n      authType: authType, // Keep as AuthType | undefined for consistency\n      model: modelId,\n      apiKey: 'apiKey' in options ? options.apiKey : undefined,\n      vertexai: options.authType === 'vertex-ai' ? true : undefined,\n      proxy: options.proxy,\n    }),\n\n    // Core safety methods - most likely to be called\n    getSessionId: () => sessionId,\n    getDebugMode: () => false,\n    getTelemetryEnabled: () => false,\n    getTargetDir: () => process.cwd(),\n    getFullContext: () => false,\n    getIdeMode: () => false,\n    getCoreTools: () => [],\n    getExcludeTools: () => [],\n    getMaxSessionTurns: () => 100,\n    getFileFilteringRespectGitIgnore: () => true,\n\n    // OAuth-specific methods (required for LOGIN_WITH_GOOGLE auth)\n    isBrowserLaunchSuppressed: () => false, // Allow browser launch for OAuth flow\n  };\n\n  // Phase 2: Proxy wrapper to catch any unknown method calls\n  const configMock = new Proxy(baseConfig, {\n    get(target, prop) {\n      if (prop in target) {\n        return target[prop as keyof typeof target];\n      }\n\n      // Log unknown method calls (helps identify what else might be needed)\n      if (typeof prop === 'string') {\n        // Handle different method patterns\n        if (\n          prop.startsWith('get') ||\n          prop.startsWith('is') ||\n          prop.startsWith('has')\n        ) {\n          if (process.env.DEBUG) {\n            console.warn(\n              `[ai-sdk-provider-gemini-cli] Unknown config method called: ${prop}()`\n            );\n          }\n\n          // Return safe defaults based on method prefix and naming patterns\n          return () => {\n            // Boolean methods (is*, has*)\n            if (prop.startsWith('is') || prop.startsWith('has')) {\n              return false; // Safe default for boolean checks\n            }\n\n            // Getter methods (get*)\n            if (prop.startsWith('get')) {\n              // Return undefined for most unknown methods (safest default)\n              if (prop.includes('Enabled') || prop.includes('Mode')) {\n                return false; // Booleans default to false\n              }\n              if (\n                prop.includes('Registry') ||\n                prop.includes('Client') ||\n                prop.includes('Service')\n              ) {\n                return undefined; // Objects/services default to undefined\n              }\n              if (prop.includes('Config') || prop.includes('Options')) {\n                return {}; // Config objects default to empty\n              }\n              if (prop.includes('Command') || prop.includes('Path')) {\n                return undefined; // Strings default to undefined\n              }\n              return undefined; // Default fallback\n            }\n\n            return undefined; // Fallback for any other pattern\n          };\n        }\n      }\n\n      return undefined;\n    },\n  });\n\n  // Create the configuration\n  const config = createContentGeneratorConfig(\n    configMock as unknown as Parameters<typeof createContentGeneratorConfig>[0],\n    authType\n  );\n\n  // Apply additional configuration based on auth type\n  if (\n    (options.authType === 'api-key' || options.authType === 'gemini-api-key') &&\n    options.apiKey\n  ) {\n    config.apiKey = options.apiKey;\n  } else if (options.authType === 'vertex-ai' && options.vertexAI) {\n    config.vertexai = true;\n    // Note: Vertex AI project/location configuration might need to be\n    // handled through environment variables or other means\n  }\n\n  // Create content generator - pass the configMock as the second parameter and sessionId\n  const client = await createContentGenerator(\n    config,\n    configMock as unknown as Parameters<typeof createContentGenerator>[1],\n    sessionId\n  );\n\n  return { client, config, sessionId };\n}\n","import type {\n  LanguageModelV2CallOptions,\n  LanguageModelV2FilePart,\n  LanguageModelV2Message,\n} from '@ai-sdk/provider';\nimport type { Content, Part } from '@google/genai';\n\nexport interface GeminiPromptResult {\n  contents: Content[];\n  systemInstruction?: Content;\n}\n\n/**\n * Maps Vercel AI SDK messages to Gemini format\n */\nexport function mapPromptToGeminiFormat(\n  options: LanguageModelV2CallOptions\n): GeminiPromptResult {\n  let messages = options.prompt;\n  const contents: Content[] = [];\n  let systemInstruction: Content | undefined;\n\n  // If in json response format, enhance the last user message with schema information\n  if (\n    options.responseFormat?.type === 'json' &&\n    options.responseFormat.schema &&\n    messages.length > 0\n  ) {\n    const lastMessage = messages[messages.length - 1];\n    if (lastMessage.role === 'user' && Array.isArray(lastMessage.content)) {\n      const schemaPrompt = `\\n\\nYou must respond with a JSON object that exactly matches this schema:\\n${JSON.stringify(options.responseFormat.schema, null, 2)}\\n\\nIMPORTANT: Use the exact field names from the schema. Do not add extra fields.`;\n\n      // Clone the messages array and modify the last message\n      messages = [...messages];\n      const lastContent = [...lastMessage.content];\n\n      // Find the last text content and append to it\n      for (let i = lastContent.length - 1; i >= 0; i--) {\n        const content = lastContent[i];\n        if (content.type === 'text') {\n          lastContent[i] = {\n            ...content,\n            text: content.text + schemaPrompt,\n          };\n          break;\n        }\n      }\n\n      messages[messages.length - 1] = {\n        ...lastMessage,\n        content: lastContent,\n      };\n    }\n  }\n\n  for (const message of messages) {\n    switch (message.role) {\n      case 'system':\n        // Gemini uses a separate systemInstruction field\n        systemInstruction = {\n          role: 'user',\n          parts: [{ text: message.content }],\n        };\n        break;\n\n      case 'user':\n        contents.push(mapUserMessage(message));\n        break;\n\n      case 'assistant':\n        contents.push(mapAssistantMessage(message));\n        break;\n\n      case 'tool': {\n        // Tool results in v5 are part of tool messages\n        const parts: Part[] = [];\n        for (const part of message.content) {\n          if (part.type === 'tool-result') {\n            parts.push({\n              functionResponse: {\n                name: part.toolName,\n                response: (typeof part.output === 'string'\n                  ? { result: part.output }\n                  : part.output) as Record<string, unknown>,\n              },\n            });\n          }\n        }\n        contents.push({\n          role: 'user',\n          parts,\n        });\n        break;\n      }\n    }\n  }\n\n  return { contents, systemInstruction };\n}\n\n/**\n * Maps a user message to Gemini format\n */\nfunction mapUserMessage(\n  message: LanguageModelV2Message & { role: 'user' }\n): Content {\n  const parts: Part[] = [];\n\n  for (const part of message.content) {\n    switch (part.type) {\n      case 'text':\n        parts.push({ text: part.text });\n        break;\n\n      case 'file': {\n        // Handle file parts (images, etc.)\n        const mediaType = part.mediaType || 'application/octet-stream';\n        if (mediaType.startsWith('image/')) {\n          parts.push(mapImagePart(part));\n        } else {\n          throw new Error(`Unsupported file type: ${mediaType}`);\n        }\n        break;\n      }\n    }\n  }\n\n  return { role: 'user', parts };\n}\n\n/**\n * Maps an assistant message to Gemini format\n */\nfunction mapAssistantMessage(\n  message: LanguageModelV2Message & { role: 'assistant' }\n): Content {\n  const parts: Part[] = [];\n\n  for (const part of message.content) {\n    switch (part.type) {\n      case 'text':\n        parts.push({ text: part.text });\n        break;\n\n      case 'tool-call':\n        // In v5, tool calls have input as an object already\n        parts.push({\n          functionCall: {\n            name: part.toolName,\n            args: (part.input || {}) as Record<string, unknown>,\n          },\n        });\n        break;\n    }\n  }\n\n  return { role: 'model', parts };\n}\n\n/**\n * Maps an image part to Gemini format\n */\nfunction mapImagePart(part: LanguageModelV2FilePart): Part {\n  if (part.data instanceof URL) {\n    throw new Error(\n      'URL images are not supported by Gemini CLI Core. Please provide base64-encoded image data.'\n    );\n  }\n\n  // Extract mime type and base64 data\n  const mimeType = part.mediaType || 'image/jpeg';\n  let base64Data: string;\n\n  if (typeof part.data === 'string') {\n    // Already base64 encoded\n    base64Data = part.data;\n  } else if (part.data instanceof Uint8Array) {\n    // Convert Uint8Array to base64\n    base64Data = Buffer.from(part.data).toString('base64');\n  } else {\n    throw new Error('Unsupported image format');\n  }\n\n  return {\n    inlineData: {\n      mimeType,\n      data: base64Data,\n    },\n  };\n}\n","import type {\n  LanguageModelV2CallOptions,\n  LanguageModelV2FunctionTool,\n  LanguageModelV2ToolChoice,\n} from '@ai-sdk/provider';\nimport {\n  Tool,\n  FunctionDeclaration,\n  Schema,\n  ToolConfig,\n  FunctionCallingConfigMode,\n} from '@google/genai';\nimport { z } from 'zod';\n\n// Type for JSON Schema objects with common properties\ninterface JsonSchemaObject {\n  $schema?: string;\n  $ref?: string;\n  $defs?: unknown;\n  definitions?: unknown;\n  properties?: Record<string, unknown>;\n  items?: unknown;\n  additionalProperties?: unknown;\n  allOf?: unknown[];\n  anyOf?: unknown[];\n  oneOf?: unknown[];\n  [key: string]: unknown;\n}\n\n/**\n * Maps Vercel AI SDK tools to Gemini format\n */\nexport function mapToolsToGeminiFormat(\n  tools: LanguageModelV2FunctionTool[]\n): Tool[] {\n  const functionDeclarations: FunctionDeclaration[] = [];\n\n  for (const tool of tools) {\n    functionDeclarations.push({\n      name: tool.name,\n      description: tool.description,\n      parameters: convertToolParameters(tool.inputSchema),\n    });\n  }\n\n  return [{ functionDeclarations }];\n}\n\n/**\n * Attempts to convert a Zod schema to JSON Schema using available methods\n */\nfunction convertZodToJsonSchema(zodSchema: z.ZodSchema): unknown {\n  // Try Zod v4's native toJSONSchema function first (if available)\n  const zodWithToJSONSchema = z as unknown as {\n    toJSONSchema?: (schema: z.ZodSchema) => unknown;\n  };\n\n  if (\n    zodWithToJSONSchema.toJSONSchema &&\n    typeof zodWithToJSONSchema.toJSONSchema === 'function'\n  ) {\n    try {\n      // Zod v4 uses z.toJSONSchema(schema) as a standalone function\n      return zodWithToJSONSchema.toJSONSchema(zodSchema);\n    } catch {\n      // Method exists but failed, try fallback\n    }\n  }\n\n  // Try zod-to-json-schema for Zod v3 compatibility\n  try {\n    // Lazy load zod-to-json-schema to avoid import errors with Zod v4\n    // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-unsafe-assignment\n    const zodToJsonSchemaModule = require('zod-to-json-schema');\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    return zodToJsonSchemaModule.zodToJsonSchema(zodSchema);\n  } catch {\n    // zod-to-json-schema not available or not compatible\n  }\n\n  // No conversion method available\n  console.warn(\n    'Unable to convert Zod schema to JSON Schema. ' +\n      'For Zod v3, install zod-to-json-schema. ' +\n      'For Zod v4, use z.toJSONSchema() function.'\n  );\n\n  // Return a basic object schema as fallback\n  return { type: 'object' };\n}\n\n/**\n * Converts tool parameters from Zod schema or JSON schema to Gemini format\n */\nfunction convertToolParameters(parameters: unknown): Schema {\n  // If it's already a plain object (JSON schema), clean it\n  if (isJsonSchema(parameters)) {\n    return cleanJsonSchema(parameters as JsonSchemaObject) as Schema;\n  }\n\n  // If it's a Zod schema, convert to JSON schema first\n  if (isZodSchema(parameters)) {\n    const jsonSchema = convertZodToJsonSchema(parameters as z.ZodSchema);\n    return cleanJsonSchema(jsonSchema as JsonSchemaObject) as Schema;\n  }\n\n  // Return a basic schema if we can't identify the format\n  return parameters as Schema;\n}\n\n/**\n * Checks if an object is a JSON schema\n */\nfunction isJsonSchema(obj: unknown): boolean {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    ('type' in obj || 'properties' in obj || '$schema' in obj)\n  );\n}\n\n/**\n * Checks if an object is a Zod schema\n */\nfunction isZodSchema(obj: unknown): obj is z.ZodTypeAny {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    '_def' in obj &&\n    typeof (obj as z.ZodTypeAny)._def === 'object'\n  );\n}\n\n/**\n * Cleans JSON schema for Gemini compatibility\n * Removes $schema and other metadata that Gemini doesn't support\n */\nfunction cleanJsonSchema(schema: JsonSchemaObject): JsonSchemaObject {\n  if (typeof schema !== 'object' || schema === null) {\n    return schema;\n  }\n\n  const cleaned = { ...schema };\n\n  // Remove $schema property\n  delete cleaned.$schema;\n  delete cleaned.$ref;\n  delete cleaned.$defs;\n  delete cleaned.definitions;\n\n  // Recursively clean nested schemas\n  if (cleaned.properties && typeof cleaned.properties === 'object') {\n    const cleanedProps: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(cleaned.properties)) {\n      cleanedProps[key] = cleanJsonSchema(value as JsonSchemaObject);\n    }\n    cleaned.properties = cleanedProps;\n  }\n\n  if (cleaned.items) {\n    cleaned.items = cleanJsonSchema(cleaned.items as JsonSchemaObject);\n  }\n\n  if (\n    cleaned.additionalProperties &&\n    typeof cleaned.additionalProperties === 'object'\n  ) {\n    cleaned.additionalProperties = cleanJsonSchema(\n      cleaned.additionalProperties as JsonSchemaObject\n    );\n  }\n\n  // Clean arrays\n  for (const key of ['allOf', 'anyOf', 'oneOf'] as const) {\n    const arrayProp = cleaned[key];\n    if (Array.isArray(arrayProp)) {\n      cleaned[key] = arrayProp.map((item) =>\n        cleanJsonSchema(item as JsonSchemaObject)\n      );\n    }\n  }\n\n  return cleaned;\n}\n\n/**\n * Maps Vercel AI SDK tool config options to Gemini format\n */\nexport function mapGeminiToolConfig(\n  options: LanguageModelV2CallOptions\n): ToolConfig | undefined {\n  if (options.toolChoice) {\n    // Restrict allowed function names when a specific tool is forced.\n    // Gemini expects that when forcing a tool call, the function name is\n    // provided via `allowedFunctionNames` while `mode` is set to ANY.\n    const allowedFunctionNames =\n      options.toolChoice.type === 'tool'\n        ? [options.toolChoice.toolName]\n        : undefined;\n\n    return {\n      functionCallingConfig: {\n        allowedFunctionNames,\n        mode: mapToolChoiceToGeminiFormat(options.toolChoice),\n      },\n    };\n  }\n  return undefined;\n}\n\nfunction mapToolChoiceToGeminiFormat(\n  toolChoice: LanguageModelV2ToolChoice\n): FunctionCallingConfigMode {\n  switch (toolChoice.type) {\n    case 'auto':\n      return FunctionCallingConfigMode.AUTO;\n    case 'none':\n      return FunctionCallingConfigMode.NONE;\n    case 'required':\n    case 'tool':\n      return FunctionCallingConfigMode.ANY;\n    default:\n      // this should never happen if types are correct\n      return FunctionCallingConfigMode.MODE_UNSPECIFIED;\n  }\n}\n","import { APICallError, LoadAPIKeyError } from '@ai-sdk/provider';\n\n/**\n * Custom error metadata for Gemini CLI errors\n */\nexport interface GeminiCLIErrorMetadata {\n  code?: string;\n  exitCode?: number;\n  stderr?: string;\n  promptExcerpt?: string;\n}\n\n/**\n * Creates an API call error with Gemini-specific metadata\n */\nexport function createAPICallError({\n  message,\n  code,\n  exitCode,\n  stderr,\n  promptExcerpt,\n  isRetryable = false,\n  statusCode = 500,\n}: GeminiCLIErrorMetadata & {\n  message: string;\n  isRetryable?: boolean;\n  statusCode?: number;\n}): APICallError {\n  return new APICallError({\n    url: 'gemini-cli-core://command',\n    requestBodyValues: promptExcerpt ? { prompt: promptExcerpt } : {},\n    statusCode,\n    responseHeaders: {},\n    message,\n    data: {\n      code,\n      exitCode,\n      stderr,\n    },\n    isRetryable,\n  });\n}\n\n/**\n * Creates an authentication error\n */\nexport function createAuthenticationError({\n  message,\n}: {\n  message: string;\n}): LoadAPIKeyError {\n  return new LoadAPIKeyError({\n    message,\n  });\n}\n\n/**\n * Creates a timeout error\n */\nexport function createTimeoutError({\n  message,\n  promptExcerpt,\n}: {\n  message: string;\n  promptExcerpt?: string;\n}): APICallError {\n  return createAPICallError({\n    message,\n    code: 'TIMEOUT',\n    promptExcerpt,\n    isRetryable: true,\n    statusCode: 504,\n  });\n}\n\n/**\n * Checks if an error is an authentication error\n */\nexport function isAuthenticationError(error: unknown): boolean {\n  if (error instanceof LoadAPIKeyError) {\n    return true;\n  }\n\n  if (error instanceof Error) {\n    const message = error.message.toLowerCase();\n    return (\n      message.includes('unauthorized') ||\n      message.includes('authentication') ||\n      message.includes('api key') ||\n      message.includes('credentials')\n    );\n  }\n\n  return false;\n}\n\n/**\n * Checks if an error is a timeout error\n */\nexport function isTimeoutError(error: unknown): boolean {\n  if (error instanceof APICallError) {\n    return (\n      error.statusCode === 504 ||\n      (error.data as GeminiCLIErrorMetadata)?.code === 'TIMEOUT'\n    );\n  }\n\n  if (error instanceof Error) {\n    const message = error.message.toLowerCase();\n    return message.includes('timeout') || message.includes('timed out');\n  }\n\n  return false;\n}\n\n/**\n * Gets error metadata from an error\n */\nexport function getErrorMetadata(\n  error: unknown\n): GeminiCLIErrorMetadata | undefined {\n  if (error instanceof APICallError) {\n    return error.data as GeminiCLIErrorMetadata;\n  }\n\n  return undefined;\n}\n\n/**\n * Maps Gemini errors to Vercel AI SDK errors (v5 pattern)\n */\nexport function mapGeminiError(error: unknown): APICallError | LoadAPIKeyError {\n  if (error instanceof Error) {\n    // Don't wrap abort errors - they should pass through unchanged\n    if (error.name === 'AbortError') {\n      throw error;\n    }\n\n    const message = error.message.toLowerCase();\n\n    // Check for authentication errors\n    if (isAuthenticationError(error)) {\n      return createAuthenticationError({\n        message: error.message,\n      });\n    }\n\n    // Check for rate limit errors\n    if (message.includes('rate limit') || message.includes('quota')) {\n      return createAPICallError({\n        message: error.message,\n        code: 'RATE_LIMIT',\n        isRetryable: true,\n        statusCode: 429,\n      });\n    }\n\n    // Check for timeout errors\n    if (isTimeoutError(error)) {\n      return createTimeoutError({\n        message: error.message,\n      });\n    }\n\n    // Check for model not found (check this before general invalid errors)\n    if (\n      message.includes('not found') ||\n      message.includes('no such model') ||\n      (message.includes('model') &&\n        (message.includes('invalid') || message.includes('not found')))\n    ) {\n      return createAPICallError({\n        message: error.message,\n        code: 'MODEL_NOT_FOUND',\n        isRetryable: false,\n        statusCode: 404,\n      });\n    }\n\n    // Check for invalid request errors\n    if (message.includes('invalid') || message.includes('bad request')) {\n      return createAPICallError({\n        message: error.message,\n        code: 'INVALID_REQUEST',\n        isRetryable: false,\n        statusCode: 400,\n      });\n    }\n\n    // Default to internal server error\n    return createAPICallError({\n      message: error.message,\n      code: 'INTERNAL_ERROR',\n      isRetryable: true,\n      statusCode: 500,\n    });\n  }\n\n  // Unknown error type\n  return createAPICallError({\n    message: 'An unknown error occurred',\n    code: 'UNKNOWN_ERROR',\n    isRetryable: true,\n    statusCode: 500,\n  });\n}\n","/**\n * Extract JSON from model response using a tolerant parser.\n * Removes common wrappers such as markdown fences or variable declarations.\n */\nexport function extractJson(text: string): string {\n  let content = text.trim();\n\n  // Strip ```json or ``` fences\n  const fenceMatch = /```(?:json)?\\s*([\\s\\S]*?)\\s*```/i.exec(content);\n  if (fenceMatch) {\n    content = fenceMatch[1];\n  }\n\n  // Strip variable declarations like `const foo =` or `let foo =`\n  const varMatch = /^\\s*(?:const|let|var)\\s+\\w+\\s*=\\s*([\\s\\S]*)/i.exec(content);\n  if (varMatch) {\n    content = varMatch[1];\n    // Remove trailing semicolon if present\n    if (content.trim().endsWith(';')) {\n      content = content.trim().slice(0, -1);\n    }\n  }\n\n  // Find the first opening bracket\n  const firstObj = content.indexOf('{');\n  const firstArr = content.indexOf('[');\n  if (firstObj === -1 && firstArr === -1) {\n    return text;\n  }\n  const start =\n    firstArr === -1\n      ? firstObj\n      : firstObj === -1\n        ? firstArr\n        : Math.min(firstObj, firstArr);\n  content = content.slice(start);\n\n  // Try to parse the entire string\n  try {\n    const parsed = JSON.parse(content) as unknown;\n    return JSON.stringify(parsed);\n  } catch {\n    // Continue with more lenient parsing\n  }\n\n  // Find valid JSON boundaries by tracking nesting depth\n  const openChar = content[0];\n  const closeChar = openChar === '{' ? '}' : ']';\n\n  const closingPositions: number[] = [];\n  let depth = 0;\n  let inString = false;\n  let escapeNext = false;\n\n  for (let i = 0; i < content.length; i++) {\n    const char = content[i];\n\n    if (escapeNext) {\n      escapeNext = false;\n      continue;\n    }\n\n    if (char === '\\\\') {\n      escapeNext = true;\n      continue;\n    }\n\n    if (char === '\"' && !inString) {\n      inString = true;\n      continue;\n    }\n\n    if (char === '\"' && inString) {\n      inString = false;\n      continue;\n    }\n\n    // Skip content inside strings\n    if (inString) continue;\n\n    if (char === openChar) {\n      depth++;\n    } else if (char === closeChar) {\n      depth--;\n      if (depth === 0) {\n        closingPositions.push(i + 1);\n      }\n    }\n  }\n\n  // Try parsing at each valid closing position, starting from the end\n  for (let i = closingPositions.length - 1; i >= 0; i--) {\n    try {\n      const attempt = content.slice(0, closingPositions[i]);\n      const parsed = JSON.parse(attempt) as unknown;\n      return JSON.stringify(parsed);\n    } catch {\n      // Continue trying\n    }\n  }\n\n  return text;\n}\n","import type { GeminiProviderOptions } from './types';\n\n/**\n * Validates the authentication options for the Gemini provider.\n * Ensures that the provided configuration has valid authentication credentials.\n *\n * @param options - The provider options to validate\n * @returns The validated options\n * @throws Error if authentication configuration is invalid\n */\nexport function validateAuthOptions(\n  options: GeminiProviderOptions = {}\n): GeminiProviderOptions {\n  // Default to oauth-personal if no authType specified\n  const authType = options.authType || 'oauth-personal';\n\n  // Validate based on auth type\n  switch (authType) {\n    case 'api-key':\n    case 'gemini-api-key':\n      if (!('apiKey' in options) || !options.apiKey) {\n        throw new Error(`API key is required for ${authType} auth type`);\n      }\n      return { ...options, authType };\n\n    case 'vertex-ai':\n      if ('vertexAI' in options && options.vertexAI) {\n        if (\n          !options.vertexAI.projectId ||\n          options.vertexAI.projectId.trim() === ''\n        ) {\n          throw new Error('Project ID is required for vertex-ai auth type');\n        }\n        if (\n          !options.vertexAI.location ||\n          options.vertexAI.location.trim() === ''\n        ) {\n          throw new Error('Location is required for vertex-ai auth type');\n        }\n      } else {\n        throw new Error(\n          'Vertex AI configuration is required for vertex-ai auth type'\n        );\n      }\n      return { ...options, authType };\n\n    case 'oauth':\n    case 'oauth-personal':\n      // No additional validation needed for oauth\n      return { ...options, authType };\n\n    case 'google-auth-library':\n      if (!('googleAuth' in options) || !options.googleAuth) {\n        throw new Error(\n          'Google Auth Library instance is required for google-auth-library auth type'\n        );\n      }\n      return { ...options, authType };\n\n    default:\n      throw new Error(`Invalid auth type: ${String(authType)}`);\n  }\n}\n"],"mappings":"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","names":["randomUUID","randomUUID"]}