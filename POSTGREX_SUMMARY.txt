================================================================================
POSTGREX.QUERY!() ANALYSIS SUMMARY - CodeSearch Module
================================================================================

FILE: singularity/lib/singularity/search/code_search.ex
TOTAL LINES: 1,273
TOTAL POSTGREX.QUERY!() CALLS: 48

================================================================================
BREAKDOWN BY OPERATION TYPE
================================================================================

DDL OPERATIONS (Schema/Index Creation): 33 calls (69%)
├── Table Creation: 8 calls
│   ├── codebase_metadata (line 58)
│   ├── codebase_registry (line 160)
│   ├── graph_nodes (line 184)
│   ├── graph_edges (line 207)
│   ├── graph_types (line 230)
│   ├── vector_search (line 260)
│   ├── vector_similarity_cache (line 280)
│   └── Apache AGE extension (line 534)
│
└── Index Creation: 25 calls (lines 300-528)
    ├── codebase_metadata: 9 indexes
    ├── codebase_registry: 3 indexes
    ├── graph_nodes: 5 indexes
    ├── graph_edges: 4 indexes
    └── vector_search: 4 indexes

DML OPERATIONS (Data Manipulation): 6 calls (13%)
├── INSERT operations: 5 calls
│   ├── register_codebase (line 560) - 7 params
│   ├── insert_codebase_metadata (line 708) - 55 params [COMPLEX]
│   ├── insert_graph_node (line 859) - 9 params
│   ├── insert_graph_edge (line 893) - 7 params
│   └── create_graph_tables defaults (line 244)
│
└── UPDATE operations: 1 call
    └── update_codebase_status (line 690) - 3 params

QUERY OPERATIONS (Data Retrieval): 9 calls (18%)
├── Simple/Medium Complexity: 4 calls
│   ├── get_codebase_registry (line 592) - SELECT WHERE
│   ├── list_codebases (line 644) - SELECT ORDER BY
│   ├── get_dependencies (line 1093) - SELECT with JOIN
│   └── get_dependents (line 1127) - SELECT with JOIN
│
└── High Complexity: 5 calls (Vector + CTE operations)
    ├── semantic_search (line 961) - Vector similarity search
    ├── find_similar_nodes (line 990) - CTE + CROSS JOIN
    ├── multi_codebase_search (line 1047) - Dynamic WHERE IN
    ├── detect_circular_dependencies (line 1161) - RECURSIVE CTE
    └── calculate_pagerank (line 1223) - RECURSIVE CTE

================================================================================
CONVERSION IMPACT ASSESSMENT
================================================================================

Quick Wins (High Impact, Low Effort):
1. Move all DDL to Ecto migrations: 33 calls removed
   - Consolidates schema management
   - Enables version control for schema changes
   - Improves testing isolation
   Effort: HIGH | Impact: VERY HIGH

2. Create 4 Ecto Schemas:
   - Singularity.Search.CodebaseMetadata
   - Singularity.Search.CodebaseRegistry
   - Singularity.Search.GraphNode
   - Singularity.Search.GraphEdge
   Effort: MEDIUM | Impact: HIGH

3. Convert DML operations to Ecto:
   - Use Repo.insert_or_update!() with Changesets
   - 6 functions affected
   Effort: MEDIUM | Impact: MEDIUM

4. Keep Complex Queries as SQL:
   - Use Ecto.Adapters.SQL.query!() pattern (already shown at line 955!)
   - Works for vector operations, CTEs, etc.
   Effort: LOW | Impact: NONE (already in use)

================================================================================
EXISTING ECTO INTEGRATION
================================================================================

GOOD NEWS: semantic_search/4 (lines 933-984) already shows the conversion pattern!

Current Implementation:
- Accepts both Ecto.Repo AND raw Postgrex connection
- Uses Ecto.Adapters.SQL.query!() for complex queries (line 955)
- Falls back to Postgrex.query!() for backwards compatibility (line 961)

This is the TEMPLATE for converting all remaining complex queries.

================================================================================
RECOMMENDED MIGRATION PHASES
================================================================================

PHASE 1: Foundation (2-3 days)
- Create 4 Ecto schemas with all fields
- Write initial migration with table creation
- Create changeset functions

PHASE 2: Migrations (1-2 days)
- Extract 33 DDL calls into proper migrations
- Separate indexes into 2nd migration (optional)
- Test migrations run without errors

PHASE 3: Data Functions (1-2 days)
- Convert insert/update operations to Repo methods
- Use insert_or_update!() for ON CONFLICT logic
- Update function signatures: db_conn → repo

PHASE 4: Query Functions (1 day)
- Simple queries → Ecto.Query
- Complex queries → Ecto.Adapters.SQL.query! (pattern exists!)
- Maintain backwards compatibility option if needed

PHASE 5: Testing & Cleanup (1-2 days)
- Test with Ecto.Sandbox
- Remove raw Postgrex usage except in tests
- Verify performance with real data

TOTAL ESTIMATED EFFORT: 5-10 days for complete migration

================================================================================
FILES GENERATED
================================================================================

1. POSTGREX_ANALYSIS.md
   - Comprehensive analysis of all 48 calls
   - Usage patterns and complexity assessment
   - Conversion recommendations with examples
   - Effort/impact breakdown

2. POSTGREX_LINE_REFERENCE.md
   - Line-by-line index of all 48 calls
   - Function groupings and dependencies
   - Migration consolidation plan
   - Ecto schema templates
   - Before/after conversion examples

3. This summary (POSTGREX_SUMMARY.txt)

================================================================================
KEY INSIGHTS
================================================================================

1. Well-Organized Code:
   - Clear separation of DDL, DML, and Query operations
   - Consistent use of ! operators for error handling
   - Good documentation of vector operations

2. Migration Priority:
   - DDL → Move to migrations FIRST (33 calls)
   - DML → Convert to Ecto SECOND (6 calls)
   - Queries → Use existing pattern THIRD (9 calls)

3. No Major Blockers:
   - Ecto supports all required operations
   - Pattern already demonstrated in semantic_search/4
   - pgvector and vector operations supported via SQL

4. Testing Benefits:
   - Ecto.Sandbox enables true test isolation
   - No need for separate test databases
   - Transactions rolled back after each test

================================================================================
CONVERSION CHECKLIST
================================================================================

Migrations:
  [ ] Create migration for 7 core tables
  [ ] Create migration for 25 indexes
  [ ] Create migration for Apache AGE extension
  [ ] Test migration runs both up and down

Schemas & Changesets:
  [ ] CodebaseMetadata schema (99 fields!)
  [ ] CodebaseRegistry schema (10 fields)
  [ ] GraphNode schema (9 fields)
  [ ] GraphEdge schema (7 fields)
  [ ] Test changesets validate correctly

DML Functions:
  [ ] register_codebase/5 → use Repo.insert_or_update!()
  [ ] insert_codebase_metadata/3 → use Repo.insert_or_update!()
  [ ] insert_graph_node/2 → use Repo.insert_or_update!()
  [ ] insert_graph_edge/2 → use Repo.insert_or_update!()
  [ ] update_codebase_status/3 → use Repo.update!()

Query Functions:
  [ ] get_codebase_registry/2 → Ecto.Query
  [ ] list_codebases/1 → Ecto.Query
  [ ] semantic_search/4 → already using Ecto.Adapters.SQL.query!
  [ ] find_similar_nodes/3 → Ecto.Adapters.SQL.query! (complex)
  [ ] multi_codebase_search/4 → Ecto.Adapters.SQL.query! (complex)
  [ ] get_dependencies/2 → Ecto.Query or SQL
  [ ] get_dependents/2 → Ecto.Query or SQL
  [ ] detect_circular_dependencies/1 → Ecto.Adapters.SQL.query! (CTE)
  [ ] calculate_pagerank/3 → Ecto.Adapters.SQL.query! (CTE)

Testing:
  [ ] Run all functions with Ecto.Sandbox
  [ ] Verify vector operations work correctly
  [ ] Test with real codebase data
  [ ] Performance benchmarking

================================================================================
