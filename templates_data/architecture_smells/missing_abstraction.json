{
  "pattern_id": "missing_abstraction",
  "name": "Missing Abstraction Layer",
  "description": "Detect duplicate code and patterns indicating missing abstraction",
  "severity": "medium",
  "type": "code_smell",

  "indicators": [
    {
      "indicator": "Code Duplication",
      "threshold": "> 3 copies of same logic",
      "impact": "Hard to maintain, bug fixes must be repeated",
      "detection_methods": [
        {
          "method": "Token-based detection",
          "description": "Find sequences of similar tokens",
          "threshold": "> 50 tokens repeated"
        },
        {
          "method": "AST-based detection",
          "description": "Compare abstract syntax trees",
          "threshold": "Structural similarity > 80%"
        },
        {
          "method": "Semantic detection",
          "description": "Find functionally equivalent code",
          "example": "Different variable names, same logic"
        }
      ],
      "examples": [
        "Copy-pasted validation logic",
        "Repeated error handling",
        "Duplicate business rules"
      ]
    },
    {
      "indicator": "Similar Function Signatures",
      "description": "Multiple functions doing similar things with different names",
      "patterns": [
        "getUserById(), getCustomerById(), getAccountById()",
        "validateEmail(), checkEmail(), verifyEmail()",
        "formatDate(), dateToString(), convertDate()"
      ],
      "detection": "Analyze function names and parameters for similarity"
    },
    {
      "indicator": "Conditional Branches Handling Similar Cases",
      "description": "Large if/else or switch handling multiple similar cases",
      "threshold": "> 5 similar branches",
      "examples": [
        "Switch with similar case handling",
        "If-else chain with repeated logic",
        "Multiple instanceof checks"
      ],
      "code_example": {
        "bad": "if (type == 'A') { processA(); } else if (type == 'B') { processB(); }",
        "good": "processor = getProcessor(type); processor.process();"
      }
    },
    {
      "indicator": "Repeated Data Structures",
      "description": "Similar data structures defined multiple times",
      "examples": [
        "Multiple classes with same fields",
        "Repeated configuration objects",
        "Duplicate DTOs"
      ],
      "threshold": "> 3 similar structures"
    },
    {
      "indicator": "Pattern Repetition",
      "description": "Same pattern implemented multiple times",
      "patterns": [
        "Manual object creation instead of factory",
        "Repeated null checks instead of null object pattern",
        "Multiple retry logic implementations"
      ]
    },
    {
      "indicator": "Magic Numbers/Strings",
      "description": "Repeated literals throughout codebase",
      "examples": [
        "Same timeout value in multiple places",
        "Repeated regex patterns",
        "Duplicate error messages"
      ],
      "threshold": "> 2 occurrences of same literal"
    },
    {
      "indicator": "Similar Exception Handling",
      "description": "Repeated exception handling logic",
      "patterns": [
        "Same try-catch blocks",
        "Repeated logging logic",
        "Duplicate recovery mechanisms"
      ]
    },
    {
      "indicator": "Parallel Class Hierarchies",
      "description": "Multiple inheritance trees with similar structure",
      "example": "Employee hierarchy mirrors Customer hierarchy",
      "impact": "Changes must be made in multiple places"
    }
  ],

  "types_of_duplication": {
    "exact_duplication": {
      "description": "Identical code blocks",
      "severity": "high",
      "detection": "Character-by-character comparison",
      "remediation": "Extract to method/function"
    },
    "parameterized_duplication": {
      "description": "Similar code with different values",
      "severity": "medium",
      "detection": "Token analysis ignoring literals",
      "remediation": "Extract method with parameters"
    },
    "structural_duplication": {
      "description": "Similar structure, different details",
      "severity": "medium",
      "detection": "AST comparison",
      "remediation": "Template method or strategy pattern"
    },
    "semantic_duplication": {
      "description": "Different code, same behavior",
      "severity": "low",
      "detection": "Behavioral analysis",
      "remediation": "Standardize implementation"
    },
    "design_duplication": {
      "description": "Repeated design patterns",
      "severity": "medium",
      "detection": "Architecture analysis",
      "remediation": "Create framework or library"
    }
  },

  "remediation": {
    "approach": "Extract Common Abstraction",
    "method": "Create shared function/class/module for common logic",
    "strategies": [
      {
        "strategy": "Extract Method",
        "when": "Duplicate code within same class",
        "steps": [
          "Identify common code",
          "Extract to private method",
          "Replace duplicates with method call",
          "Add parameters for variations"
        ],
        "example": {
          "before": "calculateTax() and calculateFee() with similar logic",
          "after": "calculate(rate, amount)"
        }
      },
      {
        "strategy": "Extract Class",
        "when": "Duplicate code across classes",
        "steps": [
          "Create new class for common functionality",
          "Move duplicate code to new class",
          "Update original classes to use new class",
          "Consider inheritance vs composition"
        ],
        "example": {
          "before": "User and Customer with duplicate validation",
          "after": "Validator class used by both"
        }
      },
      {
        "strategy": "Pull Up Method",
        "when": "Duplicate code in sibling classes",
        "steps": [
          "Identify common parent class",
          "Move duplicate code to parent",
          "Make method protected/public as needed",
          "Override only when necessary"
        ]
      },
      {
        "strategy": "Extract Interface",
        "when": "Similar behavior across unrelated classes",
        "steps": [
          "Define interface with common methods",
          "Implement interface in classes",
          "Use interface type in client code",
          "Apply dependency injection"
        ]
      },
      {
        "strategy": "Template Method Pattern",
        "when": "Similar algorithms with variations",
        "steps": [
          "Create abstract base class",
          "Define template method with algorithm",
          "Create abstract methods for variations",
          "Implement variations in subclasses"
        ]
      },
      {
        "strategy": "Strategy Pattern",
        "when": "Multiple implementations of same algorithm",
        "steps": [
          "Define strategy interface",
          "Create concrete strategy classes",
          "Use context class to switch strategies",
          "Configure strategy at runtime"
        ]
      },
      {
        "strategy": "Create Library/Framework",
        "when": "Pattern repeated across projects",
        "steps": [
          "Identify reusable components",
          "Create separate module/package",
          "Define clear API",
          "Document and test thoroughly",
          "Publish for reuse"
        ]
      }
    ]
  },

  "detection_techniques": {
    "clone_detection": {
      "text_based": {
        "description": "Line-by-line comparison",
        "pros": "Fast, language agnostic",
        "cons": "Sensitive to formatting"
      },
      "token_based": {
        "description": "Lexical token comparison",
        "pros": "Ignores formatting, comments",
        "cons": "Misses semantic clones"
      },
      "tree_based": {
        "description": "AST comparison",
        "pros": "Finds structural similarity",
        "cons": "Computationally expensive"
      },
      "metric_based": {
        "description": "Compare code metrics",
        "pros": "Fast, scalable",
        "cons": "May miss clones"
      },
      "semantic_based": {
        "description": "Program dependency graph",
        "pros": "Finds functional clones",
        "cons": "Very expensive"
      }
    }
  },

  "metrics": {
    "duplication_percentage": {
      "name": "Code Duplication Ratio",
      "formula": "(duplicated_lines / total_lines) * 100",
      "good": "< 5%",
      "concerning": "5-10%",
      "critical": "> 10%"
    },
    "clone_coverage": {
      "name": "Clone Coverage",
      "description": "Percentage of code involved in clones",
      "good": "< 3%",
      "concerning": "3-7%",
      "critical": "> 7%"
    },
    "largest_clone_size": {
      "name": "Maximum Clone Size",
      "description": "Lines in largest duplicated block",
      "good": "< 10 lines",
      "concerning": "10-50 lines",
      "critical": "> 50 lines"
    },
    "clone_instances": {
      "name": "Number of Clone Instances",
      "description": "Total number of duplicated code blocks",
      "good": "< 10",
      "concerning": "10-50",
      "critical": "> 50"
    }
  },

  "prevention": {
    "practices": [
      "DRY (Don't Repeat Yourself) principle",
      "Regular refactoring sessions",
      "Code reviews focusing on duplication",
      "Pair programming to spot patterns",
      "Automated duplication detection in CI/CD"
    ],
    "design_principles": [
      "Single Source of Truth",
      "Abstraction over Implementation",
      "Composition over Inheritance",
      "Open/Closed Principle"
    ],
    "tools_configuration": {
      "minimum_lines": 5,
      "minimum_tokens": 50,
      "similarity_threshold": 0.8,
      "ignore_patterns": [
        "Generated code",
        "Test fixtures",
        "Boilerplate"
      ]
    }
  },

  "tools": {
    "detection": [
      {
        "name": "PMD CPD",
        "languages": ["Java", "C++", "Python"],
        "type": "Token-based"
      },
      {
        "name": "Simian",
        "languages": ["Multiple"],
        "type": "Text-based"
      },
      {
        "name": "jscpd",
        "languages": ["JavaScript", "TypeScript"],
        "type": "Token-based"
      },
      {
        "name": "CloneDR",
        "languages": ["Multiple"],
        "type": "AST-based"
      },
      {
        "name": "SonarQube",
        "languages": ["Multiple"],
        "type": "Mixed approach"
      }
    ],
    "refactoring": [
      "IntelliJ IDEA Refactoring Tools",
      "Eclipse Refactoring Support",
      "VS Code Refactoring Extensions",
      "ReSharper for Visual Studio"
    ]
  },

  "case_studies": {
    "example_1": {
      "problem": "User validation repeated in 5 controllers",
      "solution": "Created ValidationService",
      "impact": "Reduced code by 200 lines, fixed 3 bugs once"
    },
    "example_2": {
      "problem": "Database connection logic duplicated",
      "solution": "Implemented connection pool factory",
      "impact": "Improved performance, centralized configuration"
    },
    "example_3": {
      "problem": "Similar report generation for different entities",
      "solution": "Template method pattern with ReportGenerator base",
      "impact": "Adding new reports reduced from days to hours"
    }
  }
}