{
  "framework_id": "rails",
  "framework_name": "Ruby on Rails",
  "version_target": "6.0+",
  "description": "Security patterns and vulnerability detection for Ruby on Rails applications",

  "vulnerability_patterns": [
    {
      "vulnerability_id": "rails_mass_assignment",
      "name": "Mass Assignment Vulnerability",
      "cwe": "CWE-915",
      "severity": "high",
      "description": "Accepting all parameters without whitelisting",

      "bad_patterns": [
        {
          "code": "User.create(params[:user])",
          "issue": "All params accepted, including admin flag"
        },
        {
          "code": "@user.update_attributes(params[:user])",
          "issue": "Direct parameter assignment without filtering"
        },
        {
          "code": "User.new(params)",
          "issue": "Entire params hash assigned"
        }
      ],

      "good_patterns": [
        {
          "code": "User.create(user_params)\n\nprivate\ndef user_params\n  params.require(:user).permit(:name, :email)\nend",
          "explanation": "Explicit parameter whitelisting with Strong Parameters"
        },
        {
          "code": "class User < ApplicationRecord\n  attr_accessible :name, :email\n  # For Rails 3.x compatibility\nend",
          "explanation": "Model-level attribute protection (Rails 3.x)"
        },
        {
          "code": "@user.update(user_params.slice(:name, :email))",
          "explanation": "Use slice to limit allowed attributes"
        }
      ]
    },
    {
      "vulnerability_id": "rails_sql_injection",
      "name": "SQL Injection via String Interpolation",
      "cwe": "CWE-89",
      "severity": "critical",
      "description": "Dynamic SQL construction with user input",

      "bad_patterns": [
        {
          "code": "User.where(\"email = '#{email}'\")",
          "issue": "String interpolation in where clause"
        },
        {
          "code": "User.find_by_sql(\"SELECT * FROM users WHERE name = '#{name}'\")",
          "issue": "Raw SQL with string interpolation"
        },
        {
          "code": "User.where(\"role = '#{params[:role]}'\")",
          "issue": "Direct parameter injection"
        },
        {
          "code": "User.order(\"#{params[:sort_column]} #{params[:direction]}\")",
          "issue": "User controlled ORDER BY clause"
        }
      ],

      "good_patterns": [
        {
          "code": "User.where(email: email)",
          "explanation": "Use hash syntax for automatic parameterization"
        },
        {
          "code": "User.where('email = ?', email)",
          "explanation": "Use placeholders with parameters"
        },
        {
          "code": "User.where(['name = :name AND role = :role', { name: name, role: role }])",
          "explanation": "Named placeholders for complex queries"
        },
        {
          "code": "ALLOWED_COLUMNS = %w[name created_at email]\ncolumn = params[:sort_column]\nif ALLOWED_COLUMNS.include?(column)\n  User.order(Arel.sql(\"#{column} DESC\"))\nend",
          "explanation": "Whitelist allowed columns for dynamic ordering"
        }
      ]
    },
    {
      "vulnerability_id": "rails_xss",
      "name": "Cross-Site Scripting (XSS)",
      "cwe": "CWE-79",
      "severity": "high",
      "description": "Rendering unescaped user content",

      "bad_patterns": [
        {
          "code": "<%= raw user_content %>",
          "issue": "raw helper bypasses HTML escaping"
        },
        {
          "code": "<%= content.html_safe %>",
          "issue": "Marking user content as html_safe"
        },
        {
          "code": "<%= \"<h1>#{params[:title]}</h1>\".html_safe %>",
          "issue": "Concatenating user input with html_safe"
        },
        {
          "code": "render inline: params[:template]",
          "issue": "Rendering user-controlled templates"
        }
      ],

      "good_patterns": [
        {
          "code": "<%= user_content %>",
          "explanation": "Rails escapes output by default"
        },
        {
          "code": "<%= h(user_content) %>",
          "explanation": "Explicit HTML escaping"
        },
        {
          "code": "<%= sanitize(user_content, tags: %w[p br strong em], attributes: %w[]) %>",
          "explanation": "Sanitize HTML with allowed tags"
        },
        {
          "code": "<%= content_tag :h1, params[:title] %>",
          "explanation": "Use Rails helpers that escape content"
        }
      ]
    },
    {
      "vulnerability_id": "rails_csrf",
      "name": "CSRF Token Bypass",
      "cwe": "CWE-352",
      "severity": "high",
      "description": "Missing or disabled CSRF protection",

      "bad_patterns": [
        {
          "code": "class ApplicationController < ActionController::Base\n  skip_before_action :verify_authenticity_token\nend",
          "issue": "CSRF protection disabled globally"
        },
        {
          "code": "protect_from_forgery with: :null_session",
          "issue": "CSRF protection weakened"
        },
        {
          "code": "<form action=\"/transfer\" method=\"post\">\n  <input name=\"amount\" value=\"1000\">\n</form>",
          "issue": "Form without CSRF token"
        }
      ],

      "good_patterns": [
        {
          "code": "class ApplicationController < ActionController::Base\n  protect_from_forgery with: :exception\nend",
          "explanation": "Enable CSRF protection with exception strategy"
        },
        {
          "code": "<%= form_with url: transfer_path do |form| %>\n  <%= form.text_field :amount %>\n  <%= form.submit %>\n<% end %>",
          "explanation": "Rails form helpers include CSRF token automatically"
        },
        {
          "code": "# For API endpoints expecting JSON\nclass ApiController < ApplicationController\n  protect_from_forgery with: :null_session, if: -> { request.format.json? }\nend",
          "explanation": "Conditional CSRF for API endpoints"
        }
      ]
    },
    {
      "vulnerability_id": "rails_insecure_redirect",
      "name": "Open Redirect Vulnerability",
      "cwe": "CWE-601",
      "severity": "medium",
      "description": "Unvalidated redirects to user-controlled URLs",

      "bad_patterns": [
        {
          "code": "redirect_to params[:return_to]",
          "issue": "Direct redirect to user input"
        },
        {
          "code": "redirect_to request.referer",
          "issue": "Trusting referer header"
        },
        {
          "code": "redirect_to session[:redirect_url]",
          "issue": "Redirect to unvalidated session data"
        }
      ],

      "good_patterns": [
        {
          "code": "def safe_redirect_url(url)\n  uri = URI.parse(url)\n  uri.host == request.host ? url : root_path\nrescue URI::InvalidURIError\n  root_path\nend\n\nredirect_to safe_redirect_url(params[:return_to])",
          "explanation": "Validate redirect host matches application"
        },
        {
          "code": "ALLOWED_REDIRECTS = [root_path, dashboard_path, profile_path]\nredirect_url = params[:return_to]\nif ALLOWED_REDIRECTS.include?(redirect_url)\n  redirect_to redirect_url\nelse\n  redirect_to root_path\nend",
          "explanation": "Whitelist allowed redirect destinations"
        },
        {
          "code": "redirect_back(fallback_location: root_path, allow_other_host: false)",
          "explanation": "Use Rails redirect_back with host restriction"
        }
      ]
    },
    {
      "vulnerability_id": "rails_file_upload",
      "name": "Unrestricted File Upload",
      "cwe": "CWE-434",
      "severity": "high",
      "description": "Accepting dangerous file uploads without validation",

      "bad_patterns": [
        {
          "code": "def upload\n  uploaded_file = params[:file]\n  File.open(Rails.root.join('public', uploaded_file.original_filename), 'wb') do |file|\n    file.write(uploaded_file.read)\n  end\nend",
          "issue": "No file type or size validation"
        },
        {
          "code": "send_file params[:file_path]",
          "issue": "Path traversal in file download"
        }
      ],

      "good_patterns": [
        {
          "code": "class User < ApplicationRecord\n  has_one_attached :avatar\n  \n  validates :avatar, content_type: { in: %w[image/png image/jpg image/jpeg],\n                                      message: 'must be a PNG or JPG image' },\n                     size: { less_than: 5.megabytes }\nend",
          "explanation": "Use Active Storage with validations"
        },
        {
          "code": "ALLOWED_EXTENSIONS = %w[.pdf .txt .docx]\nfilename = params[:file].original_filename\nextension = File.extname(filename).downcase\n\nif ALLOWED_EXTENSIONS.include?(extension)\n  # Process file\nelse\n  flash[:error] = 'Invalid file type'\nend",
          "explanation": "Validate file extensions explicitly"
        }
      ]
    },
    {
      "vulnerability_id": "rails_command_injection",
      "name": "Command Injection",
      "cwe": "CWE-78",
      "severity": "critical",
      "description": "Executing system commands with user input",

      "bad_patterns": [
        {
          "code": "system(\"convert #{params[:file]} output.pdf\")",
          "issue": "User input in system command"
        },
        {
          "code": "`ping #{params[:host]}`",
          "issue": "Backticks with user input"
        },
        {
          "code": "exec(\"ls #{params[:directory]}\")",
          "issue": "exec with user-controlled arguments"
        }
      ],

      "good_patterns": [
        {
          "code": "system('convert', params[:file], 'output.pdf')",
          "explanation": "Use array form to avoid shell interpretation"
        },
        {
          "code": "require 'shellwords'\nsystem(\"convert #{Shellwords.escape(params[:file])} output.pdf\")",
          "explanation": "Escape shell arguments with Shellwords"
        },
        {
          "code": "Open3.capture2('ping', '-c', '4', params[:host])",
          "explanation": "Use Open3 with array arguments"
        }
      ]
    },
    {
      "vulnerability_id": "rails_yaml_deserialization",
      "name": "YAML Deserialization",
      "cwe": "CWE-502",
      "severity": "critical",
      "description": "Unsafe YAML parsing can execute arbitrary code",

      "bad_patterns": [
        {
          "code": "YAML.load(params[:config])",
          "issue": "YAML.load can instantiate arbitrary objects"
        },
        {
          "code": "config = YAML.load(File.read(params[:config_file]))",
          "issue": "Loading untrusted YAML files"
        }
      ],

      "good_patterns": [
        {
          "code": "YAML.safe_load(params[:config])",
          "explanation": "Use safe_load to restrict object types"
        },
        {
          "code": "YAML.safe_load(params[:config], permitted_classes: [Symbol, Date])",
          "explanation": "Explicitly allow specific classes if needed"
        },
        {
          "code": "JSON.parse(params[:config])",
          "explanation": "Use JSON instead of YAML when possible"
        }
      ]
    }
  ],

  "security_settings": [
    {
      "setting": "force_ssl",
      "recommendation": "true in production",
      "purpose": "Force HTTPS for all requests"
    },
    {
      "setting": "config.session_store",
      "recommendation": "Use :cookie_store with secure and httponly flags",
      "purpose": "Secure session cookie configuration"
    },
    {
      "setting": "secrets.secret_key_base",
      "recommendation": "Use strong random key, store in credentials",
      "purpose": "Secure cookie signing"
    },
    {
      "setting": "config.filter_parameters",
      "recommendation": "Include :password, :token, :secret",
      "purpose": "Prevent sensitive data in logs"
    },
    {
      "setting": "default_headers",
      "recommendation": "Set X-Frame-Options, X-Content-Type-Options, X-XSS-Protection",
      "purpose": "Security headers for browser protection"
    }
  ]
}