{
  "framework_id": "express",
  "framework_name": "Express.js",
  "version_target": "4.17+",
  "description": "Security patterns and vulnerability detection for Express.js applications",

  "vulnerability_patterns": [
    {
      "vulnerability_id": "express_sql_injection",
      "name": "SQL Injection in Database Queries",
      "cwe": "CWE-89",
      "severity": "critical",
      "description": "Dynamic SQL construction with user input",

      "bad_patterns": [
        {
          "code": "app.get('/user/:id', (req, res) => {\n  const query = `SELECT * FROM users WHERE id = ${req.params.id}`;\n  db.query(query, (err, result) => {\n    res.json(result);\n  });\n});",
          "issue": "Template literal with user input in SQL"
        },
        {
          "code": "app.post('/search', (req, res) => {\n  const sql = \"SELECT * FROM products WHERE name LIKE '%\" + req.body.search + \"%'\";\n  connection.query(sql, (error, results) => {\n    res.json(results);\n  });\n});",
          "issue": "String concatenation in LIKE clause"
        },
        {
          "code": "app.get('/items', (req, res) => {\n  const sortBy = req.query.sort;\n  const query = `SELECT * FROM items ORDER BY ${sortBy}`;\n  db.execute(query).then(results => res.json(results));\n});",
          "issue": "User-controlled ORDER BY clause"
        }
      ],

      "good_patterns": [
        {
          "code": "app.get('/user/:id', (req, res) => {\n  const query = 'SELECT * FROM users WHERE id = ?';\n  db.query(query, [req.params.id], (err, result) => {\n    if (err) return res.status(500).json({ error: 'Database error' });\n    res.json(result);\n  });\n});",
          "explanation": "Use parameterized queries with placeholders"
        },
        {
          "code": "app.post('/search', async (req, res) => {\n  const searchTerm = `%${req.body.search}%`;\n  const [rows] = await db.execute(\n    'SELECT * FROM products WHERE name LIKE ?',\n    [searchTerm]\n  );\n  res.json(rows);\n});",
          "explanation": "Parameterized LIKE query"
        },
        {
          "code": "const ALLOWED_SORT_COLUMNS = ['name', 'created_at', 'price'];\n\napp.get('/items', (req, res) => {\n  const sortBy = req.query.sort;\n  \n  if (!ALLOWED_SORT_COLUMNS.includes(sortBy)) {\n    return res.status(400).json({ error: 'Invalid sort column' });\n  }\n  \n  const query = `SELECT * FROM items ORDER BY \\`${sortBy}\\``;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
          "explanation": "Whitelist allowed columns for dynamic queries"
        }
      ]
    },
    {
      "vulnerability_id": "express_xss",
      "name": "Cross-Site Scripting (XSS)",
      "cwe": "CWE-79",
      "severity": "high",
      "description": "Rendering unescaped user input",

      "bad_patterns": [
        {
          "code": "app.get('/profile/:name', (req, res) => {\n  res.send(`<h1>Welcome ${req.params.name}</h1>`);\n});",
          "issue": "User input directly in HTML response"
        },
        {
          "code": "app.post('/comment', (req, res) => {\n  const html = `<div class=\"comment\">${req.body.comment}</div>`;\n  res.send(html);\n});",
          "issue": "Unescaped user content in HTML"
        },
        {
          "code": "app.get('/search', (req, res) => {\n  res.render('search', {\n    results: `No results for <b>${req.query.q}</b>`,\n    safe: true  // Disables escaping in template\n  });\n});",
          "issue": "Marking user input as safe in template"
        }
      ],

      "good_patterns": [
        {
          "code": "const escapeHtml = require('escape-html');\n\napp.get('/profile/:name', (req, res) => {\n  const safeName = escapeHtml(req.params.name);\n  res.send(`<h1>Welcome ${safeName}</h1>`);\n});",
          "explanation": "Escape HTML entities before rendering"
        },
        {
          "code": "const DOMPurify = require('isomorphic-dompurify');\n\napp.post('/comment', (req, res) => {\n  const cleanComment = DOMPurify.sanitize(req.body.comment);\n  res.json({ comment: cleanComment });\n});",
          "explanation": "Sanitize HTML with DOMPurify"
        },
        {
          "code": "app.set('view engine', 'ejs');\n\napp.get('/search', (req, res) => {\n  res.render('search', {\n    query: req.query.q  // EJS escapes by default with <%= %>\n  });\n});\n\n// In search.ejs:\n// <p>Results for: <%= query %></p>",
          "explanation": "Use template engine with auto-escaping"
        }
      ]
    },
    {
      "vulnerability_id": "express_no_helmet",
      "name": "Missing Security Headers",
      "cwe": "CWE-693",
      "severity": "high",
      "description": "Missing important security headers",

      "bad_patterns": [
        {
          "code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});",
          "issue": "No security headers configured"
        },
        {
          "code": "app.use((req, res, next) => {\n  res.setHeader('X-Powered-By', 'Express');\n  next();\n});",
          "issue": "Exposing server technology"
        }
      ],

      "good_patterns": [
        {
          "code": "const express = require('express');\nconst helmet = require('helmet');\nconst app = express();\n\napp.use(helmet());\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n    scriptSrc: [\"'self'\"],\n    imgSrc: [\"'self'\", \"data:\", \"https:\"]\n  }\n}));",
          "explanation": "Use helmet middleware for security headers"
        },
        {
          "code": "app.use((req, res, next) => {\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');\n  res.removeHeader('X-Powered-By');\n  next();\n});",
          "explanation": "Manually set security headers"
        }
      ]
    },
    {
      "vulnerability_id": "express_csrf",
      "name": "Missing CSRF Protection",
      "cwe": "CWE-352",
      "severity": "high",
      "description": "Forms and state-changing operations without CSRF tokens",

      "bad_patterns": [
        {
          "code": "app.post('/transfer', (req, res) => {\n  const { to, amount } = req.body;\n  // No CSRF token validation\n  transferFunds(req.user.id, to, amount);\n  res.json({ success: true });\n});",
          "issue": "State-changing operation without CSRF protection"
        },
        {
          "code": "<form action=\"/delete-account\" method=\"POST\">\n  <button type=\"submit\">Delete Account</button>\n</form>",
          "issue": "Form without CSRF token"
        }
      ],

      "good_patterns": [
        {
          "code": "const csrf = require('csurf');\nconst csrfProtection = csrf({ cookie: true });\n\napp.use(csrfProtection);\n\napp.get('/form', (req, res) => {\n  res.render('form', { csrfToken: req.csrfToken() });\n});\n\napp.post('/transfer', (req, res) => {\n  // CSRF token automatically validated by middleware\n  const { to, amount } = req.body;\n  transferFunds(req.user.id, to, amount);\n  res.json({ success: true });\n});",
          "explanation": "Use csurf middleware for CSRF protection"
        },
        {
          "code": "// In template:\n<form action=\"/delete-account\" method=\"POST\">\n  <input type=\"hidden\" name=\"_csrf\" value=\"<%= csrfToken %>\">\n  <button type=\"submit\">Delete Account</button>\n</form>\n\n// For AJAX:\nfetch('/api/transfer', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'CSRF-Token': getCsrfToken()\n  },\n  body: JSON.stringify(data)\n});",
          "explanation": "Include CSRF token in forms and AJAX requests"
        }
      ]
    },
    {
      "vulnerability_id": "express_path_traversal",
      "name": "Path Traversal Vulnerability",
      "cwe": "CWE-22",
      "severity": "critical",
      "description": "Serving files based on user input without validation",

      "bad_patterns": [
        {
          "code": "app.get('/download/:filename', (req, res) => {\n  const file = path.join(__dirname, 'uploads', req.params.filename);\n  res.sendFile(file);\n});",
          "issue": "User can traverse with ../../../etc/passwd"
        },
        {
          "code": "app.get('/file', (req, res) => {\n  fs.readFile(req.query.path, (err, data) => {\n    res.send(data);\n  });\n});",
          "issue": "Direct file path from user input"
        }
      ],

      "good_patterns": [
        {
          "code": "const path = require('path');\n\napp.get('/download/:filename', (req, res) => {\n  // Sanitize filename\n  const filename = path.basename(req.params.filename);\n  \n  // Define safe directory\n  const safeDir = path.join(__dirname, 'uploads');\n  const filePath = path.join(safeDir, filename);\n  \n  // Ensure file is within safe directory\n  if (!filePath.startsWith(safeDir)) {\n    return res.status(400).send('Invalid filename');\n  }\n  \n  // Check if file exists\n  if (!fs.existsSync(filePath)) {\n    return res.status(404).send('File not found');\n  }\n  \n  res.sendFile(filePath);\n});",
          "explanation": "Validate file path is within safe directory"
        },
        {
          "code": "app.use('/static', express.static(path.join(__dirname, 'public'), {\n  dotfiles: 'deny',\n  index: false,\n  redirect: false\n}));",
          "explanation": "Use express.static with security options"
        }
      ]
    },
    {
      "vulnerability_id": "express_nosql_injection",
      "name": "NoSQL Injection",
      "cwe": "CWE-943",
      "severity": "high",
      "description": "MongoDB query injection through user input",

      "bad_patterns": [
        {
          "code": "app.post('/login', async (req, res) => {\n  const user = await User.findOne({\n    username: req.body.username,\n    password: req.body.password\n  });\n  // If req.body.password = {$ne: null}, it matches any password\n  if (user) {\n    res.json({ token: generateToken(user) });\n  }\n});",
          "issue": "Direct object insertion allows query operators"
        },
        {
          "code": "app.get('/users', async (req, res) => {\n  // req.query.filter could be {$where: 'this.admin == true'}\n  const users = await User.find(req.query.filter);\n  res.json(users);\n});",
          "issue": "User controls entire query filter"
        }
      ],

      "good_patterns": [
        {
          "code": "const mongoSanitize = require('express-mongo-sanitize');\n\napp.use(mongoSanitize());\n\napp.post('/login', async (req, res) => {\n  // Ensure inputs are strings\n  const username = String(req.body.username);\n  const password = String(req.body.password);\n  \n  const user = await User.findOne({\n    username: username,\n    password: password  // Better: use bcrypt for passwords\n  });\n  \n  if (user) {\n    res.json({ token: generateToken(user) });\n  }\n});",
          "explanation": "Sanitize input and ensure string types"
        },
        {
          "code": "app.get('/users', async (req, res) => {\n  // Whitelist allowed query parameters\n  const filter = {};\n  \n  if (req.query.name && typeof req.query.name === 'string') {\n    filter.name = req.query.name;\n  }\n  \n  if (req.query.age && !isNaN(req.query.age)) {\n    filter.age = parseInt(req.query.age);\n  }\n  \n  const users = await User.find(filter);\n  res.json(users);\n});",
          "explanation": "Build query object with validated fields"
        }
      ]
    },
    {
      "vulnerability_id": "express_jwt_weak",
      "name": "Weak JWT Implementation",
      "cwe": "CWE-347",
      "severity": "high",
      "description": "Insecure JWT token handling",

      "bad_patterns": [
        {
          "code": "const jwt = require('jsonwebtoken');\nconst SECRET = 'secret123';\n\napp.post('/login', (req, res) => {\n  const token = jwt.sign({ user: req.body.username }, SECRET);\n  res.json({ token });\n});",
          "issue": "Weak/hardcoded secret key"
        },
        {
          "code": "app.get('/protected', (req, res) => {\n  const token = req.headers.authorization;\n  // No algorithm verification\n  const decoded = jwt.decode(token);\n  res.json({ user: decoded.user });\n});",
          "issue": "Using decode instead of verify"
        },
        {
          "code": "jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] });",
          "issue": "Allowing 'none' algorithm"
        }
      ],

      "good_patterns": [
        {
          "code": "const jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\n\n// Use environment variable or secure key management\nconst SECRET = process.env.JWT_SECRET || crypto.randomBytes(64).toString('hex');\n\napp.post('/login', async (req, res) => {\n  const user = await authenticateUser(req.body.username, req.body.password);\n  \n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  const token = jwt.sign(\n    { userId: user.id, username: user.username },\n    SECRET,\n    { expiresIn: '1h', algorithm: 'HS256' }\n  );\n  \n  res.json({ token });\n});",
          "explanation": "Strong secret with expiration"
        },
        {
          "code": "const authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n  \n  if (!token) {\n    return res.status(401).json({ error: 'Token required' });\n  }\n  \n  jwt.verify(token, SECRET, { algorithms: ['HS256'] }, (err, user) => {\n    if (err) {\n      return res.status(403).json({ error: 'Invalid token' });\n    }\n    req.user = user;\n    next();\n  });\n};\n\napp.get('/protected', authenticateToken, (req, res) => {\n  res.json({ user: req.user });\n});",
          "explanation": "Proper JWT verification middleware"
        }
      ]
    },
    {
      "vulnerability_id": "express_command_injection",
      "name": "Command Injection",
      "cwe": "CWE-78",
      "severity": "critical",
      "description": "Executing system commands with user input",

      "bad_patterns": [
        {
          "code": "const exec = require('child_process').exec;\n\napp.get('/ping/:host', (req, res) => {\n  exec(`ping -c 4 ${req.params.host}`, (error, stdout) => {\n    res.send(stdout);\n  });\n});",
          "issue": "User input in shell command"
        },
        {
          "code": "app.post('/convert', (req, res) => {\n  const filename = req.body.file;\n  exec(`convert ${filename} output.pdf`, (err, stdout) => {\n    res.send('Converted');\n  });\n});",
          "issue": "Unescaped filename in command"
        }
      ],

      "good_patterns": [
        {
          "code": "const { spawn } = require('child_process');\n\napp.get('/ping/:host', (req, res) => {\n  // Validate input\n  const host = req.params.host;\n  const ipRegex = /^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$/;\n  const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9](?:\\.[a-zA-Z]{2,})+$/;\n  \n  if (!ipRegex.test(host) && !domainRegex.test(host)) {\n    return res.status(400).send('Invalid host');\n  }\n  \n  // Use spawn with array arguments (no shell)\n  const ping = spawn('ping', ['-c', '4', host]);\n  \n  let output = '';\n  ping.stdout.on('data', (data) => {\n    output += data;\n  });\n  \n  ping.on('close', (code) => {\n    res.send(output);\n  });\n});",
          "explanation": "Use spawn with array arguments to avoid shell"
        },
        {
          "code": "const { execFile } = require('child_process');\n\napp.post('/convert', (req, res) => {\n  const filename = path.basename(req.body.file);\n  \n  // Use execFile which doesn't spawn a shell\n  execFile('convert', [filename, 'output.pdf'], (error, stdout) => {\n    if (error) {\n      return res.status(500).send('Conversion failed');\n    }\n    res.send('Converted');\n  });\n});",
          "explanation": "Use execFile to avoid shell interpretation"
        }
      ]
    }
  ],

  "security_settings": [
    {
      "setting": "Use HTTPS",
      "recommendation": "Deploy behind HTTPS proxy (nginx/Apache) or use https module",
      "purpose": "Encrypt traffic in transit"
    },
    {
      "setting": "Session Security",
      "recommendation": "Use express-session with secure: true, httpOnly: true, sameSite: 'strict'",
      "purpose": "Protect session cookies"
    },
    {
      "setting": "Rate Limiting",
      "recommendation": "Use express-rate-limit or similar middleware",
      "purpose": "Prevent brute force and DoS attacks"
    },
    {
      "setting": "Input Validation",
      "recommendation": "Use express-validator or joi for input validation",
      "purpose": "Validate and sanitize all user inputs"
    },
    {
      "setting": "Error Handling",
      "recommendation": "Don't expose stack traces in production",
      "purpose": "Prevent information leakage"
    },
    {
      "setting": "Dependencies",
      "recommendation": "Regularly update and audit with npm audit",
      "purpose": "Patch known vulnerabilities"
    },
    {
      "setting": "CORS Configuration",
      "recommendation": "Configure CORS restrictively, avoid wildcards with credentials",
      "purpose": "Prevent unauthorized cross-origin requests"
    },
    {
      "setting": "Body Parser Limits",
      "recommendation": "Set limits in body-parser or express.json({ limit: '100kb' })",
      "purpose": "Prevent large payload attacks"
    }
  ]
}