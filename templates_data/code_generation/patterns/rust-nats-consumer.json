{
  "id": "rust-nats-consumer",
  "name": "Rust NATS Consumer Generator",
  "description": "Generates async NATS consumers with error handling and metrics",
  "steps": [
    {
      "name": "sparc-phase-1-research",
      "operation": {"type": "generate", "generate": "sparc-research"}
    },
    {
      "name": "sparc-phase-2-architecture",
      "operation": {"type": "generate", "generate": "sparc-architecture"}
    },
    {
      "name": "sparc-phase-3-security",
      "operation": {"type": "generate", "generate": "sparc-security"}
    },
    {
      "name": "sparc-phase-4-performance",
      "operation": {"type": "generate", "generate": "sparc-performance"}
    },
    {
      "name": "sparc-phase-5-implementation",
      "operation": {"type": "generate", "generate": "rust-nats-consumer"}
    }
  ],
  "metadata": {
    "version": "1.0.0",
    "author": "SPARC Team",
    "created_at": "2025-10-04T00:00:00Z",
    "updated_at": "2025-10-04T00:00:00Z",
    "tags": ["rust", "nats", "async", "event-driven", "messaging"],
    "performance": {
      "avg_execution_time_ms": 80.0,
      "memory_usage_bytes": 1572864,
      "complexity": 6
    }
  },
  "detector_signatures": {
    "package_files": ["Cargo.toml"],
    "dependencies": ["async-nats", "nats", "tokio"],
    "file_patterns": ["**/nats/**/*.rs", "**/consumers/**/*.rs"],
    "code_patterns": [
      "async_nats::",
      "nats::subscribe",
      "subscribe(",
      "jetstream"
    ],
    "min_confidence": 0.75
  },
  "ai_signature": {
    "name": "rust_nats_consumer",
    "inputs": {
      "subject": "NATS subject pattern (e.g., facts.>, events.user.*)",
      "consumer_name": "Consumer name (snake_case)",
      "message_type": "Message payload type",
      "use_jetstream": "Use JetStream (default: true)",
      "durable": "Durable consumer (default: true)"
    },
    "outputs": {
      "rust_code": "Async NATS consumer with error handling",
      "message_handlers": "Message processing logic",
      "config": "Consumer configuration",
      "tests": "Integration tests with test containers"
    },
    "instruction": "Generate production-ready Rust NATS consumer with: (1) Async message handling with tokio, (2) Proper error handling and retries, (3) JetStream support with acknowledgments, (4) Structured logging with tracing, (5) Metrics and observability, (6) Graceful shutdown, (7) Integration tests. Follow Rust best practices and use strong typing."
  },
  "template_content": "//! @business-domain {{business_domain}}\n//! @architecture-pattern event-driven\n//! @architecture-layer messaging\n//! @security-level {{security_level}}\n//! @performance-profile high-throughput\n//! @ai-signature rust_nats_consumer\n\nuse anyhow::{Context, Result};\nuse async_nats::jetstream::{self, consumer::PullConsumer};\nuse serde::{Deserialize, Serialize};\nuse tokio::signal;\nuse tracing::{error, info, warn};\n\n/// @business-entity {{MessageType}}\n/// @architecture-pattern message-dto\n/// @security-pattern data-validation\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct {{MessageType}} {\n    pub id: String,\n    pub data: serde_json::Value,\n    pub timestamp: chrono::DateTime<chrono::Utc>,\n}\n\n/// @business-component {{ConsumerName}}Consumer\n/// @architecture-pattern consumer\n/// @performance-optimization async-processing\npub struct {{ConsumerName}}Consumer {\n    consumer: PullConsumer,\n    batch_size: usize,\n}\n\nimpl {{ConsumerName}}Consumer {\n    /// Create new consumer\n    /// @business-operation initialize_consumer\n    /// @test-scenario happy-path\n    pub async fn new(\n        client: async_nats::Client,\n        subject: &str,\n        durable_name: &str,\n    ) -> Result<Self> {\n        info!(\"Creating NATS consumer for subject: {}\", subject);\n        \n        // @architecture-pattern jetstream-consumer\n        let jetstream = jetstream::new(client);\n        \n        // @business-workflow consumer-configuration\n        let consumer = jetstream\n            .get_or_create_consumer(\n                \"{{stream_name}}\",\n                jetstream::consumer::pull::Config {\n                    durable_name: Some(durable_name.to_string()),\n                    filter_subject: subject.to_string(),\n                    ..Default::default()\n                },\n            )\n            .await\n            .context(\"Failed to create consumer\")?;\n        \n        Ok(Self {\n            consumer,\n            batch_size: 10,\n        })\n    }\n    \n    /// Start consuming messages\n    /// @business-operation consume_messages\n    /// @performance-critical-section\n    /// @test-scenario message-processing\n    /// @test-scenario error-handling\n    pub async fn start(&mut self) -> Result<()> {\n        info!(\"Starting {{ConsumerName}} consumer\");\n        \n        loop {\n            tokio::select! {\n                // @architecture-pattern graceful-shutdown\n                _ = signal::ctrl_c() => {\n                    info!(\"Shutting down consumer gracefully\");\n                    break;\n                }\n                \n                // @performance-optimization batch-processing\n                result = self.consumer.batch().max_messages(self.batch_size).messages() => {\n                    match result {\n                        Ok(mut messages) => {\n                            while let Some(Ok(msg)) = messages.next().await {\n                                // @business-workflow message-processing\n                                if let Err(e) = self.process_message(msg).await {\n                                    error!(\"Error processing message: {}\", e);\n                                }\n                            }\n                        }\n                        Err(e) => {\n                            error!(\"Error fetching messages: {}\", e);\n                            // @architecture-pattern exponential-backoff\n                            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;\n                        }\n                    }\n                }\n            }\n        }\n        \n        Ok(())\n    }\n    \n    /// Process a single message\n    /// @business-operation process_message\n    /// @security-validation message-validation\n    /// @performance-metric processing-time\n    async fn process_message(\n        &self,\n        msg: jetstream::Message,\n    ) -> Result<()> {\n        let subject = msg.subject.as_str();\n        let payload = msg.payload.clone();\n        \n        info!(\"Processing message from subject: {}\", subject);\n        \n        // @security-validation input-deserialization\n        let message: {{MessageType}} = serde_json::from_slice(&payload)\n            .context(\"Failed to deserialize message\")?;\n        \n        // @business-workflow message-handler\n        // TODO: Implement message processing logic\n        info!(\"Received {{MessageType}}: {:?}\", message);\n        \n        // @architecture-pattern acknowledgment\n        msg.ack().await.context(\"Failed to ack message\")?;\n        \n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    /// @test-scenario integration-test\n    /// @ai-output tests: consumer_test\n    #[tokio::test]\n    async fn test_{{consumer_name}}_consumer() {\n        // TODO: Use testcontainers for NATS server\n        // let client = async_nats::connect(\"localhost:4222\").await.unwrap();\n        // let mut consumer = {{ConsumerName}}Consumer::new(\n        //     client,\n        //     \"{{subject}}\",\n        //     \"test-consumer\"\n        // ).await.unwrap();\n    }\n}\n"
}
