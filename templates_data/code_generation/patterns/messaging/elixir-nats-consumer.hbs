defmodule {{module_name}} do
  @moduledoc """
  {{description}}

  ## Overview

  {{overview}}

  ## Public API Contract

  - `start_link(opts) :: GenServer.on_start()` - Starts the consumer GenServer
    - Required options: `:subject`, `:handler`
    - Optional options: `:concurrency` (default: 10)

  ## Error Matrix

  {{#each error_types}}
  - `:{{atom}}` - {{description}}
  {{/each}}

  ## Performance Notes

  {{performance_notes}}

  ## Concurrency Semantics

  {{concurrency_notes}}

  ## Security Considerations

  {{security_notes}}

  ## Examples

  {{#each examples}}
      # {{comment}}
      {{code}}
  {{/each}}

  ## Relationships

  {{#if relationships}}
  {{#if relationships.calls}}
  **Calls:**
  {{#each relationships.calls}}
  - {{module}}{{#if function}}.{{function}}/{{arity}}{{/if}} - {{purpose}}
  {{/each}}
  {{/if}}

  {{#if relationships.called_by}}
  **Called by:**
  {{#each relationships.called_by}}
  - {{module}} - {{purpose}}
  {{/each}}
  {{/if}}

  {{#if relationships.depends_on}}
  **Depends on:**
  {{#each relationships.depends_on}}
  - {{name}} - {{purpose}}
  {{/each}}
  {{/if}}

  {{#if relationships.integrates_with}}
  **Integrates with:**
  {{#each relationships.integrates_with}}
  - {{name}} - {{purpose}}
  {{/each}}
  {{/if}}
  {{/if}}

  ## Template Version

  - **Applied:** {{template_id}} v{{template_version}}
  - **Applied on:** {{applied_date}}
  """

  use GenServer
  require Logger

  @type state :: %{
    conn: Gnat.t() | nil,
    subscription: reference() | nil,
    subject: String.t(),
    handler: module(),
    concurrency: pos_integer()
  }

  ## Client API

  @doc """
  Start the NATS consumer.

  ## Options

  - `:subject` - NATS subject to subscribe to (required)
  - `:handler` - Handler module implementing `handle_message/1` (required)
  - `:concurrency` - Number of concurrent message processors (default: {{default_concurrency}})
  {{#if additional_options}}
  {{#each additional_options}}
  - `:{{name}}` - {{description}}
  {{/each}}
  {{/if}}
  """
  @spec start_link(keyword()) :: GenServer.on_start()
  def start_link(opts) do
    subject = Keyword.fetch!(opts, :subject)
    handler = Keyword.fetch!(opts, :handler)
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  ## Server Callbacks

  @impl true
  def init(opts) do
    subject = Keyword.fetch!(opts, :subject)
    handler = Keyword.fetch!(opts, :handler)
    concurrency = Keyword.get(opts, :concurrency, {{default_concurrency}})

    state = %{
      conn: nil,
      subscription: nil,
      subject: subject,
      handler: handler,
      concurrency: concurrency
    }

    # Connect in init to fail fast
    case connect(state) do
      {:ok, new_state} ->
        Logger.info("NATS consumer started for subject: #{subject}")
        {:ok, new_state}

      {:error, reason} ->
        Logger.error("Failed to connect to NATS: #{inspect(reason)}")
        {:stop, reason}
    end
  end

  @impl true
  def handle_info({:msg, %{body: body, topic: topic, reply_to: reply_to}}, state) do
    # Process message async
    Task.Supervisor.start_child({{task_supervisor}}, fn ->
      process_message(body, topic, reply_to, state)
    end)

    {:noreply, state}
  end

  @impl true
  def handle_info(:reconnect, state) do
    case connect(state) do
      {:ok, new_state} ->
        Logger.info("Reconnected to NATS")
        {:noreply, new_state}

      {:error, _reason} ->
        # Retry after delay
        Process.send_after(self(), :reconnect, {{reconnect_delay}})
        {:noreply, state}
    end
  end

  ## Private Functions

  defp connect(state) do
    with {:ok, conn} <- Gnat.start_link(),
         {:ok, sub} <- Gnat.sub(conn, self(), state.subject) do
      {:ok, %{state | conn: conn, subscription: sub}}
    end
  end

  defp process_message(body, topic, reply_to, state) do
    start_time = System.monotonic_time(:millisecond)

    case state.handler.handle_message(body) do
      :ok ->
        emit_telemetry(:success, topic, start_time)
        if reply_to, do: Gnat.pub(state.conn, reply_to, "ACK")

      {:error, reason} ->
        Logger.error("Message processing failed: #{inspect(reason)}")
        emit_telemetry(:error, topic, start_time)
        {{#if enable_dlq}}
        send_to_dlq(body, topic, reason, state)
        {{/if}}
    end
  end

  defp emit_telemetry(status, topic, start_time) do
    duration = System.monotonic_time(:millisecond) - start_time

    :telemetry.execute(
      [:nats_consumer, :message, status],
      %{duration: duration},
      %{topic: topic}
    )
  end

  {{#if enable_dlq}}
  defp send_to_dlq(body, topic, reason, state) do
    # Send failed messages to dead letter queue
    dlq_topic = "#{topic}.dlq"

    payload = Jason.encode!(%{
      original_body: body,
      error: inspect(reason),
      timestamp: DateTime.utc_now()
    })

    Gnat.pub(state.conn, dlq_topic, payload)
  end
  {{/if}}
end
