{
  "language": "javascript",
  "language_name": "JavaScript/TypeScript",
  "version_target": "ES2020+/TypeScript 4.5+",
  "description": "Best practices and patterns for writing modern, maintainable JavaScript and TypeScript code",

  "patterns": [
    {
      "pattern_id": "js_async_await",
      "name": "Async/Await Over Callbacks and Promises",
      "category": "Asynchronous Programming",
      "severity": "high",
      "description": "Use async/await for cleaner asynchronous code flow",

      "bad_example": {
        "code": "// Callback hell\ngetUser(id, (err, user) => {\n  if (err) {\n    handleError(err);\n    return;\n  }\n  getOrders(user.id, (err, orders) => {\n    if (err) {\n      handleError(err);\n      return;\n    }\n    getOrderDetails(orders[0].id, (err, details) => {\n      if (err) {\n        handleError(err);\n        return;\n      }\n      console.log(details);\n    });\n  });\n});\n\n// Promise chains\ngetUser(id)\n  .then(user => getOrders(user.id))\n  .then(orders => getOrderDetails(orders[0].id))\n  .then(details => console.log(details))\n  .catch(handleError);\n\n// Mixed patterns\nfunction fetchData() {\n  return fetch('/api/data')\n    .then(res => {\n      if (!res.ok) throw new Error('Failed');\n      return res.json();\n    });\n}",
        "issues": [
          "Callback hell is hard to read",
          "Promise chains are verbose",
          "Error handling is complex",
          "Difficult to debug"
        ]
      },

      "good_example": {
        "code": "// Clean async/await\nasync function getUserOrderDetails(userId: string) {\n  try {\n    const user = await getUser(userId);\n    const orders = await getOrders(user.id);\n    const details = await getOrderDetails(orders[0].id);\n    return details;\n  } catch (error) {\n    console.error('Error fetching order details:', error);\n    throw new Error(`Failed to get order details for user ${userId}`);\n  }\n}\n\n// Parallel operations\nasync function fetchMultipleUsers(userIds: string[]) {\n  const users = await Promise.all(\n    userIds.map(id => getUser(id))\n  );\n  return users;\n}\n\n// With proper error handling\nasync function fetchDataWithRetry<T>(\n  url: string,\n  maxRetries = 3\n): Promise<T> {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      const response = await fetch(url);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      if (i === maxRetries - 1) throw error;\n      \n      // Exponential backoff\n      await new Promise(resolve => \n        setTimeout(resolve, Math.pow(2, i) * 1000)\n      );\n    }\n  }\n  throw new Error('Unreachable');\n}\n\n// Async generators\nasync function* paginate<T>(url: string): AsyncGenerator<T[]> {\n  let page = 1;\n  let hasMore = true;\n  \n  while (hasMore) {\n    const response = await fetch(`${url}?page=${page}`);\n    const data = await response.json();\n    \n    yield data.items;\n    hasMore = data.hasNext;\n    page++;\n  }\n}\n\n// Usage\nfor await (const items of paginate('/api/users')) {\n  processItems(items);\n}",
        "benefits": [
          "Sequential code appearance",
          "Better error handling with try/catch",
          "Easier to debug",
          "Works well with loops"
        ]
      },

      "learning_resources": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",
        "https://javascript.info/async-await",
        "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html"
      ]
    },
    {
      "pattern_id": "js_optional_chaining",
      "name": "Optional Chaining and Nullish Coalescing",
      "category": "Null Safety",
      "severity": "medium",
      "description": "Use modern operators for safe property access and default values",

      "bad_example": {
        "code": "// Verbose null checks\nconst name = user && user.profile && user.profile.name || 'Unknown';\n\n// Multiple conditions\nif (data && data.items && data.items.length > 0) {\n  processItems(data.items);\n}\n\n// Falsy value issues\nconst count = settings.count || 10;  // Problem if count is 0\n\n// Deep nesting checks\nlet city;\nif (response &&\n    response.data &&\n    response.data.user &&\n    response.data.user.address &&\n    response.data.user.address.city) {\n  city = response.data.user.address.city;\n}",
        "issues": [
          "Verbose and repetitive",
          "Falsy value confusion",
          "Hard to maintain",
          "Error-prone"
        ]
      },

      "good_example": {
        "code": "// Optional chaining for safe access\nconst name = user?.profile?.name ?? 'Unknown';\n\n// Array/function optional chaining\nconst firstItem = data?.items?.[0];\nconst result = api?.getData?.() ?? [];\n\n// Nullish coalescing for defaults\nconst count = settings.count ?? 10;  // Handles 0 correctly\nconst timeout = config?.timeout ?? 5000;\n\n// Combined with destructuring\nconst { name = 'Guest' } = user?.profile ?? {};\n\n// Type-safe property access (TypeScript)\ninterface User {\n  profile?: {\n    name?: string;\n    age?: number;\n    address?: {\n      city?: string;\n      country?: string;\n    };\n  };\n}\n\nfunction getUserCity(user: User): string {\n  return user?.profile?.address?.city ?? 'Unknown City';\n}\n\n// Conditional method calls\nconst length = str?.trim?.()?.length ?? 0;\n\n// With array methods\nconst names = users\n  ?.filter(u => u.active)\n  ?.map(u => u.name) ?? [];\n\n// Dynamic property access\nconst value = obj?.[dynamicKey]?.nested?.value;\n\n// Early returns with optional chaining\nfunction processUser(user?: User) {\n  const email = user?.contact?.email;\n  if (!email) return;\n  \n  sendEmail(email);\n}\n\n// In React components\nfunction UserProfile({ user }: { user?: User }) {\n  return (\n    <div>\n      <h1>{user?.name ?? 'Anonymous'}</h1>\n      <p>{user?.bio ?? 'No bio available'}</p>\n      {user?.social?.twitter && (\n        <a href={`https://twitter.com/${user.social.twitter}`}>\n          @{user.social.twitter}\n        </a>\n      )}\n    </div>\n  );\n}",
        "benefits": [
          "Concise null checking",
          "Handles undefined and null correctly",
          "Type-safe in TypeScript",
          "Readable and maintainable"
        ]
      },

      "learning_resources": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator",
        "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html"
      ]
    },
    {
      "pattern_id": "js_destructuring",
      "name": "Destructuring for Clean Code",
      "category": "Code Quality",
      "severity": "medium",
      "description": "Use destructuring for cleaner variable assignments and function parameters",

      "bad_example": {
        "code": "// Repetitive property access\nconst name = user.name;\nconst email = user.email;\nconst age = user.age;\n\n// Accessing array elements\nconst first = arr[0];\nconst second = arr[1];\n\n// Function with many parameters\nfunction createUser(name, email, age, role, department) {\n  // Hard to remember parameter order\n}\n\n// Nested property access\nconst street = user.address.street;\nconst city = user.address.city;\nconst country = user.address.country;",
        "issues": [
          "Repetitive code",
          "Parameter order dependency",
          "Verbose property access",
          "No default values"
        ]
      },

      "good_example": {
        "code": "// Object destructuring\nconst { name, email, age = 18 } = user;\n\n// Array destructuring\nconst [first, second, ...rest] = arr;\n\n// Nested destructuring\nconst {\n  name,\n  address: { street, city, country = 'USA' }\n} = user;\n\n// Function parameter destructuring\ninterface UserConfig {\n  name: string;\n  email: string;\n  age?: number;\n  role?: 'admin' | 'user';\n  department?: string;\n}\n\nfunction createUser({\n  name,\n  email,\n  age = 18,\n  role = 'user',\n  department = 'general'\n}: UserConfig) {\n  return {\n    id: generateId(),\n    name,\n    email,\n    age,\n    role,\n    department,\n    createdAt: new Date()\n  };\n}\n\n// Renaming during destructuring\nconst { name: userName, email: userEmail } = user;\n\n// Swapping variables\nlet a = 1, b = 2;\n[a, b] = [b, a];\n\n// Rest parameters\nconst { id, ...userWithoutId } = user;\n\n// In function returns\nfunction getCoordinates() {\n  return { x: 10, y: 20, z: 30 };\n}\n\nconst { x, y } = getCoordinates();\n\n// With async functions\nasync function fetchUserData() {\n  const { data: { user } } = await api.get('/user');\n  return user;\n}\n\n// Loop destructuring\nfor (const { id, name } of users) {\n  console.log(`${id}: ${name}`);\n}\n\n// TypeScript with destructuring\ntype Point3D = { x: number; y: number; z: number };\n\nfunction distance(\n  { x: x1, y: y1, z: z1 }: Point3D,\n  { x: x2, y: y2, z: z2 }: Point3D\n): number {\n  return Math.sqrt(\n    (x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2\n  );\n}\n\n// React props destructuring\ninterface ButtonProps {\n  label: string;\n  onClick?: () => void;\n  disabled?: boolean;\n  variant?: 'primary' | 'secondary';\n}\n\nfunction Button({\n  label,\n  onClick,\n  disabled = false,\n  variant = 'primary'\n}: ButtonProps) {\n  return (\n    <button\n      className={`btn btn-${variant}`}\n      onClick={onClick}\n      disabled={disabled}\n    >\n      {label}\n    </button>\n  );\n}",
        "benefits": [
          "Less repetitive code",
          "Clear function interfaces",
          "Default values support",
          "Improved readability"
        ]
      },

      "learning_resources": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment",
        "https://javascript.info/destructuring-assignment",
        "https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring"
      ]
    },
    {
      "pattern_id": "js_typescript_types",
      "name": "TypeScript Type Safety",
      "category": "Type Safety",
      "severity": "high",
      "description": "Leverage TypeScript's type system for safer code",

      "bad_example": {
        "code": "// Using any\nlet data: any = fetchData();\ndata.foo.bar.baz;  // No type checking\n\n// Implicit any\nfunction process(input) {  // Parameter implicitly any\n  return input.value;\n}\n\n// Weak typing\ninterface User {\n  [key: string]: any;  // Loses all type safety\n}\n\n// Type assertions everywhere\nconst user = {} as User;\nuser.name = 'John';  // Unsafe\n\n// Missing return types\nfunction calculate(a, b) {\n  if (a > 10) {\n    return a + b;\n  }\n  // Implicit undefined return\n}",
        "issues": [
          "No type safety",
          "Runtime errors",
          "Poor IDE support",
          "Hard to refactor"
        ]
      },

      "good_example": {
        "code": "// Proper typing\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  age?: number;\n  roles: Role[];\n}\n\nenum Role {\n  Admin = 'ADMIN',\n  User = 'USER',\n  Guest = 'GUEST'\n}\n\n// Generic types\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message?: string;\n}\n\nasync function fetchUser(id: string): Promise<ApiResponse<User>> {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n\n// Union types\ntype Status = 'pending' | 'active' | 'completed' | 'failed';\n\ninterface Task {\n  id: string;\n  status: Status;\n  title: string;\n}\n\n// Type guards\nfunction isUser(value: unknown): value is User {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'id' in value &&\n    'name' in value &&\n    'email' in value\n  );\n}\n\nfunction processValue(value: unknown) {\n  if (isUser(value)) {\n    // TypeScript knows value is User here\n    console.log(value.email);\n  }\n}\n\n// Discriminated unions\ntype Result<T> = \n  | { success: true; data: T }\n  | { success: false; error: string };\n\nfunction handleResult<T>(result: Result<T>) {\n  if (result.success) {\n    // TypeScript knows result.data exists\n    return result.data;\n  } else {\n    // TypeScript knows result.error exists\n    console.error(result.error);\n  }\n}\n\n// Utility types\ntype PartialUser = Partial<User>;\ntype RequiredUser = Required<User>;\ntype ReadonlyUser = Readonly<User>;\ntype UserName = Pick<User, 'id' | 'name'>;\ntype UserWithoutId = Omit<User, 'id'>;\n\n// Template literal types\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\ntype Endpoint = `/api/${string}`;\n\ninterface ApiRequest {\n  method: HttpMethod;\n  endpoint: Endpoint;\n}\n\n// Const assertions\nconst config = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3\n} as const;\n\ntype Config = typeof config;\n\n// Mapped types\ntype Nullable<T> = {\n  [P in keyof T]: T[P] | null;\n};\n\n// Conditional types\ntype IsArray<T> = T extends any[] ? true : false;\ntype ElementType<T> = T extends (infer E)[] ? E : T;\n\n// Function overloads\nfunction createElement(tag: 'a'): HTMLAnchorElement;\nfunction createElement(tag: 'div'): HTMLDivElement;\nfunction createElement(tag: 'span'): HTMLSpanElement;\nfunction createElement(tag: string): HTMLElement {\n  return document.createElement(tag);\n}\n\nconst link = createElement('a');  // Type is HTMLAnchorElement",
        "benefits": [
          "Compile-time type checking",
          "Better IDE support",
          "Safer refactoring",
          "Self-documenting code"
        ]
      },

      "learning_resources": [
        "https://www.typescriptlang.org/docs/handbook/",
        "https://github.com/typescript-cheatsheets",
        "https://www.totaltypescript.com/"
      ]
    },
    {
      "pattern_id": "js_functional_programming",
      "name": "Functional Programming Patterns",
      "category": "Code Quality",
      "severity": "medium",
      "description": "Use functional programming concepts for cleaner, more predictable code",

      "bad_example": {
        "code": "// Mutating arrays\nconst numbers = [1, 2, 3];\nnumbers.push(4);  // Mutates original\nnumbers.sort();   // Mutates in place\n\n// Imperative loops\nlet sum = 0;\nfor (let i = 0; i < arr.length; i++) {\n  if (arr[i] > 0) {\n    sum += arr[i] * 2;\n  }\n}\n\n// Side effects in functions\nlet globalCounter = 0;\nfunction incrementCounter() {\n  globalCounter++;  // Side effect\n  return globalCounter;\n}\n\n// Mutating objects\nfunction updateUser(user) {\n  user.lastModified = new Date();  // Mutates input\n  user.version++;\n  return user;\n}",
        "issues": [
          "Unpredictable mutations",
          "Hard to test",
          "Side effects",
          "Not composable"
        ]
      },

      "good_example": {
        "code": "// Immutable operations\nconst numbers = [1, 2, 3];\nconst withFour = [...numbers, 4];  // New array\nconst sorted = [...numbers].sort();  // Copy then sort\n\n// Functional array methods\nconst sum = arr\n  .filter(n => n > 0)\n  .map(n => n * 2)\n  .reduce((acc, n) => acc + n, 0);\n\n// Pure functions\nfunction add(a: number, b: number): number {\n  return a + b;  // No side effects\n}\n\n// Immutable updates\nfunction updateUser(user: User): User {\n  return {\n    ...user,\n    lastModified: new Date(),\n    version: user.version + 1\n  };\n}\n\n// Function composition\nconst pipe = <T>(...fns: Array<(arg: T) => T>) => \n  (value: T) => fns.reduce((acc, fn) => fn(acc), value);\n\nconst compose = <T>(...fns: Array<(arg: T) => T>) => \n  (value: T) => fns.reduceRight((acc, fn) => fn(acc), value);\n\nconst processString = pipe(\n  (s: string) => s.trim(),\n  (s: string) => s.toLowerCase(),\n  (s: string) => s.replace(/\\s+/g, '-')\n);\n\n// Currying\nconst multiply = (a: number) => (b: number) => a * b;\nconst double = multiply(2);\nconst triple = multiply(3);\n\n// Higher-order functions\nfunction memoize<T extends (...args: any[]) => any>(\n  fn: T\n): T {\n  const cache = new Map();\n  \n  return ((...args: Parameters<T>) => {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    \n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  }) as T;\n}\n\n// Partial application\nfunction partial<T extends any[], R>(\n  fn: (...args: T) => R,\n  ...fixedArgs: Partial<T>\n) {\n  return (...remainingArgs: T) => \n    fn(...[...fixedArgs, ...remainingArgs] as T);\n}\n\nconst greet = (greeting: string, name: string) => \n  `${greeting}, ${name}!`;\n\nconst sayHello = partial(greet, 'Hello');\nsayHello('World');  // \"Hello, World!\"\n\n// Immutable state updates (React example)\ntype State = {\n  users: User[];\n  loading: boolean;\n  error: string | null;\n};\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'ADD_USER':\n      return {\n        ...state,\n        users: [...state.users, action.payload]\n      };\n    \n    case 'UPDATE_USER':\n      return {\n        ...state,\n        users: state.users.map(user =>\n          user.id === action.payload.id\n            ? { ...user, ...action.payload.updates }\n            : user\n        )\n      };\n    \n    default:\n      return state;\n  }\n}",
        "benefits": [
          "Predictable code",
          "Easier testing",
          "Better debugging",
          "Composable functions"
        ]
      },

      "learning_resources": [
        "https://eloquentjavascript.net/05_higher_order.html",
        "https://github.com/MostlyAdequate/mostly-adequate-guide",
        "https://frontendmasters.com/courses/functional-javascript/"
      ]
    },
    {
      "pattern_id": "js_error_handling",
      "name": "Comprehensive Error Handling",
      "category": "Error Management",
      "severity": "high",
      "description": "Implement robust error handling strategies",

      "bad_example": {
        "code": "// Ignoring errors\ntry {\n  doSomething();\n} catch (e) {\n  // Silent failure\n}\n\n// Generic error messages\ncatch (error) {\n  console.log('An error occurred');\n}\n\n// Throwing strings\nthrow 'Something went wrong';\n\n// No error boundaries\nfunction Component() {\n  const data = JSON.parse(props.data);  // Can crash app\n  return <div>{data.name}</div>;\n}",
        "issues": [
          "Lost error information",
          "Hard to debug",
          "Poor user experience",
          "No recovery strategy"
        ]
      },

      "good_example": {
        "code": "// Custom error classes\nclass ValidationError extends Error {\n  constructor(\n    message: string,\n    public field: string,\n    public value: unknown\n  ) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nclass ApiError extends Error {\n  constructor(\n    message: string,\n    public status: number,\n    public endpoint: string\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\n// Result type pattern\ntype Result<T, E = Error> = \n  | { ok: true; value: T }\n  | { ok: false; error: E };\n\nfunction divide(a: number, b: number): Result<number> {\n  if (b === 0) {\n    return {\n      ok: false,\n      error: new Error('Division by zero')\n    };\n  }\n  return { ok: true, value: a / b };\n}\n\n// Error handling in async functions\nasync function fetchUserData(\n  userId: string\n): Promise<Result<User>> {\n  try {\n    const response = await fetch(`/api/users/${userId}`);\n    \n    if (!response.ok) {\n      return {\n        ok: false,\n        error: new ApiError(\n          `Failed to fetch user`,\n          response.status,\n          `/api/users/${userId}`\n        )\n      };\n    }\n    \n    const user = await response.json();\n    return { ok: true, value: user };\n    \n  } catch (error) {\n    return {\n      ok: false,\n      error: error instanceof Error \n        ? error \n        : new Error('Unknown error')\n    };\n  }\n}\n\n// Global error handler\nwindow.addEventListener('error', (event) => {\n  console.error('Global error:', event.error);\n  \n  // Send to error tracking service\n  trackError({\n    message: event.message,\n    source: event.filename,\n    line: event.lineno,\n    column: event.colno,\n    stack: event.error?.stack\n  });\n});\n\n// Promise rejection handler\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('Unhandled promise rejection:', event.reason);\n  trackError(event.reason);\n});\n\n// React error boundary\nclass ErrorBoundary extends React.Component<\n  { children: React.ReactNode },\n  { hasError: boolean; error?: Error }\n> {\n  state = { hasError: false };\n  \n  static getDerivedStateFromError(error: Error) {\n    return { hasError: true, error };\n  }\n  \n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('Component error:', error, errorInfo);\n    trackError({ error, errorInfo });\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-fallback\">\n          <h2>Something went wrong</h2>\n          <details>\n            <summary>Details</summary>\n            <pre>{this.state.error?.stack}</pre>\n          </details>\n        </div>\n      );\n    }\n    \n    return this.props.children;\n  }\n}\n\n// Validation with detailed errors\nfunction validateUser(data: unknown): User {\n  if (!data || typeof data !== 'object') {\n    throw new ValidationError(\n      'Invalid user data',\n      'root',\n      data\n    );\n  }\n  \n  const user = data as Record<string, unknown>;\n  \n  if (!user.email || typeof user.email !== 'string') {\n    throw new ValidationError(\n      'Email is required',\n      'email',\n      user.email\n    );\n  }\n  \n  if (!isValidEmail(user.email)) {\n    throw new ValidationError(\n      'Invalid email format',\n      'email',\n      user.email\n    );\n  }\n  \n  return user as User;\n}",
        "benefits": [
          "Detailed error information",
          "Better debugging",
          "Graceful degradation",
          "Improved user experience"
        ]
      },

      "learning_resources": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
        "https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary",
        "https://www.typescriptlang.org/docs/handbook/2/narrowing.html"
      ]
    },
    {
      "pattern_id": "js_module_patterns",
      "name": "Modern Module Patterns",
      "category": "Architecture",
      "severity": "medium",
      "description": "Use ES modules and proper import/export patterns",

      "bad_example": {
        "code": "// Global namespace pollution\nvar MyApp = MyApp || {};\nMyApp.utils = {\n  formatDate: function() { /*...*/ }\n};\n\n// CommonJS in browser\nconst utils = require('./utils');  // Doesn't work in browser\n\n// Default export abuse\nexport default {\n  func1,\n  func2,\n  func3,\n  // Everything in one object\n};\n\n// Circular dependencies\n// fileA.js\nimport { funcB } from './fileB';\nexport const funcA = () => funcB();\n\n// fileB.js\nimport { funcA } from './fileA';\nexport const funcB = () => funcA();",
        "issues": [
          "Global pollution",
          "No tree shaking",
          "Circular dependencies",
          "Poor module boundaries"
        ]
      },

      "good_example": {
        "code": "// Named exports for utilities\n// utils/date.ts\nexport function formatDate(date: Date): string {\n  return date.toISOString();\n}\n\nexport function parseDate(str: string): Date {\n  return new Date(str);\n}\n\n// Default export for main class\n// models/User.ts\nexport interface UserProps {\n  id: string;\n  name: string;\n}\n\nexport default class User {\n  constructor(private props: UserProps) {}\n  \n  get id() { return this.props.id; }\n  get name() { return this.props.name; }\n}\n\n// Re-exports for clean API\n// index.ts\nexport { formatDate, parseDate } from './utils/date';\nexport { default as User } from './models/User';\nexport type { UserProps } from './models/User';\n\n// Barrel exports\n// components/index.ts\nexport { Button } from './Button';\nexport { Input } from './Input';\nexport { Select } from './Select';\n\n// Dynamic imports for code splitting\nasync function loadHeavyModule() {\n  const { processData } = await import('./heavyModule');\n  return processData();\n}\n\n// Conditional imports\nconst loadPolyfill = async () => {\n  if (!window.IntersectionObserver) {\n    await import('intersection-observer');\n  }\n};\n\n// Module namespace imports\nimport * as DateUtils from './utils/date';\n\nconst formatted = DateUtils.formatDate(new Date());\n\n// Type-only imports (TypeScript)\nimport type { User } from './types';\nimport { type UserProps, createUser } from './user';\n\n// Module augmentation\ndeclare module './user' {\n  interface User {\n    newMethod(): void;\n  }\n}\n\n// Avoid circular dependencies with interfaces\n// types.ts\nexport interface ServiceA {\n  methodA(): void;\n}\n\nexport interface ServiceB {\n  methodB(): void;\n}\n\n// serviceA.ts\nimport type { ServiceB } from './types';\n\nexport class ServiceAImpl {\n  constructor(private serviceB: ServiceB) {}\n  \n  methodA() {\n    this.serviceB.methodB();\n  }\n}\n\n// serviceB.ts\nimport type { ServiceA } from './types';\n\nexport class ServiceBImpl {\n  constructor(private serviceA: ServiceA) {}\n  \n  methodB() {\n    // Implementation\n  }\n}",
        "benefits": [
          "Tree shaking support",
          "Clear module boundaries",
          "Type safety",
          "Better code organization"
        ]
      },

      "learning_resources": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",
        "https://exploringjs.com/es6/ch_modules.html",
        "https://www.typescriptlang.org/docs/handbook/modules.html"
      ]
    }
  ],

  "anti_patterns": [
    {
      "pattern_id": "js_var_keyword",
      "name": "Using var Instead of let/const",
      "severity": "high",
      "description": "var has function scope and hoisting issues",
      "example": "var count = 0;  // Use let or const instead",
      "fixes": [
        "Use const for values that won't be reassigned",
        "Use let for values that will be reassigned",
        "Never use var in modern JavaScript"
      ]
    },
    {
      "pattern_id": "js_equality_coercion",
      "name": "Using == Instead of ===",
      "severity": "medium",
      "description": "== performs type coercion which can lead to bugs",
      "example": "if (value == null)  // Use === or check both null and undefined",
      "fixes": [
        "Always use === for equality checks",
        "Use == only for null/undefined check: value == null",
        "Be explicit about type conversions"
      ]
    },
    {
      "pattern_id": "js_eval_usage",
      "name": "Using eval() or Function Constructor",
      "severity": "critical",
      "description": "eval() is a security risk and performance problem",
      "example": "eval('console.log(data)')  // Security vulnerability",
      "fixes": [
        "Parse JSON with JSON.parse()",
        "Use function declarations instead of strings",
        "Use template literals for string building",
        "Never use eval() in production"
      ]
    },
    {
      "pattern_id": "js_promise_constructor",
      "name": "Promise Constructor Anti-pattern",
      "severity": "medium",
      "description": "Wrapping promises unnecessarily",
      "example": "return new Promise((resolve) => {\n  fetch(url).then(resolve);\n});",
      "fixes": [
        "Return the promise directly",
        "Use async/await instead",
        "Only use Promise constructor for callback-based APIs"
      ]
    },
    {
      "pattern_id": "js_array_holes",
      "name": "Creating Array Holes",
      "severity": "low",
      "description": "Arrays with holes have performance issues",
      "example": "const arr = [1, , , 4];  // Has holes",
      "fixes": [
        "Use undefined explicitly: [1, undefined, undefined, 4]",
        "Use Array.from() or fill() for initialization",
        "Avoid delete on array elements"
      ]
    },
    {
      "pattern_id": "js_modify_prototype",
      "name": "Modifying Native Prototypes",
      "severity": "high",
      "description": "Extending native prototypes causes conflicts",
      "example": "Array.prototype.myMethod = function() {...}",
      "fixes": [
        "Use utility functions instead",
        "Create wrapper classes if needed",
        "Use symbols for private extensions"
      ]
    }
  ],

  "style_guide": {
    "formatting": {
      "line_length": 80,
      "indentation": 2,
      "semicolons": "optional (be consistent)",
      "quotes": "single quotes for strings, backticks for templates",
      "trailing_comma": "always in multiline"
    },
    "naming": {
      "variables": "camelCase",
      "constants": "UPPER_SNAKE_CASE or PascalCase",
      "classes": "PascalCase",
      "interfaces": "PascalCase (TypeScript)",
      "types": "PascalCase (TypeScript)",
      "enums": "PascalCase with PascalCase members",
      "private": "_leadingUnderscore (convention only)",
      "files": "kebab-case.ts or PascalCase.tsx for components"
    },
    "imports": {
      "order": [
        "node built-ins",
        "external packages",
        "internal aliases",
        "relative imports",
        "css/assets"
      ],
      "style": "named imports preferred over default"
    },
    "typescript": {
      "strict": true,
      "no_implicit_any": true,
      "no_explicit_any": "avoid unless necessary",
      "interfaces_over_types": "for object shapes",
      "types_for_unions": "and complex types"
    }
  },

  "testing_patterns": {
    "framework": "Jest or Vitest for unit tests",
    "structure": "Co-locate tests with source files",
    "naming": "*.test.ts or *.spec.ts",
    "assertions": "Use expect() with descriptive matchers",
    "mocking": "Use jest.mock() or vi.mock()",
    "coverage": "Aim for >80% coverage",
    "e2e": "Playwright or Cypress for end-to-end"
  },

  "metadata": {
    "version": "1.0.0",
    "last_updated": "2024-01-10",
    "contributors": ["Singularity Code Quality Engine"],
    "tags": ["javascript", "typescript", "es6", "modern", "best-practices", "async", "type-safety"]
  }
}