{
  "language": "elixir",
  "language_name": "Elixir",
  "version_target": "1.14+",
  "description": "Best practices and patterns for writing high-quality, maintainable, and idiomatic Elixir code",

  "patterns": [
    {
      "pattern_id": "elixir_supervision_tree",
      "name": "Proper OTP Supervision Tree",
      "category": "Architecture",
      "severity": "high",
      "description": "Define proper OTP supervision trees for fault tolerance and system resilience",

      "bad_example": {
        "code": "# Starting processes manually without supervision\npid = spawn(fn -> \n  receive do\n    msg -> IO.puts(msg)\n  end\nend)\n\n# Or worse, using Node.spawn_link without supervision\nNode.spawn_link(:node@host, MyModule, :run, [])",
        "issues": [
          "No automatic restart on failure",
          "Processes not tracked by system",
          "Hard to debug process hierarchy",
          "No backpressure or rate limiting"
        ]
      },

      "good_example": {
        "code": "defmodule MyApp.Supervisor do\n  use Supervisor\n\n  def start_link(opts) do\n    Supervisor.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl true\n  def init(_opts) do\n    children = [\n      # Restart if exits abnormally\n      {MyApp.Worker, restart: :permanent},\n      # Task supervisor for dynamic tasks\n      {Task.Supervisor, name: MyApp.TaskSupervisor},\n      # Registry for process discovery\n      {Registry, keys: :unique, name: MyApp.Registry}\n    ]\n    \n    opts = [\n      strategy: :one_for_one,\n      max_restarts: 3,\n      max_seconds: 5\n    ]\n    \n    Supervisor.init(children, opts)\n  end\nend",
        "benefits": [
          "Automatic process restart on failure",
          "Clean process hierarchy",
          "Easy to monitor and debug",
          "Configurable restart strategies"
        ]
      },

      "learning_resources": [
        "https://hexdocs.pm/elixir/Supervisor.html",
        "https://pragprog.com/titles/elixir16/programming-elixir-1-6/",
        "https://learnyousomeerlang.com/supervisors"
      ]
    },
    {
      "pattern_id": "elixir_pattern_matching",
      "name": "Effective Pattern Matching",
      "category": "Code Quality",
      "severity": "medium",
      "description": "Use pattern matching to write clean, readable, and maintainable code",

      "bad_example": {
        "code": "def handle_response(response) do\n  if response != nil && Map.has_key?(response, :status) do\n    if response.status == 200 do\n      if Map.has_key?(response, :body) && response.body != nil do\n        JSON.decode(response.body)\n      else\n        {:error, \"No body\"}\n      end\n    else\n      {:error, \"Bad status: #{response.status}\"}\n    end\n  else\n    {:error, \"Invalid response\"}\n  end\nend",
        "issues": [
          "Deeply nested conditionals",
          "Hard to read and maintain",
          "Error handling unclear",
          "Multiple nil checks"
        ]
      },

      "good_example": {
        "code": "def handle_response(%{status: 200, body: body}) when not is_nil(body) do\n  JSON.decode(body)\nend\n\ndef handle_response(%{status: 200}) do\n  {:error, :missing_body}\nend\n\ndef handle_response(%{status: status}) do\n  {:error, {:bad_status, status}}\nend\n\ndef handle_response(_) do\n  {:error, :invalid_response}\nend",
        "benefits": [
          "Clear separation of cases",
          "Self-documenting code",
          "No nested conditionals",
          "Guards for additional constraints"
        ]
      },

      "learning_resources": [
        "https://elixir-lang.org/getting-started/pattern-matching.html",
        "https://hexdocs.pm/elixir/patterns-and-guards.html"
      ]
    },
    {
      "pattern_id": "elixir_pipe_operator",
      "name": "Effective Use of Pipe Operator",
      "category": "Code Quality",
      "severity": "medium",
      "description": "Use pipes to chain functions for readability and data transformation clarity",

      "bad_example": {
        "code": "# Nested function calls - hard to read\nresult = Enum.filter(\n  Enum.map(\n    String.split(\n      String.trim(input), \",\"\n    ),\n    &String.to_integer/1\n  ),\n  &(&1 > 10)\n)",
        "issues": [
          "Reading order is inside-out",
          "Hard to follow data flow",
          "Difficult to debug intermediate steps"
        ]
      },

      "good_example": {
        "code": "result = \n  input\n  |> String.trim()\n  |> String.split(\",\")\n  |> Enum.map(&String.to_integer/1)\n  |> Enum.filter(&(&1 > 10))\n  \n# With intermediate variables for debugging\nresult =\n  input\n  |> String.trim()\n  |> tap(&IO.inspect(&1, label: \"trimmed\"))\n  |> String.split(\",\")\n  |> Enum.map(&String.to_integer/1)\n  |> Enum.filter(&(&1 > 10))",
        "benefits": [
          "Clear data flow from top to bottom",
          "Easy to add/remove steps",
          "Natural debugging with tap/2"
        ]
      },

      "learning_resources": [
        "https://elixirschool.com/en/lessons/basics/pipe_operator",
        "https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2"
      ]
    },
    {
      "pattern_id": "elixir_error_handling",
      "name": "Robust Error Handling with Tagged Tuples",
      "category": "Reliability",
      "severity": "high",
      "description": "Handle errors explicitly using tagged tuples instead of exceptions",

      "bad_example": {
        "code": "# Using bang operators that raise\ndef get_user_posts(user_id) do\n  user = Repo.get!(User, user_id)\n  posts = Repo.all!(from p in Post, where: p.user_id == ^user.id)\n  comments = Repo.preload!(posts, :comments)\n  %{user: user, posts: posts}\nend\n\n# No error handling\ndef process_file(path) do\n  File.read!(path)\n  |> Jason.decode!()\n  |> Map.get(\"data\")\nend",
        "issues": [
          "Exceptions crash the calling process",
          "Hard to handle failures gracefully",
          "No way to recover from errors"
        ]
      },

      "good_example": {
        "code": "# Using with for clean error handling\ndef get_user_posts(user_id) do\n  with {:ok, user} <- fetch_user(user_id),\n       {:ok, posts} <- fetch_user_posts(user),\n       {:ok, posts_with_comments} <- load_comments(posts) do\n    {:ok, %{user: user, posts: posts_with_comments}}\n  else\n    {:error, :not_found} -> {:error, \"User not found\"}\n    {:error, reason} -> {:error, reason}\n  end\nend\n\n# Explicit error handling\ndef process_file(path) do\n  with {:ok, content} <- File.read(path),\n       {:ok, json} <- Jason.decode(content),\n       {:ok, data} <- Map.fetch(json, \"data\") do\n    {:ok, data}\n  else\n    {:error, :enoent} -> {:error, \"File not found\"}\n    {:error, %Jason.DecodeError{} = e} -> {:error, \"Invalid JSON: #{e.message}\"}\n    :error -> {:error, \"Missing data field\"}\n  end\nend\n\ndefp fetch_user(id) do\n  case Repo.get(User, id) do\n    nil -> {:error, :not_found}\n    user -> {:ok, user}\n  end\nend",
        "benefits": [
          "Explicit error handling",
          "Process doesn't crash on errors",
          "Clear error propagation",
          "Easy to add specific error cases"
        ]
      },

      "learning_resources": [
        "https://elixirschool.com/en/lessons/intermediate/error_handling",
        "https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1"
      ]
    },
    {
      "pattern_id": "elixir_genserver_state",
      "name": "GenServer State Management",
      "category": "Concurrency",
      "severity": "high",
      "description": "Properly manage state in GenServers with clear interfaces",

      "bad_example": {
        "code": "defmodule Counter do\n  use GenServer\n  \n  # Exposing internal state structure\n  def get_state(pid) do\n    GenServer.call(pid, :get_state)\n  end\n  \n  def handle_call(:get_state, _from, state) do\n    {:reply, state, state}\n  end\n  \n  # Modifying nested state directly\n  def handle_call({:update, key, value}, _from, state) do\n    new_state = put_in(state, [key], value)\n    {:reply, :ok, new_state}\n  end\nend",
        "issues": [
          "Exposes internal state structure",
          "No encapsulation",
          "Hard to change state structure"
        ]
      },

      "good_example": {
        "code": "defmodule Counter do\n  use GenServer\n  \n  defstruct count: 0, max: nil\n  \n  # Public API\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n  \n  def increment do\n    GenServer.call(__MODULE__, :increment)\n  end\n  \n  def get_count do\n    GenServer.call(__MODULE__, :get_count)\n  end\n  \n  # Server callbacks\n  @impl true\n  def init(opts) do\n    state = %__MODULE__{\n      count: Keyword.get(opts, :initial_count, 0),\n      max: Keyword.get(opts, :max)\n    }\n    {:ok, state}\n  end\n  \n  @impl true\n  def handle_call(:increment, _from, %{count: count, max: max} = state) do\n    new_count = count + 1\n    \n    cond do\n      is_nil(max) || new_count <= max ->\n        {:reply, {:ok, new_count}, %{state | count: new_count}}\n      true ->\n        {:reply, {:error, :max_reached}, state}\n    end\n  end\n  \n  @impl true\n  def handle_call(:get_count, _from, %{count: count} = state) do\n    {:reply, count, state}\n  end\nend",
        "benefits": [
          "Clean public API",
          "State structure is private",
          "Easy to refactor internals",
          "Type safety with struct"
        ]
      },

      "learning_resources": [
        "https://hexdocs.pm/elixir/GenServer.html",
        "https://elixirschool.com/en/lessons/intermediate/concurrency"
      ]
    },
    {
      "pattern_id": "elixir_async_tasks",
      "name": "Concurrent Task Management",
      "category": "Performance",
      "severity": "medium",
      "description": "Use Task module for concurrent operations with proper supervision",

      "bad_example": {
        "code": "# Spawning processes without supervision\ndef fetch_all_data(urls) do\n  urls\n  |> Enum.map(fn url ->\n    spawn(fn -> \n      HTTPoison.get!(url)\n    end)\n  end)\n  # No way to collect results!\nend",
        "issues": [
          "No result collection",
          "No error handling",
          "No supervision"
        ]
      },

      "good_example": {
        "code": "def fetch_all_data(urls) do\n  # Using Task.async_stream for concurrent fetching\n  urls\n  |> Task.async_stream(\n    fn url -> \n      case HTTPoison.get(url) do\n        {:ok, response} -> {:ok, response.body}\n        {:error, reason} -> {:error, reason}\n      end\n    end,\n    max_concurrency: 10,\n    timeout: 5000,\n    on_timeout: :kill_task\n  )\n  |> Enum.map(fn\n    {:ok, result} -> result\n    {:exit, :timeout} -> {:error, :timeout}\n    {:exit, reason} -> {:error, reason}\n  end)\nend\n\n# Or using Task.Supervisor for more control\ndef fetch_with_supervisor(urls) do\n  tasks = \n    urls\n    |> Enum.map(fn url ->\n      Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n        HTTPoison.get(url)\n      end)\n    end)\n  \n  Task.await_many(tasks, 5000)\nend",
        "benefits": [
          "Proper supervision",
          "Configurable concurrency",
          "Timeout handling",
          "Clean result collection"
        ]
      },

      "learning_resources": [
        "https://hexdocs.pm/elixir/Task.html",
        "https://hexdocs.pm/elixir/Task.Supervisor.html"
      ]
    },
    {
      "pattern_id": "elixir_ecto_queries",
      "name": "Composable Ecto Queries",
      "category": "Database",
      "severity": "medium",
      "description": "Build composable, reusable query functions",

      "bad_example": {
        "code": "# Monolithic queries\ndef get_active_users_with_posts do\n  Repo.all(\n    from u in User,\n    where: u.active == true,\n    where: u.created_at > ^DateTime.utc_now() |> DateTime.add(-30, :day),\n    join: p in assoc(u, :posts),\n    where: p.published == true,\n    preload: [posts: p]\n  )\nend",
        "issues": [
          "Not reusable",
          "Hard to test",
          "Duplicated logic"
        ]
      },

      "good_example": {
        "code": "# Composable query functions\ndefmodule UserQuery do\n  import Ecto.Query\n  \n  def base, do: from(u in User)\n  \n  def active(query \\\\ base()) do\n    from u in query, where: u.active == true\n  end\n  \n  def recent(query \\\\ base(), days \\\\ 30) do\n    cutoff = DateTime.utc_now() |> DateTime.add(-days, :day)\n    from u in query, where: u.created_at > ^cutoff\n  end\n  \n  def with_published_posts(query \\\\ base()) do\n    from u in query,\n      join: p in assoc(u, :posts),\n      where: p.published == true,\n      preload: [posts: p]\n  end\nend\n\n# Usage - compose as needed\nactive_recent_users = \n  UserQuery.base()\n  |> UserQuery.active()\n  |> UserQuery.recent(7)\n  |> UserQuery.with_published_posts()\n  |> Repo.all()",
        "benefits": [
          "Highly reusable",
          "Easy to test each part",
          "Clear composition",
          "DRY principle"
        ]
      },

      "learning_resources": [
        "https://hexdocs.pm/ecto/Ecto.Query.html",
        "https://dashbit.co/blog/a-new-look-at-ecto-3-query-patterns"
      ]
    }
  ],

  "anti_patterns": [
    {
      "pattern_id": "elixir_deep_nesting",
      "name": "Deeply Nested Conditionals",
      "severity": "medium",
      "description": "Avoid deep nesting, use pattern matching or early returns instead",
      "example": "if condition1 do\n  if condition2 do\n    if condition3 do\n      # deeply nested logic\n    end\n  end\nend",
      "fixes": [
        "Use pattern matching in function heads",
        "Use with/2 for sequential checks",
        "Use guards for simple conditions",
        "Extract to separate functions"
      ]
    },
    {
      "pattern_id": "elixir_misused_bang",
      "name": "Overuse of Bang Operators (!)",
      "severity": "high",
      "description": "Bang operators raise exceptions and should be avoided in production code",
      "example": "user = Repo.get!(User, id)\ndata = File.read!(path)",
      "fixes": [
        "Use case/2 for single operations",
        "Use with/2 for chaining operations",
        "Return {:ok, value} | {:error, reason} tuples",
        "Only use bang in scripts or when crashing is desired"
      ]
    },
    {
      "pattern_id": "elixir_process_dictionary",
      "name": "Process Dictionary Abuse",
      "severity": "high",
      "description": "Using process dictionary instead of proper state management",
      "example": "Process.put(:user_id, 123)\nuser_id = Process.get(:user_id)",
      "fixes": [
        "Use GenServer for stateful processes",
        "Pass state explicitly through function arguments",
        "Use ETS for shared state",
        "Use Registry for process discovery"
      ]
    },
    {
      "pattern_id": "elixir_macro_overuse",
      "name": "Unnecessary Macros",
      "severity": "medium",
      "description": "Creating macros when functions would suffice",
      "example": "defmacro add(a, b) do\n  quote do\n    unquote(a) + unquote(b)\n  end\nend",
      "fixes": [
        "Use functions for computation",
        "Use macros only for compile-time code generation",
        "Prefer function composition",
        "Document why a macro is necessary"
      ]
    },
    {
      "pattern_id": "elixir_improper_string_concat",
      "name": "Inefficient String Concatenation",
      "severity": "low",
      "description": "Using ++ for string concatenation instead of proper methods",
      "example": "result = string1 ++ string2 ++ string3",
      "fixes": [
        "Use interpolation: \"#{str1}#{str2}\"",
        "Use IO lists: [str1, str2]",
        "Use String.concat/2 or <>",
        "Use :erlang.iolist_to_binary/1 for IO lists"
      ]
    }
  ],

  "style_guide": {
    "formatting": {
      "line_length": 98,
      "indentation": 2,
      "file_encoding": "UTF-8",
      "trailing_whitespace": false,
      "final_newline": true
    },
    "naming": {
      "modules": "PascalCase (e.g., MyApp.UserController)",
      "functions": "snake_case (e.g., get_user_by_id)",
      "constants": "@module_attribute (e.g., @max_retries)",
      "private_functions": "regular snake_case (no prefix)",
      "guards": "is_* or has_* prefix (e.g., is_valid_user)",
      "protocols": "PascalCase (e.g., Enumerable)",
      "behaviours": "PascalCase with descriptive name",
      "ecto_schemas": "singular (e.g., User, not Users)"
    },
    "file_organization": {
      "module_attributes": "At top after defmodule",
      "typespecs": "Before function definitions",
      "callbacks": "Group @impl true with implementation",
      "public_functions": "Before private functions",
      "test_files": "Mirror source structure in test/"
    }
  },

  "testing_patterns": {
    "test_structure": "describe/test blocks for organization",
    "async_tests": "use ExUnit.Case, async: true when possible",
    "doctests": "Include doctests for pure functions",
    "property_testing": "Use StreamData for generative testing",
    "test_helpers": "Extract common setup to test/support/"
  },

  "metadata": {
    "version": "1.0.0",
    "last_updated": "2024-01-10",
    "contributors": ["Singularity Code Quality Engine"],
    "tags": ["elixir", "best-practices", "otp", "functional", "beam"]
  }
}