{
  "id": "rust-api-endpoint-generator",
  "name": "Rust API Endpoint Generator",
  "description": "Generates Rust API endpoints using AI signatures optimized for LLM coders",
  "steps": [
    {
      "name": "sparc-phase-1-research",
      "operation": {
        "type": "generate",
        "generate": "sparc-research"
      }
    },
    {
      "name": "sparc-phase-2-architecture",
      "operation": {
        "type": "generate", 
        "generate": "sparc-architecture"
      }
    },
    {
      "name": "sparc-phase-3-security",
      "operation": {
        "type": "generate",
        "generate": "sparc-security"
      }
    },
    {
      "name": "sparc-phase-4-performance",
      "operation": {
        "type": "generate",
        "generate": "sparc-performance"
      }
    },
    {
      "name": "sparc-phase-5-implementation",
      "operation": {
        "type": "generate",
        "generate": "rust-api-endpoint"
      }
    }
  ],
  "metadata": {
    "version": "1.0.0",
    "author": "SPARC Team",
    "created_at": "2024-01-15T10:00:00Z",
    "updated_at": "2024-01-15T10:00:00Z",
    "tags": ["rust", "api", "axum", "dspy", "llm-coder", "code-generation"],
    "performance": {
      "avg_execution_time_ms": 100.0,
      "memory_usage_bytes": 2097152,
      "complexity": 6
    }
  },
  "ai_signature": {
    "name": "rust_api_endpoint_generator",
    "inputs": {
      "entity_name": "The entity name in snake_case (e.g., user, product)",
      "api_version": "API version (v1, v2, etc.)",
      "endpoint_type": "Endpoint type (rest, graphql, grpc)",
      "authentication": "Authentication method (jwt, api_key, oauth)",
      "validation_rules": "Input validation rules (required, optional, constraints)"
    },
    "outputs": {
      "rust_code": "Generated Rust API endpoint code with Axum",
      "routes": "API route definitions",
      "middleware": "Authentication and validation middleware",
      "tests": "API endpoint tests"
    },
    "instruction": "Generate a complete Rust API endpoint using Axum framework with proper request/response handling, validation, authentication, error handling, and comprehensive tests. The code should be production-ready and optimized for LLM coders."
  },
  "template_content": "//! @business-domain {business_domain}\n//! @architecture-pattern api-endpoint\n//! @architecture-layer presentation\n//! @security-level {security_level}\n//! @performance-profile {performance_profile}\n//! @ai-signature rust_api_endpoint_generator\n//! @llm-coder-optimized true\n\nuse axum::{extract::Path, http::StatusCode, response::Json, routing::get, Router};\nuse serde::{Deserialize, Serialize};\nuse tracing::{info, error};\nuse uuid::Uuid;\n\n/// @business-entity {EntityName}Response\n/// @architecture-pattern response-dto\n/// @security-pattern data-transfer-object\n/// @ai-output rust_code: response_struct\n#[derive(Debug, Serialize)]\npub struct {EntityName}Response {\n    /// @business-field {entity_name}_id\n    pub id: String,\n    pub name: String,\n    pub status: String,\n    pub created_at: String,\n}\n\n/// @business-entity {EntityName}Request\n/// @architecture-pattern request-dto\n/// @security-pattern data-transfer-object\n/// @ai-output rust_code: request_struct\n#[derive(Debug, Deserialize)]\npub struct {EntityName}Request {\n    /// @business-field {entity_name}_name\n    /// @security-validation input-sanitization\n    pub name: String,\n}\n\n/// @business-operation get_{entity_name}\n/// @architecture-pattern controller\n/// @security-operation data-retrieval\n/// @performance-metric response-time\n/// @test-scenario happy-path\n/// @test-scenario not-found\n/// @ai-output rust_code: endpoint_handler\npub async fn get_{entity_name}(\n    Path(id): Path<String>,\n) -> Result<Json<{EntityName}Response>, StatusCode> {\n    info!(\"Getting {entity_name} with id: {}\", id);\n    \n    // @security-validation input-sanitization\n    // @performance-critical-section\n    match {entity_name}_service::get_by_id(&id).await {\n        Ok(entity) => {\n            let response = {EntityName}Response {\n                id: entity.id,\n                name: entity.name,\n                status: \"active\".to_string(),\n                created_at: entity.created_at.to_rfc3339(),\n            };\n            Ok(Json(response))\n        }\n        Err(_) => {\n            error!(\"{EntityName} not found: {}\", id);\n            Err(StatusCode::NOT_FOUND)\n        }\n    }\n}\n\n/// @business-operation create_{entity_name}\n/// @architecture-pattern controller\n/// @security-operation data-creation\n/// @performance-metric response-time\n/// @test-scenario happy-path\n/// @test-scenario validation-error\npub async fn create_{entity_name}(\n    Json(payload): Json<{EntityName}Request>,\n) -> Result<Json<{EntityName}Response>, StatusCode> {\n    info!(\"Creating {entity_name} with data: {:?}\", payload);\n    \n    // @security-validation input-sanitization\n    if payload.name.is_empty() {\n        return Err(StatusCode::BAD_REQUEST);\n    }\n    \n    // @performance-critical-section\n    let entity = {entity_name}_service::create(payload.name).await\n        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;\n    \n    let response = {EntityName}Response {\n        id: entity.id,\n        name: entity.name,\n        status: \"active\".to_string(),\n        created_at: entity.created_at.to_rfc3339(),\n    };\n    \n    Ok(Json(response))\n}\n\n/// @architecture-pattern router\n/// @security-boundary api-gateway\n/// @ai-output routes: api_routes\npub fn create_{entity_name}_router() -> Router {\n    Router::new()\n        .route(\"/{entity_name}/:id\", get(get_{entity_name}))\n        .route(\"/{entity_name}\", axum::routing::post(create_{entity_name}))\n        .route(\"/{entity_name}/:id\", axum::routing::put(update_{entity_name}))\n        .route(\"/{entity_name}/:id\", axum::routing::delete(delete_{entity_name}))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use axum::http::StatusCode;\n    use axum::body::Body;\n    use tower::ServiceExt;\n\n    /// @test-scenario happy-path\n    /// @ai-output tests: api_test\n    #[tokio::test]\n    async fn test_get_{entity_name}_success() {\n        let app = create_{entity_name}_router();\n        let response = app\n            .oneshot(\n                axum::http::Request::builder()\n                    .uri(\"/{entity_name}/test-id\")\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n        \n        // Test would need mock service\n        assert_eq!(response.status(), StatusCode::NOT_FOUND);\n    }\n\n    /// @test-scenario validation-error\n    /// @ai-output tests: validation_test\n    #[tokio::test]\n    async fn test_create_{entity_name}_empty_name() {\n        let app = create_{entity_name}_router();\n        let response = app\n            .oneshot(\n                axum::http::Request::builder()\n                    .method(\"POST\")\n                    .uri(\"/{entity_name}\")\n                    .header(\"content-type\", \"application/json\")\n                    .body(Body::from(r#\"{\"name\": \"\"}\"#))\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::BAD_REQUEST);\n    }\n}"
}
