{
  "pattern_id": "owasp_weak_auth",
  "name": "Weak Authentication",
  "cwe": "CWE-287",
  "owasp_category": "A07:2021 - Identification and Authentication Failures",
  "severity": "critical",
  "applicable_languages": ["python", "javascript", "java", "go", "php", "ruby", "csharp"],
  "applicable_frameworks": ["django", "flask", "express", "spring", "rails", "laravel", "aspnet"],
  "description": "Weak authentication mechanisms including plaintext passwords, weak hashing algorithms, hardcoded credentials, and missing multi-factor authentication",

  "vulnerability_patterns": [
    {
      "language": "python",
      "bad_code": [
        "# Plaintext password storage\npassword = request.form['password']\nuser.password = password  # Storing plaintext",
        "# MD5 hashing (weak)\nimport hashlib\nhashed = hashlib.md5(password.encode()).hexdigest()",
        "# SHA1 hashing (weak)\nhashed = hashlib.sha1(password.encode()).hexdigest()",
        "# Hardcoded credentials\nADMIN_PASSWORD = 'admin123'\nif password == ADMIN_PASSWORD:\n    login_user()",
        "# No salt\nhashed = hashlib.sha256(password.encode()).hexdigest()",
        "# Weak password validation\nif len(password) >= 4:\n    # Password too short",
        "# Hardcoded API key\nAPI_KEY = 'sk-1234567890abcdef'\nheaders = {'Authorization': f'Bearer {API_KEY}'}"
      ],
      "risk_description": "Weak password storage and validation allows attackers to compromise user accounts",
      "good_code": [
        "# Using bcrypt\nimport bcrypt\nhashed = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\n# Verify\nbcrypt.checkpw(password.encode('utf-8'), stored_hash)",
        "# Using argon2\nfrom argon2 import PasswordHasher\nph = PasswordHasher()\nhashed = ph.hash(password)\n# Verify\nph.verify(stored_hash, password)",
        "# Django's built-in\nfrom django.contrib.auth.hashers import make_password, check_password\nhashed = make_password(password)\nis_valid = check_password(password, hashed)",
        "# Using environment variables\nimport os\napi_key = os.environ.get('API_KEY')\nif not api_key:\n    raise ValueError('API_KEY not configured')",
        "# Strong password validation\nimport re\ndef validate_password(password):\n    if len(password) < 12:\n        return False\n    if not re.search(r'[A-Z]', password):\n        return False\n    if not re.search(r'[a-z]', password):\n        return False\n    if not re.search(r'[0-9]', password):\n        return False\n    if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\n        return False\n    return True"
      ],
      "fix_explanation": "Use bcrypt or argon2 for password hashing, store secrets in environment variables, implement strong password policies"
    },
    {
      "language": "javascript",
      "bad_code": [
        "// Plaintext password\nconst user = {\n    username: username,\n    password: password  // Storing plaintext\n};",
        "// MD5 hashing (weak)\nconst crypto = require('crypto');\nconst hash = crypto.createHash('md5').update(password).digest('hex');",
        "// SHA1 (weak)\nconst hash = crypto.createHash('sha1').update(password).digest('hex');",
        "// Hardcoded credentials\nconst ADMIN_PASSWORD = 'admin123';\nif (password === ADMIN_PASSWORD) {\n    // Authenticate\n}",
        "// Client-side password validation only\nif (password.length >= 6) {\n    // Weak validation\n    submitForm();\n}",
        "// Hardcoded API key\nconst API_KEY = 'sk-1234567890';\nfetch('/api', {\n    headers: { 'Authorization': `Bearer ${API_KEY}` }\n});",
        "// Storing password in localStorage\nlocalStorage.setItem('password', userPassword);"
      ],
      "risk_description": "Weak password handling and hardcoded secrets expose authentication mechanisms",
      "good_code": [
        "// Using bcrypt\nconst bcrypt = require('bcrypt');\nconst saltRounds = 10;\nconst hash = await bcrypt.hash(password, saltRounds);\n// Verify\nconst match = await bcrypt.compare(password, hash);",
        "// Using argon2\nconst argon2 = require('argon2');\nconst hash = await argon2.hash(password);\n// Verify\nconst valid = await argon2.verify(hash, password);",
        "// Using environment variables\nrequire('dotenv').config();\nconst apiKey = process.env.API_KEY;\nif (!apiKey) {\n    throw new Error('API_KEY not configured');\n}",
        "// Server-side password validation\nfunction validatePassword(password) {\n    const minLength = 12;\n    const hasUpperCase = /[A-Z]/.test(password);\n    const hasLowerCase = /[a-z]/.test(password);\n    const hasNumbers = /\\d/.test(password);\n    const hasSpecialChar = /[!@#$%^&*(),.?\":{}|<>]/.test(password);\n    \n    return password.length >= minLength && \n           hasUpperCase && hasLowerCase && \n           hasNumbers && hasSpecialChar;\n}",
        "// Using secure session storage\napp.use(session({\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n        secure: true,\n        httpOnly: true,\n        sameSite: 'strict'\n    }\n}));"
      ],
      "fix_explanation": "Use bcrypt or argon2, implement server-side validation, use environment variables for secrets"
    },
    {
      "language": "java",
      "bad_code": [
        "// Plaintext password\nString password = request.getParameter(\"password\");\nuser.setPassword(password);  // Storing plaintext",
        "// MD5 hashing (weak)\nMessageDigest md = MessageDigest.getInstance(\"MD5\");\nbyte[] hash = md.digest(password.getBytes());",
        "// SHA1 (weak)\nMessageDigest sha1 = MessageDigest.getInstance(\"SHA-1\");\nString hashed = bytesToHex(sha1.digest(password.getBytes()));",
        "// Hardcoded credentials\nprivate static final String ADMIN_PASSWORD = \"admin123\";\nif (password.equals(ADMIN_PASSWORD)) {\n    authenticateUser();\n}",
        "// No salt\nMessageDigest sha256 = MessageDigest.getInstance(\"SHA-256\");\nString hash = bytesToHex(sha256.digest(password.getBytes()));",
        "// Weak password check\nif (password.length() >= 6) {\n    // Too weak\n}",
        "// Hardcoded database password\nString url = \"jdbc:mysql://localhost:3306/db?user=root&password=root123\";"
      ],
      "risk_description": "Insecure password storage and hardcoded credentials compromise authentication",
      "good_code": [
        "// Using BCrypt\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nBCryptPasswordEncoder encoder = new BCryptPasswordEncoder();\nString hashedPassword = encoder.encode(password);\n// Verify\nboolean matches = encoder.matches(password, hashedPassword);",
        "// Using Argon2\nimport de.mkammerer.argon2.Argon2Factory;\nArgon2 argon2 = Argon2Factory.create();\nString hash = argon2.hash(10, 65536, 1, password.toCharArray());\n// Verify\nboolean verified = argon2.verify(hash, password.toCharArray());",
        "// Using PBKDF2\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nSecureRandom random = new SecureRandom();\nbyte[] salt = new byte[16];\nrandom.nextBytes(salt);\nKeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 65536, 128);\nSecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\nbyte[] hash = factory.generateSecret(spec).getEncoded();",
        "// Using environment variables\nString apiKey = System.getenv(\"API_KEY\");\nif (apiKey == null) {\n    throw new IllegalStateException(\"API_KEY not configured\");\n}",
        "// Strong password validation\npublic boolean validatePassword(String password) {\n    if (password.length() < 12) return false;\n    if (!password.matches(\".*[A-Z].*\")) return false;\n    if (!password.matches(\".*[a-z].*\")) return false;\n    if (!password.matches(\".*[0-9].*\")) return false;\n    if (!password.matches(\".*[!@#$%^&*()].*\")) return false;\n    return true;\n}"
      ],
      "fix_explanation": "Use BCrypt, Argon2, or PBKDF2 for password hashing with proper salt generation"
    },
    {
      "language": "go",
      "bad_code": [
        "// Plaintext password\npassword := r.FormValue(\"password\")\nuser.Password = password  // Storing plaintext",
        "// MD5 (weak)\nimport \"crypto/md5\"\nhash := md5.Sum([]byte(password))\nhashString := fmt.Sprintf(\"%x\", hash)",
        "// SHA1 (weak)\nimport \"crypto/sha1\"\nh := sha1.New()\nh.Write([]byte(password))\nhashed := h.Sum(nil)",
        "// Hardcoded credentials\nconst ADMIN_PASSWORD = \"admin123\"\nif password == ADMIN_PASSWORD {\n    // Authenticate\n}",
        "// No salt with SHA256\nimport \"crypto/sha256\"\nhash := sha256.Sum256([]byte(password))",
        "// Weak validation\nif len(password) >= 6 {\n    // Too short\n}",
        "// Hardcoded API key\nconst API_KEY = \"sk-1234567890\"\nreq.Header.Set(\"Authorization\", \"Bearer \" + API_KEY)"
      ],
      "risk_description": "Weak cryptographic functions and hardcoded secrets compromise security",
      "good_code": [
        "// Using bcrypt\nimport \"golang.org/x/crypto/bcrypt\"\nhashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n// Verify\nerr = bcrypt.CompareHashAndPassword(hashed, []byte(password))",
        "// Using argon2\nimport \"golang.org/x/crypto/argon2\"\nsalt := make([]byte, 16)\n_, err := rand.Read(salt)\nhash := argon2.IDKey([]byte(password), salt, 1, 64*1024, 4, 32)",
        "// Using scrypt\nimport \"golang.org/x/crypto/scrypt\"\nsalt := make([]byte, 32)\n_, err := rand.Read(salt)\nhash, err := scrypt.Key([]byte(password), salt, 32768, 8, 1, 32)",
        "// Environment variables\nimport \"os\"\napiKey := os.Getenv(\"API_KEY\")\nif apiKey == \"\" {\n    log.Fatal(\"API_KEY not set\")\n}",
        "// Strong password validation\nfunc validatePassword(password string) bool {\n    if len(password) < 12 {\n        return false\n    }\n    var hasUpper, hasLower, hasNumber, hasSpecial bool\n    for _, char := range password {\n        switch {\n        case unicode.IsUpper(char):\n            hasUpper = true\n        case unicode.IsLower(char):\n            hasLower = true\n        case unicode.IsNumber(char):\n            hasNumber = true\n        case unicode.IsPunct(char) || unicode.IsSymbol(char):\n            hasSpecial = true\n        }\n    }\n    return hasUpper && hasLower && hasNumber && hasSpecial\n}"
      ],
      "fix_explanation": "Use bcrypt, argon2, or scrypt with proper salt generation and cost parameters"
    },
    {
      "language": "php",
      "bad_code": [
        "// Plaintext password\n$password = $_POST['password'];\n$user->password = $password;  // Storing plaintext",
        "// MD5 (weak)\n$hash = md5($password);",
        "// SHA1 (weak)\n$hash = sha1($password);",
        "// Hardcoded credentials\ndefine('ADMIN_PASSWORD', 'admin123');\nif ($password === ADMIN_PASSWORD) {\n    // Authenticate\n}",
        "// Weak custom hash\n$hash = sha256($password . 'static_salt');",
        "// Database credentials in code\n$conn = new mysqli('localhost', 'root', 'password123', 'database');",
        "// Weak validation\nif (strlen($password) >= 6) {\n    // Too short\n}"
      ],
      "risk_description": "Weak hashing functions and exposed credentials enable password attacks",
      "good_code": [
        "// Using password_hash (bcrypt by default)\n$hash = password_hash($password, PASSWORD_DEFAULT);\n// Or with specific algorithm\n$hash = password_hash($password, PASSWORD_ARGON2ID);\n// Verify\nif (password_verify($password, $hash)) {\n    // Valid password\n}",
        "// Using Argon2id explicitly\n$options = [\n    'memory_cost' => 65536,\n    'time_cost' => 4,\n    'threads' => 3,\n];\n$hash = password_hash($password, PASSWORD_ARGON2ID, $options);",
        "// Environment variables\n$apiKey = $_ENV['API_KEY'] ?? getenv('API_KEY');\nif (!$apiKey) {\n    throw new Exception('API_KEY not configured');\n}",
        "// Database credentials from environment\n$conn = new mysqli(\n    $_ENV['DB_HOST'],\n    $_ENV['DB_USER'],\n    $_ENV['DB_PASS'],\n    $_ENV['DB_NAME']\n);",
        "// Strong password validation\nfunction validatePassword($password) {\n    if (strlen($password) < 12) return false;\n    if (!preg_match('/[A-Z]/', $password)) return false;\n    if (!preg_match('/[a-z]/', $password)) return false;\n    if (!preg_match('/[0-9]/', $password)) return false;\n    if (!preg_match('/[!@#$%^&*()]/', $password)) return false;\n    return true;\n}"
      ],
      "fix_explanation": "Use password_hash() with PASSWORD_DEFAULT or PASSWORD_ARGON2ID"
    },
    {
      "language": "ruby",
      "bad_code": [
        "# Plaintext password\npassword = params[:password]\nuser.password = password  # Storing plaintext",
        "# MD5 (weak)\nrequire 'digest'\nhash = Digest::MD5.hexdigest(password)",
        "# SHA1 (weak)\nhash = Digest::SHA1.hexdigest(password)",
        "# Hardcoded credentials\nADMIN_PASSWORD = 'admin123'\nif password == ADMIN_PASSWORD\n  authenticate_user\nend",
        "# No salt\nhash = Digest::SHA256.hexdigest(password)",
        "# Hardcoded API key\nAPI_KEY = 'sk-1234567890'\nheaders = { 'Authorization' => \"Bearer #{API_KEY}\" }",
        "# Weak validation\nif password.length >= 6\n  # Too short\nend"
      ],
      "risk_description": "Weak digest algorithms and plaintext storage compromise password security",
      "good_code": [
        "# Using bcrypt\nrequire 'bcrypt'\nhashed = BCrypt::Password.create(password)\n# Verify\nstored_hash = BCrypt::Password.new(user.password_digest)\nif stored_hash == password\n  # Valid\nend",
        "# Rails has_secure_password\nclass User < ApplicationRecord\n  has_secure_password\n  \n  validates :password, length: { minimum: 12 },\n                      format: { with: /\\A(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/ }\nend",
        "# Using argon2\nrequire 'argon2'\nhasher = Argon2::Password.new\nhashed = hasher.create(password)\n# Verify\nArgon2::Password.verify_password(password, hashed)",
        "# Environment variables\napi_key = ENV['API_KEY']\nraise 'API_KEY not configured' unless api_key",
        "# Strong password validation\ndef validate_password(password)\n  return false if password.length < 12\n  return false unless password =~ /[A-Z]/\n  return false unless password =~ /[a-z]/\n  return false unless password =~ /\\d/\n  return false unless password =~ /[!@#$%^&*()]/\n  true\nend"
      ],
      "fix_explanation": "Use bcrypt or argon2, leverage Rails has_secure_password for built-in security"
    },
    {
      "language": "csharp",
      "bad_code": [
        "// Plaintext password\nstring password = Request.Form[\"password\"];\nuser.Password = password;  // Storing plaintext",
        "// MD5 (weak)\nusing (var md5 = MD5.Create())\n{\n    byte[] hash = md5.ComputeHash(Encoding.UTF8.GetBytes(password));\n}",
        "// SHA1 (weak)\nusing (var sha1 = SHA1.Create())\n{\n    byte[] hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(password));\n}",
        "// Hardcoded credentials\nconst string ADMIN_PASSWORD = \"admin123\";\nif (password == ADMIN_PASSWORD)\n{\n    AuthenticateUser();\n}",
        "// No salt\nusing (var sha256 = SHA256.Create())\n{\n    byte[] hash = sha256.ComputeHash(Encoding.UTF8.GetBytes(password));\n}",
        "// Connection string with password\nstring connString = \"Server=localhost;Database=myDB;User Id=sa;Password=password123;\";",
        "// Weak validation\nif (password.Length >= 6)\n{\n    // Too short\n}"
      ],
      "risk_description": "Weak hashing algorithms and hardcoded credentials expose authentication",
      "good_code": [
        "// Using BCrypt.Net\nusing BCrypt.Net;\nstring hash = BCrypt.Net.BCrypt.HashPassword(password);\n// Verify\nbool valid = BCrypt.Net.BCrypt.Verify(password, hash);",
        "// Using Argon2\nusing Konscious.Security.Cryptography;\nvar argon2 = new Argon2id(Encoding.UTF8.GetBytes(password));\nargon2.Salt = GenerateSalt();\nargon2.DegreeOfParallelism = 8;\nargon2.Iterations = 4;\nargon2.MemorySize = 1024 * 128;\nbyte[] hash = argon2.GetBytes(32);",
        "// Using ASP.NET Core Identity\nvar hasher = new PasswordHasher<User>();\nstring hash = hasher.HashPassword(user, password);\n// Verify\nvar result = hasher.VerifyHashedPassword(user, hash, password);",
        "// Using configuration\nvar apiKey = Configuration[\"ApiKey\"];\nif (string.IsNullOrEmpty(apiKey))\n{\n    throw new InvalidOperationException(\"API key not configured\");\n}",
        "// Connection string from configuration\nstring connString = Configuration.GetConnectionString(\"DefaultConnection\");",
        "// Strong password validation\npublic bool ValidatePassword(string password)\n{\n    if (password.Length < 12) return false;\n    if (!Regex.IsMatch(password, @\"[A-Z]\")) return false;\n    if (!Regex.IsMatch(password, @\"[a-z]\")) return false;\n    if (!Regex.IsMatch(password, @\"[0-9]\")) return false;\n    if (!Regex.IsMatch(password, @\"[!@#$%^&*()]\")) return false;\n    return true;\n}"
      ],
      "fix_explanation": "Use BCrypt.Net, Argon2, or ASP.NET Core Identity for secure password hashing"
    }
  ],

  "detection_rules": {
    "ast_patterns": [
      "MD5 or SHA1 function calls",
      "Plaintext password assignment",
      "Hardcoded string literals with 'password' or 'secret'",
      "Direct password comparison without hashing",
      "Missing salt in hash operations",
      "Password length checks less than 10 characters"
    ],
    "regex_patterns": [
      "\\bmd5\\s*\\(",
      "\\bsha1\\s*\\(",
      "password\\s*=\\s*['\"][^'\"]+['\"]",
      "API_KEY\\s*=\\s*['\"][^'\"]+['\"]",
      "if.*password\\s*==\\s*['\"]",
      "strlen\\(.*password.*\\)\\s*[<>]=?\\s*[1-8]\\b",
      "password\\.length\\s*[<>]=?\\s*[1-8]\\b"
    ],
    "code_smell_indicators": [
      "Passwords stored in plain text files",
      "Credentials in source control",
      "Simple string comparison for authentication",
      "Custom crypto implementations",
      "Static salts",
      "Client-side only password validation"
    ]
  },

  "remediation": {
    "steps": [
      "Replace MD5/SHA1 with bcrypt, argon2, or scrypt",
      "Use a minimum cost factor of 10 for bcrypt",
      "Generate unique salts for each password",
      "Store all secrets in environment variables or secure vaults",
      "Implement strong password policies (12+ characters, mixed case, numbers, symbols)",
      "Add multi-factor authentication (MFA/2FA)",
      "Implement account lockout after failed attempts",
      "Use secure session management",
      "Implement password rotation policies",
      "Never log passwords or authentication tokens"
    ],
    "code_examples": [
      {
        "framework": "Django",
        "safe_code": "# settings.py\nPASSWORD_HASHERS = [\n    'django.contrib.auth.hashers.Argon2PasswordHasher',\n    'django.contrib.auth.hashers.PBKDF2PasswordHasher',\n    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',\n    'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',\n]\n\nAUTH_PASSWORD_VALIDATORS = [\n    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n     'OPTIONS': {'min_length': 12}},\n    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},\n]"
      },
      {
        "framework": "Spring Security",
        "safe_code": "@Bean\npublic PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder(12);\n    // Or for Argon2:\n    // return new Argon2PasswordEncoder();\n}\n\n@Bean\npublic UserDetailsService userDetailsService() {\n    return username -> {\n        User user = userRepository.findByUsername(username);\n        if (user == null) {\n            throw new UsernameNotFoundException(username);\n        }\n        return user;\n    };\n}"
      }
    ],
    "prevention_guidelines": [
      "Never store passwords in plain text",
      "Use established cryptographic libraries",
      "Implement rate limiting on authentication endpoints",
      "Log authentication failures for monitoring",
      "Use secure communication (HTTPS/TLS)",
      "Implement session timeout and rotation",
      "Consider passwordless authentication options",
      "Regular security audits of authentication code"
    ]
  },

  "impact": {
    "severity_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "business_impact": "Account takeover, data breach, unauthorized access, identity theft",
    "technical_impact": "Password cracking, rainbow table attacks, credential stuffing, brute force",
    "confidentiality": "high",
    "integrity": "high",
    "availability": "high",
    "compliance_violations": ["GDPR", "PCI-DSS", "HIPAA", "SOC2", "ISO-27001"]
  },

  "references": [
    "https://owasp.org/www-project-top-ten/2021/A07_2021-Identification_and_Authentication_Failures",
    "https://cwe.mitre.org/data/definitions/287.html",
    "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html",
    "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html",
    "https://www.nist.gov/publications/digital-identity-guidelines"
  ],

  "test_cases": [
    {
      "input": "password123",
      "description": "Weak password - too common",
      "expected_detection": true,
      "attack_type": "dictionary_attack"
    },
    {
      "input": "md5('password')",
      "description": "MD5 hash usage",
      "expected_detection": true,
      "attack_type": "weak_hash"
    },
    {
      "input": "if (password == 'admin123')",
      "description": "Hardcoded credential check",
      "expected_detection": true,
      "attack_type": "hardcoded_password"
    },
    {
      "input": "sha1(password + 'salt')",
      "description": "SHA1 with static salt",
      "expected_detection": true,
      "attack_type": "weak_hash_static_salt"
    }
  ],

  "metadata": {
    "last_updated": "2025-01-10",
    "version": "1.0.0",
    "tags": ["authentication", "passwords", "hashing", "critical"],
    "related_patterns": ["cwe_256_plaintext_storage", "cwe_916_weak_hash", "cwe_798_hardcoded_credentials"]
  }
}