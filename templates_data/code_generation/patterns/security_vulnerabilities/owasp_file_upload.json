{
  "pattern_id": "owasp_file_upload",
  "name": "Unrestricted File Upload",
  "cwe": "CWE-434",
  "owasp_category": "A04:2021 - Insecure Design",
  "severity": "high",
  "applicable_languages": ["python", "javascript", "java", "go", "php", "ruby", "csharp"],
  "applicable_frameworks": ["django", "flask", "express", "spring", "rails", "laravel", "aspnet"],
  "description": "Unrestricted file upload vulnerabilities allow attackers to upload malicious files that can be executed on the server",

  "vulnerability_patterns": [
    {
      "language": "python",
      "bad_code": [
        "# No file type validation\n@app.route('/upload', methods=['POST'])\ndef upload():\n    file = request.files['file']\n    file.save(os.path.join('uploads', file.filename))",
        "# Extension check only\nif file.filename.endswith('.jpg'):\n    file.save(file.filename)",
        "# No size limit\nfile = request.files['file']\nfile.save('uploads/' + file.filename)",
        "# Executable directory\nfile.save('/var/www/html/' + file.filename)",
        "# Using user-provided filename directly\nfilename = request.files['file'].filename\nfile.save(f'uploads/{filename}')",
        "# No content validation\nif file.content_type == 'image/jpeg':\n    # Only checks MIME type from client\n    file.save(file.filename)"
      ],
      "risk_description": "Missing file validation allows uploading and executing malicious files",
      "good_code": [
        "# Complete file validation\nimport os\nimport magic\nimport hashlib\nfrom werkzeug.utils import secure_filename\n\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\nMAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB\n\ndef allowed_file(filename):\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/upload', methods=['POST'])\ndef upload():\n    file = request.files['file']\n    \n    # Check file size\n    file.seek(0, os.SEEK_END)\n    file_size = file.tell()\n    file.seek(0)\n    \n    if file_size > MAX_FILE_SIZE:\n        return 'File too large', 400\n    \n    # Validate filename\n    if not allowed_file(file.filename):\n        return 'Invalid file type', 400\n    \n    # Secure the filename\n    filename = secure_filename(file.filename)\n    \n    # Generate unique filename\n    unique_filename = hashlib.md5(os.urandom(32)).hexdigest() + '_' + filename\n    \n    # Save to non-executable directory\n    filepath = os.path.join('uploads', unique_filename)\n    file.save(filepath)\n    \n    # Verify file content\n    mime = magic.Magic(mime=True)\n    file_mime = mime.from_file(filepath)\n    \n    if not file_mime.startswith('image/'):\n        os.remove(filepath)\n        return 'Invalid file content', 400\n    \n    # Set proper permissions\n    os.chmod(filepath, 0o644)\n    \n    return 'File uploaded successfully'"
      ],
      "fix_explanation": "Validate file type, size, content, use secure filenames, store outside web root"
    },
    {
      "language": "javascript",
      "bad_code": [
        "// No validation\napp.post('/upload', upload.single('file'), (req, res) => {\n    res.send('File uploaded');\n});",
        "// Extension check only\nconst path = require('path');\nif (path.extname(file.originalname) === '.jpg') {\n    // Save file\n}",
        "// No size limit\nconst multer = require('multer');\nconst upload = multer({ dest: 'uploads/' });",
        "// User-controlled filename\nconst storage = multer.diskStorage({\n    destination: 'uploads/',\n    filename: (req, file, cb) => {\n        cb(null, file.originalname);\n    }\n});",
        "// Public directory\nconst upload = multer({ dest: 'public/uploads/' });"
      ],
      "risk_description": "Missing validation allows malicious file uploads and execution",
      "good_code": [
        "// Complete validation\nconst multer = require('multer');\nconst path = require('path');\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst fileType = require('file-type');\n\nconst ALLOWED_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif'];\nconst MAX_SIZE = 5 * 1024 * 1024; // 5MB\n\nconst storage = multer.diskStorage({\n    destination: (req, file, cb) => {\n        // Store outside web root\n        cb(null, '/var/uploads/');\n    },\n    filename: (req, file, cb) => {\n        // Generate unique filename\n        const uniqueSuffix = crypto.randomBytes(16).toString('hex');\n        const ext = path.extname(file.originalname).toLowerCase();\n        cb(null, uniqueSuffix + ext);\n    }\n});\n\nconst fileFilter = (req, file, cb) => {\n    const ext = path.extname(file.originalname).toLowerCase();\n    \n    if (!ALLOWED_EXTENSIONS.includes(ext)) {\n        return cb(new Error('Invalid file type'), false);\n    }\n    \n    // Check MIME type\n    const allowedMimes = ['image/jpeg', 'image/png', 'image/gif'];\n    if (!allowedMimes.includes(file.mimetype)) {\n        return cb(new Error('Invalid MIME type'), false);\n    }\n    \n    cb(null, true);\n};\n\nconst upload = multer({\n    storage: storage,\n    fileFilter: fileFilter,\n    limits: {\n        fileSize: MAX_SIZE,\n        files: 1\n    }\n});\n\napp.post('/upload', upload.single('file'), async (req, res) => {\n    if (!req.file) {\n        return res.status(400).send('No file uploaded');\n    }\n    \n    // Verify file content\n    const buffer = fs.readFileSync(req.file.path);\n    const type = await fileType.fromBuffer(buffer);\n    \n    if (!type || !type.mime.startsWith('image/')) {\n        fs.unlinkSync(req.file.path);\n        return res.status(400).send('Invalid file content');\n    }\n    \n    // Set permissions\n    fs.chmodSync(req.file.path, '0644');\n    \n    res.send('File uploaded successfully');\n});"
      ],
      "fix_explanation": "Use multer with filters, validate content, store outside web root"
    },
    {
      "language": "java",
      "bad_code": [
        "// No validation\n@PostMapping(\"/upload\")\npublic String upload(@RequestParam(\"file\") MultipartFile file) {\n    file.transferTo(new File(\"uploads/\" + file.getOriginalFilename()));\n    return \"success\";\n}",
        "// Extension check only\nif (file.getOriginalFilename().endsWith(\".jpg\")) {\n    file.transferTo(new File(file.getOriginalFilename()));\n}",
        "// No size limit\n@Bean\npublic MultipartConfigElement multipartConfigElement() {\n    MultipartConfigFactory factory = new MultipartConfigFactory();\n    // No size limits set\n    return factory.createMultipartConfig();\n}",
        "// Web-accessible directory\nfile.transferTo(new File(servletContext.getRealPath(\"/\") + file.getOriginalFilename()));"
      ],
      "risk_description": "Missing validation enables malicious file upload and execution",
      "good_code": [
        "// Complete validation\n@PostMapping(\"/upload\")\npublic ResponseEntity<String> upload(@RequestParam(\"file\") MultipartFile file) {\n    // Allowed extensions\n    List<String> allowedExtensions = Arrays.asList(\"jpg\", \"jpeg\", \"png\", \"gif\");\n    \n    // Max size: 5MB\n    long maxSize = 5 * 1024 * 1024;\n    \n    if (file.isEmpty()) {\n        return ResponseEntity.badRequest().body(\"No file selected\");\n    }\n    \n    // Check file size\n    if (file.getSize() > maxSize) {\n        return ResponseEntity.badRequest().body(\"File too large\");\n    }\n    \n    // Get and validate extension\n    String originalFilename = file.getOriginalFilename();\n    String extension = \"\";\n    \n    if (originalFilename != null && originalFilename.contains(\".\")) {\n        extension = originalFilename.substring(originalFilename.lastIndexOf(\".\") + 1).toLowerCase();\n    }\n    \n    if (!allowedExtensions.contains(extension)) {\n        return ResponseEntity.badRequest().body(\"Invalid file type\");\n    }\n    \n    // Validate MIME type\n    String contentType = file.getContentType();\n    if (contentType == null || !contentType.startsWith(\"image/\")) {\n        return ResponseEntity.badRequest().body(\"Invalid content type\");\n    }\n    \n    // Generate unique filename\n    String uniqueFilename = UUID.randomUUID().toString() + \".\" + extension;\n    \n    // Save to secure directory (outside web root)\n    Path uploadPath = Paths.get(\"/var/uploads\");\n    if (!Files.exists(uploadPath)) {\n        Files.createDirectories(uploadPath);\n    }\n    \n    Path filePath = uploadPath.resolve(uniqueFilename);\n    \n    try {\n        // Save file\n        Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);\n        \n        // Verify file content using Apache Tika\n        Tika tika = new Tika();\n        String detectedType = tika.detect(filePath.toFile());\n        \n        if (!detectedType.startsWith(\"image/\")) {\n            Files.deleteIfExists(filePath);\n            return ResponseEntity.badRequest().body(\"File content does not match type\");\n        }\n        \n        // Set permissions (Unix-like systems)\n        Set<PosixFilePermission> perms = PosixFilePermissions.fromString(\"rw-r--r--\");\n        Files.setPosixFilePermissions(filePath, perms);\n        \n        return ResponseEntity.ok(\"File uploaded successfully\");\n        \n    } catch (IOException e) {\n        return ResponseEntity.status(500).body(\"Upload failed\");\n    }\n}\n\n// Configuration\n@Bean\npublic MultipartConfigElement multipartConfigElement() {\n    MultipartConfigFactory factory = new MultipartConfigFactory();\n    factory.setMaxFileSize(DataSize.ofMegabytes(5));\n    factory.setMaxRequestSize(DataSize.ofMegabytes(5));\n    return factory.createMultipartConfig();\n}"
      ],
      "fix_explanation": "Validate extension, MIME type, content, use UUID filenames, store securely"
    },
    {
      "language": "go",
      "bad_code": [
        "// No validation\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n    file, header, _ := r.FormFile(\"file\")\n    defer file.Close()\n    \n    out, _ := os.Create(header.Filename)\n    defer out.Close()\n    \n    io.Copy(out, file)\n}",
        "// Extension check only\nif strings.HasSuffix(header.Filename, \".jpg\") {\n    // Save file\n}",
        "// No size limit\nr.ParseMultipartForm(32 << 20) // No actual limit enforced",
        "// Web-accessible directory\nout, _ := os.Create(\"./public/\" + header.Filename)"
      ],
      "risk_description": "Missing validation allows arbitrary file upload and execution",
      "good_code": [
        "// Complete validation\nimport (\n    \"crypto/rand\"\n    \"encoding/hex\"\n    \"io\"\n    \"mime/multipart\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\nconst maxUploadSize = 5 * 1024 * 1024 // 5MB\n\nvar allowedExtensions = map[string]bool{\n    \".jpg\":  true,\n    \".jpeg\": true,\n    \".png\":  true,\n    \".gif\":  true,\n}\n\nvar allowedMIMETypes = map[string]bool{\n    \"image/jpeg\": true,\n    \"image/png\":  true,\n    \"image/gif\":  true,\n}\n\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n    // Limit request body size\n    r.Body = http.MaxBytesReader(w, r.Body, maxUploadSize)\n    \n    if err := r.ParseMultipartForm(maxUploadSize); err != nil {\n        http.Error(w, \"File too large\", http.StatusBadRequest)\n        return\n    }\n    \n    file, header, err := r.FormFile(\"file\")\n    if err != nil {\n        http.Error(w, \"Error retrieving file\", http.StatusBadRequest)\n        return\n    }\n    defer file.Close()\n    \n    // Check file size\n    if header.Size > maxUploadSize {\n        http.Error(w, \"File too large\", http.StatusBadRequest)\n        return\n    }\n    \n    // Validate extension\n    ext := strings.ToLower(filepath.Ext(header.Filename))\n    if !allowedExtensions[ext] {\n        http.Error(w, \"Invalid file type\", http.StatusBadRequest)\n        return\n    }\n    \n    // Check MIME type\n    buffer := make([]byte, 512)\n    _, err = file.Read(buffer)\n    if err != nil {\n        http.Error(w, \"Error reading file\", http.StatusInternalServerError)\n        return\n    }\n    file.Seek(0, 0) // Reset file pointer\n    \n    contentType := http.DetectContentType(buffer)\n    if !allowedMIMETypes[contentType] {\n        http.Error(w, \"Invalid file content\", http.StatusBadRequest)\n        return\n    }\n    \n    // Generate unique filename\n    randomBytes := make([]byte, 16)\n    rand.Read(randomBytes)\n    uniqueFilename := hex.EncodeToString(randomBytes) + ext\n    \n    // Create upload directory if not exists\n    uploadDir := \"/var/uploads\"\n    os.MkdirAll(uploadDir, os.ModePerm)\n    \n    // Create destination file\n    dst, err := os.Create(filepath.Join(uploadDir, uniqueFilename))\n    if err != nil {\n        http.Error(w, \"Error saving file\", http.StatusInternalServerError)\n        return\n    }\n    defer dst.Close()\n    \n    // Copy file content\n    _, err = io.Copy(dst, file)\n    if err != nil {\n        http.Error(w, \"Error saving file\", http.StatusInternalServerError)\n        return\n    }\n    \n    // Set file permissions\n    os.Chmod(filepath.Join(uploadDir, uniqueFilename), 0644)\n    \n    w.WriteHeader(http.StatusOK)\n    w.Write([]byte(\"File uploaded successfully\"))\n}\n\n// Additional content validation\nfunc validateImageContent(filepath string) bool {\n    file, err := os.Open(filepath)\n    if err != nil {\n        return false\n    }\n    defer file.Close()\n    \n    // Read file header\n    header := make([]byte, 261)\n    file.Read(header)\n    \n    // Check magic numbers\n    if header[0] == 0xFF && header[1] == 0xD8 && header[2] == 0xFF {\n        return true // JPEG\n    }\n    if header[0] == 0x89 && header[1] == 0x50 && header[2] == 0x4E && header[3] == 0x47 {\n        return true // PNG\n    }\n    if header[0] == 0x47 && header[1] == 0x49 && header[2] == 0x46 {\n        return true // GIF\n    }\n    \n    return false\n}"
      ],
      "fix_explanation": "Validate size, extension, MIME type, content, use unique filenames"
    },
    {
      "language": "php",
      "bad_code": [
        "// No validation\nmove_uploaded_file($_FILES['file']['tmp_name'], 'uploads/' . $_FILES['file']['name']);",
        "// Extension check only\n$ext = pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION);\nif ($ext == 'jpg') {\n    move_uploaded_file($_FILES['file']['tmp_name'], $_FILES['file']['name']);\n}",
        "// No size check\nif ($_FILES['file']['error'] == UPLOAD_ERR_OK) {\n    move_uploaded_file($_FILES['file']['tmp_name'], 'uploads/' . $_FILES['file']['name']);\n}",
        "// Web-accessible directory\nmove_uploaded_file($_FILES['file']['tmp_name'], $_SERVER['DOCUMENT_ROOT'] . '/' . $_FILES['file']['name']);"
      ],
      "risk_description": "Missing validation allows PHP shell upload and execution",
      "good_code": [
        "// Complete validation\n<?php\n$allowedExtensions = ['jpg', 'jpeg', 'png', 'gif'];\n$allowedMimeTypes = ['image/jpeg', 'image/png', 'image/gif'];\n$maxFileSize = 5 * 1024 * 1024; // 5MB\n$uploadDir = '/var/uploads/'; // Outside web root\n\nif (!isset($_FILES['file']) || $_FILES['file']['error'] !== UPLOAD_ERR_OK) {\n    die('Upload failed');\n}\n\n$file = $_FILES['file'];\n\n// Check file size\nif ($file['size'] > $maxFileSize) {\n    die('File too large');\n}\n\n// Validate extension\n$filename = basename($file['name']);\n$ext = strtolower(pathinfo($filename, PATHINFO_EXTENSION));\n\nif (!in_array($ext, $allowedExtensions)) {\n    die('Invalid file type');\n}\n\n// Validate MIME type\n$finfo = finfo_open(FILEINFO_MIME_TYPE);\n$mimeType = finfo_file($finfo, $file['tmp_name']);\nfinfo_close($finfo);\n\nif (!in_array($mimeType, $allowedMimeTypes)) {\n    die('Invalid file content');\n}\n\n// Additional content validation\n$imageInfo = getimagesize($file['tmp_name']);\nif ($imageInfo === false) {\n    die('Invalid image file');\n}\n\n// Generate unique filename\n$uniqueFilename = bin2hex(random_bytes(16)) . '.' . $ext;\n$targetPath = $uploadDir . $uniqueFilename;\n\n// Create directory if not exists\nif (!is_dir($uploadDir)) {\n    mkdir($uploadDir, 0755, true);\n}\n\n// Move file to secure location\nif (move_uploaded_file($file['tmp_name'], $targetPath)) {\n    // Set proper permissions\n    chmod($targetPath, 0644);\n    \n    // Additional security: re-encode image to remove any embedded code\n    $image = imagecreatefromstring(file_get_contents($targetPath));\n    if ($image !== false) {\n        switch ($ext) {\n            case 'jpg':\n            case 'jpeg':\n                imagejpeg($image, $targetPath, 90);\n                break;\n            case 'png':\n                imagepng($image, $targetPath, 9);\n                break;\n            case 'gif':\n                imagegif($image, $targetPath);\n                break;\n        }\n        imagedestroy($image);\n    }\n    \n    echo 'File uploaded successfully';\n} else {\n    die('Upload failed');\n}\n\n// Additional: Add .htaccess to upload directory\n$htaccess = $uploadDir . '.htaccess';\nif (!file_exists($htaccess)) {\n    file_put_contents($htaccess, \"Options -Indexes\\nOptions -ExecCGI\\nAddHandler cgi-script .php .pl .py .jsp .asp .sh .cgi\\n\");\n}\n?>"
      ],
      "fix_explanation": "Validate extension, MIME, content, re-encode images, store outside web root"
    },
    {
      "language": "ruby",
      "bad_code": [
        "# No validation\ndef upload\n  uploaded_file = params[:file]\n  File.open(Rails.root.join('public', 'uploads', uploaded_file.original_filename), 'wb') do |file|\n    file.write(uploaded_file.read)\n  end\nend",
        "# Extension only\nif params[:file].original_filename.end_with?('.jpg')\n  # Save file\nend",
        "# No size limit\nclass UploadsController < ApplicationController\n  # No file size validation\n  def create\n    @upload = Upload.new(upload_params)\n    @upload.save\n  end\nend"
      ],
      "risk_description": "Missing validation allows uploading executable files",
      "good_code": [
        "# Complete validation\nclass FileUploadService\n  ALLOWED_EXTENSIONS = %w[.jpg .jpeg .png .gif].freeze\n  ALLOWED_CONTENT_TYPES = %w[image/jpeg image/png image/gif].freeze\n  MAX_FILE_SIZE = 5.megabytes\n  UPLOAD_DIRECTORY = Rails.root.join('storage', 'uploads')\n  \n  def initialize(file)\n    @file = file\n  end\n  \n  def upload\n    validate_presence!\n    validate_size!\n    validate_extension!\n    validate_content_type!\n    validate_content!\n    \n    save_file\n  end\n  \n  private\n  \n  def validate_presence!\n    raise 'No file provided' unless @file.present?\n  end\n  \n  def validate_size!\n    raise 'File too large' if @file.size > MAX_FILE_SIZE\n  end\n  \n  def validate_extension!\n    extension = File.extname(@file.original_filename).downcase\n    raise 'Invalid file type' unless ALLOWED_EXTENSIONS.include?(extension)\n  end\n  \n  def validate_content_type!\n    raise 'Invalid content type' unless ALLOWED_CONTENT_TYPES.include?(@file.content_type)\n  end\n  \n  def validate_content!\n    # Use marcel gem for content detection\n    require 'marcel'\n    mime_type = Marcel::MimeType.for(@file.tempfile)\n    raise 'File content does not match type' unless mime_type.start_with?('image/')\n  end\n  \n  def save_file\n    # Generate unique filename\n    extension = File.extname(@file.original_filename)\n    unique_filename = \"#{SecureRandom.hex(16)}#{extension}\"\n    \n    # Ensure upload directory exists\n    FileUtils.mkdir_p(UPLOAD_DIRECTORY)\n    \n    # Save file\n    filepath = UPLOAD_DIRECTORY.join(unique_filename)\n    \n    File.open(filepath, 'wb') do |file|\n      file.write(@file.read)\n    end\n    \n    # Set permissions\n    File.chmod(0644, filepath)\n    \n    # Process image to remove any embedded code\n    process_image(filepath) if defined?(MiniMagick)\n    \n    unique_filename\n  end\n  \n  def process_image(filepath)\n    image = MiniMagick::Image.open(filepath)\n    image.strip # Remove all profiles and comments\n    image.write(filepath)\n  end\nend\n\n# Controller\nclass UploadsController < ApplicationController\n  def create\n    service = FileUploadService.new(params[:file])\n    filename = service.upload\n    render json: { message: 'File uploaded successfully', filename: filename }\n  rescue => e\n    render json: { error: e.message }, status: :unprocessable_entity\n  end\nend\n\n# Active Storage configuration (alternative)\nclass User < ApplicationRecord\n  has_one_attached :avatar\n  \n  validate :acceptable_image\n  \n  private\n  \n  def acceptable_image\n    return unless avatar.attached?\n    \n    unless avatar.blob.byte_size <= 5.megabytes\n      errors.add(:avatar, 'is too big')\n    end\n    \n    acceptable_types = ['image/jpeg', 'image/png', 'image/gif']\n    unless acceptable_types.include?(avatar.blob.content_type)\n      errors.add(:avatar, 'must be a JPEG, PNG, or GIF')\n    end\n  end\nend"
      ],
      "fix_explanation": "Validate all aspects, use secure storage, process images to remove embedded code"
    },
    {
      "language": "csharp",
      "bad_code": [
        "// No validation\n[HttpPost]\npublic IActionResult Upload(IFormFile file)\n{\n    var path = Path.Combine(\"wwwroot/uploads\", file.FileName);\n    using (var stream = new FileStream(path, FileMode.Create))\n    {\n        file.CopyTo(stream);\n    }\n    return Ok();\n}",
        "// Extension only\nif (Path.GetExtension(file.FileName) == \".jpg\")\n{\n    // Save file\n}",
        "// No size limit\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.Configure<FormOptions>(options =>\n    {\n        // No limits set\n    });\n}"
      ],
      "risk_description": "Missing validation allows uploading ASPX shells and executables",
      "good_code": [
        "// Complete validation\npublic class FileUploadService\n{\n    private readonly string[] _allowedExtensions = { \".jpg\", \".jpeg\", \".png\", \".gif\" };\n    private readonly string[] _allowedMimeTypes = { \"image/jpeg\", \"image/png\", \"image/gif\" };\n    private readonly long _maxFileSize = 5 * 1024 * 1024; // 5MB\n    private readonly string _uploadPath = \"/var/uploads\"; // Outside wwwroot\n    \n    public async Task<string> UploadFileAsync(IFormFile file)\n    {\n        // Validate file presence\n        if (file == null || file.Length == 0)\n            throw new ArgumentException(\"No file provided\");\n        \n        // Validate file size\n        if (file.Length > _maxFileSize)\n            throw new ArgumentException(\"File too large\");\n        \n        // Validate extension\n        var extension = Path.GetExtension(file.FileName).ToLowerInvariant();\n        if (!_allowedExtensions.Contains(extension))\n            throw new ArgumentException(\"Invalid file type\");\n        \n        // Validate MIME type\n        if (!_allowedMimeTypes.Contains(file.ContentType.ToLower()))\n            throw new ArgumentException(\"Invalid content type\");\n        \n        // Generate unique filename\n        var uniqueFileName = $\"{Guid.NewGuid()}{extension}\";\n        var filePath = Path.Combine(_uploadPath, uniqueFileName);\n        \n        // Ensure directory exists\n        Directory.CreateDirectory(_uploadPath);\n        \n        // Save file\n        using (var stream = new FileStream(filePath, FileMode.Create))\n        {\n            await file.CopyToAsync(stream);\n        }\n        \n        // Validate actual content\n        if (!await ValidateFileContent(filePath))\n        {\n            File.Delete(filePath);\n            throw new ArgumentException(\"File content validation failed\");\n        }\n        \n        // Set file permissions (Windows)\n        var fileInfo = new FileInfo(filePath);\n        var security = fileInfo.GetAccessControl();\n        security.AddAccessRule(new FileSystemAccessRule(\n            \"IIS_IUSRS\",\n            FileSystemRights.Read,\n            AccessControlType.Allow));\n        fileInfo.SetAccessControl(security);\n        \n        return uniqueFileName;\n    }\n    \n    private async Task<bool> ValidateFileContent(string filePath)\n    {\n        try\n        {\n            using (var image = await Image.LoadAsync(filePath))\n            {\n                // Image loaded successfully, it's a valid image\n                // Optionally re-save to remove any embedded code\n                await image.SaveAsync(filePath);\n                return true;\n            }\n        }\n        catch\n        {\n            return false;\n        }\n    }\n}\n\n// Controller\n[HttpPost]\n[RequestSizeLimit(5_242_880)] // 5MB\npublic async Task<IActionResult> Upload(IFormFile file)\n{\n    try\n    {\n        var uploadService = new FileUploadService();\n        var filename = await uploadService.UploadFileAsync(file);\n        return Ok(new { message = \"File uploaded successfully\", filename });\n    }\n    catch (ArgumentException ex)\n    {\n        return BadRequest(new { error = ex.Message });\n    }\n    catch (Exception)\n    {\n        return StatusCode(500, new { error = \"Upload failed\" });\n    }\n}\n\n// Startup configuration\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.Configure<FormOptions>(options =>\n    {\n        options.ValueLengthLimit = int.MaxValue;\n        options.MultipartBodyLengthLimit = 5_242_880; // 5MB\n        options.MultipartHeadersLengthLimit = int.MaxValue;\n    });\n    \n    services.Configure<IISServerOptions>(options =>\n    {\n        options.MaxRequestBodySize = 5_242_880; // 5MB\n    });\n}"
      ],
      "fix_explanation": "Complete validation, secure storage, content verification, proper permissions"
    }
  ],

  "detection_rules": {
    "ast_patterns": [
      "File upload without extension validation",
      "File save with user-controlled filename",
      "Missing file size checks",
      "Upload to web-accessible directories",
      "Missing content-type validation",
      "No file content verification"
    ],
    "regex_patterns": [
      "move_uploaded_file\\s*\\([^,]+,\\s*[^)]*\\$_FILES",
      "file\\.save\\s*\\([^)]*file\\.filename",
      "transferTo\\s*\\([^)]*getOriginalFilename",
      "multer\\s*\\(\\s*\\{\\s*dest:",
      "File\\.open\\s*\\([^)]*original_filename"
    ],
    "code_smell_indicators": [
      "Direct use of uploaded filename",
      "Uploads to public/wwwroot directories",
      "Extension-only validation",
      "Client-side MIME type trust",
      "Missing file size limits",
      "Executable file permissions"
    ]
  },

  "remediation": {
    "steps": [
      "Validate file extensions against whitelist",
      "Check file size limits",
      "Verify MIME types server-side",
      "Validate actual file content using magic numbers",
      "Generate unique filenames (UUID/hash)",
      "Store uploads outside web root",
      "Set non-executable permissions",
      "Re-encode/process images to remove embedded code",
      "Implement virus scanning for uploads",
      "Use Content-Disposition header for downloads",
      "Add upload rate limiting per user"
    ],
    "code_examples": [
      {
        "framework": "General Best Practices",
        "safe_code": "1. Store files outside document root\n2. Use .htaccess to prevent execution:\n   Options -Indexes\n   Options -ExecCGI\n   AddHandler cgi-script .php .pl .py .jsp .asp .sh .cgi\n3. Serve files through application layer with proper headers:\n   Content-Type: application/octet-stream\n   Content-Disposition: attachment; filename=\"file.jpg\"\n   X-Content-Type-Options: nosniff"
      }
    ],
    "prevention_guidelines": [
      "Implement defense in depth for file uploads",
      "Never trust user-provided filenames",
      "Always validate content, not just metadata",
      "Use dedicated file storage services (S3, Azure Blob)",
      "Implement file type allowlists, not denylists",
      "Regular security testing of upload functionality",
      "Monitor uploaded files for suspicious content",
      "Implement proper logging and alerting"
    ]
  },

  "impact": {
    "severity_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "business_impact": "Remote code execution, server compromise, data breach, malware distribution",
    "technical_impact": "Web shell upload, server takeover, lateral movement, persistent access",
    "confidentiality": "high",
    "integrity": "high",
    "availability": "high",
    "compliance_violations": ["PCI-DSS", "GDPR", "HIPAA"]
  },

  "references": [
    "https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload",
    "https://cwe.mitre.org/data/definitions/434.html",
    "https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html",
    "https://portswigger.net/web-security/file-upload",
    "https://www.acunetix.com/websitesecurity/upload-forms-threat/"
  ],

  "test_cases": [
    {
      "input": "shell.php",
      "description": "PHP web shell upload attempt",
      "expected_detection": true,
      "attack_type": "web_shell"
    },
    {
      "input": "image.jpg.php",
      "description": "Double extension bypass attempt",
      "expected_detection": true,
      "attack_type": "extension_bypass"
    },
    {
      "input": "large_file_10mb.jpg",
      "description": "File size limit bypass",
      "expected_detection": true,
      "attack_type": "size_bypass"
    },
    {
      "input": "fake_image_with_php_code.jpg",
      "description": "Embedded code in image",
      "expected_detection": true,
      "attack_type": "content_bypass"
    }
  ],

  "metadata": {
    "last_updated": "2025-01-10",
    "version": "1.0.0",
    "tags": ["file-upload", "web-shell", "rce", "high"],
    "related_patterns": ["cwe_434_unrestricted_upload", "cwe_646_embedded_code"]
  }
}