{
  "name": "Elixir Production Quality Template",
  "spec_version": "2.1",
  "capabilities": [
    "quality",
    "graph",
    "rag",
    "otp",
    "performance",
    "security",
    "observability",
    "testing",
    "resilience",
    "self_evolving",
    "business_logic",
    "ai_assisted"
  ],
  "language": "elixir",
  "quality_level": "production",
  "description": "Elixir production quality standards for robust, maintainable, and scalable applications.",
  "extends": [],
  "version": "2.1.0",
  "last_updated": "2025-01-27",
  "requirements": {
    "documentation": {
      "moduledoc": {
        "required": true,
        "min_length": 100,
        "must_include": [
          "overview",
          "public_api_contract",
          "error_matrix",
          "examples",
          "performance_notes",
          "concurrency_semantics",
          "relationship_metadata",
          "template_version"
        ]
      },
      "doc": {
        "required_for": [
          "all_public_functions"
        ],
        "min_length": 50,
        "must_include": [
          "description",
          "parameters",
          "returns",
          "errors",
          "examples"
        ]
      },
      "inline_comments": {
        "required_for": [
          "complex_pattern_matching",
          "non_trivial_recursion",
          "performance_critical_sections",
          "security_sensitive_code"
        ],
        "style": "concise"
      },
      "structured_sections": [
        {
          "id": "overview",
          "required": true,
          "min_length": 60,
          "purpose": "High-level what/why in first 2 sentences",
          "must_answer": [
            "What does this module represent?",
            "Why does it exist vs alternatives?",
            "What are the key capabilities?"
          ]
        },
        {
          "id": "public_api_contract",
          "required": true,
          "min_length": 80,
          "purpose": "List of stable public functions with concise contract lines",
          "format": "function_name(args) :: return_type -- short purpose"
        },
        {
          "id": "error_matrix",
          "required": true,
          "min_length": 60,
          "purpose": "Enumerate all {:error, reason} atoms with meaning",
          "format": "reason_atom | scenario description"
        },
        {
          "id": "performance_notes",
          "required": true,
          "min_length": 40,
          "purpose": "Big-O complexity, memory usage, and performance characteristics"
        },
        {
          "id": "concurrency_semantics",
          "required": true,
          "min_length": 40,
          "purpose": "Thread/process safety, GenServer serialization boundaries, shared state"
        },
        {
          "id": "security_considerations",
          "required": true,
          "min_length": 30,
          "purpose": "Input validation, sanitization, privilege requirements"
        },
        {
          "id": "examples",
          "required": true,
          "min_examples": 3,
          "purpose": "Executable iex examples covering success + error paths + edge cases"
        },
        {
          "id": "relationship_metadata",
          "required": true,
          "min_length": 40,
          "purpose": "Document module relationships, dependencies, and integration points",
          "format": "## Relationships\n- **Calls:** module.function/arity - purpose\n- **Called by:** module.function/arity - purpose\n- **Depends on:** module - purpose\n- **Used by:** module - purpose\n- **Integrates with:** service/component - purpose"
        },
        {
          "id": "template_version",
          "required": true,
          "min_length": 20,
          "purpose": "Document template version and upgrade path",
          "format": "## Template Version\n- **Applied:** template_name vX.Y.Z\n- **Applied on:** YYYY-MM-DD\n- **Upgrade path:** template_name vX.Y.Z -> vX.Y+1.Z"
        }
      ]
    },
    "type_specs": {
      "required": true,
      "required_for": [
        "all_functions"
      ],
      "dialyzer": "required",
      "custom_types": "required",
      "opaque_types": "required_for_internal_data_structures"
    },
    "error_handling": {
      "style": "tagged_tuples",
      "required_pattern": "{:ok, value} | {:error, reason}",
      "no_raise_for_flow": true,
      "allowed_raise": [
        "startup_failures",
        "irrecoverable_invariants",
        "programming_errors"
      ],
      "define_error_atoms": true,
      "error_context": "Include context in error tuples when helpful"
    },
    "otp_patterns": {
      "genserver": {
        "required_callbacks": [
          "init/1",
          "handle_call/3",
          "handle_cast/2",
          "handle_info/2"
        ],
        "error_handling": "Always return {:ok, state} or {:stop, reason, state}",
        "state_validation": "Validate state transitions",
        "terminate_cleanup": "Implement terminate/2 for resource cleanup",
        "hot_code_swapping": "Implement code_change/3 for hot upgrades"
      },
      "supervisor": {
        "strategies": [
          "one_for_one",
          "one_for_all",
          "rest_for_one"
        ],
        "restart_policies": "Define appropriate restart policies",
        "child_specs": "Use proper child_spec/1 functions",
        "hot_upgrades": "Support hot upgrades of supervised processes"
      },
      "behaviours": {
        "callback_docs": "Document all callbacks with @callback",
        "test_implementations": "Provide test implementations",
        "version_handling": "Handle behaviour version changes"
      },
      "applications": {
        "startup_validation": "Validate configuration in start/2",
        "graceful_shutdown": "Implement proper shutdown sequence",
        "hot_upgrades": "Support application hot upgrades"
      },
      "distribution": {
        "node_discovery": "Use :net_kernel for node discovery",
        "global_registry": "Use :global for distributed process registry",
        "partition_handling": "Handle network partitions gracefully",
        "split_brain_prevention": "Prevent split-brain scenarios"
      },
      "process_monitoring": {
        "crash_handling": "Handle monitored process crashes",
        "health_checks": "Implement process health monitoring",
        "restart_strategies": "Define process restart strategies"
      }
    },
    "performance": {
      "caching": {
        "ets_usage": "Use ETS for fast in-memory lookups",
        "gen_server_state": "Cache expensive computations in GenServer state",
        "cache_invalidation": "Implement proper cache invalidation strategies",
        "ets_lifecycle": "Manage ETS table creation and cleanup"
      },
      "nif_usage": {
        "requirements": [
          "NIF execution under 1ms",
          "Use dirty schedulers for longer operations"
        ],
        "error_handling": "Handle NIF failures gracefully"
      },
      "memory_management": {
        "streams": "Use streams for large datasets",
        "binary_optimization": "Avoid keeping large binaries in process state",
        "garbage_collection": "Consider GC impact of data structures",
        "memory_pressure": "Handle memory pressure gracefully",
        "gc_tuning": "Tune garbage collection for your workload"
      },
      "concurrency": {
        "task_usage": "Use Task.async for CPU-bound work",
        "scheduler_limits": "Don't saturate schedulers",
        "timeout_control": "Implement proper timeouts"
      }
    },
    "hot_code_swapping": {
      "code_change": {
        "required": true,
        "description": "Implement code_change/3 for hot upgrades",
        "state_migration": "Handle state schema changes",
        "version_handling": "Support multiple version transitions",
        "rollback_support": "Support rollback scenarios"
      },
      "application_upgrades": {
        "upgrade_scripts": "Create upgrade scripts for schema changes",
        "downgrade_support": "Support application downgrades",
        "data_migration": "Handle data migrations during upgrades"
      },
      "process_upgrades": {
        "state_transformation": "Transform process state during upgrades",
        "callback_updates": "Handle callback signature changes",
        "backward_compatibility": "Maintain backward compatibility"
      }
    },
    "security": {
      "input_validation": {
        "type_checking": "Validate all external inputs",
        "range_validation": "Check numeric ranges",
        "format_validation": "Validate string formats",
        "size_limits": "Enforce size limits on inputs"
      },
      "sanitization": {
        "html_escaping": "Escape HTML in user content",
        "sql_injection": "Use parameterized queries",
        "xss_protection": "Prevent cross-site scripting"
      },
      "rate_limiting": {
        "api_endpoints": "Implement rate limiting for external APIs",
        "user_actions": "Rate limit user-initiated actions",
        "circuit_breakers": "Use circuit breakers for external services"
      },
      "privilege_separation": {
        "minimal_privileges": "Use minimal required privileges",
        "privilege_escalation": "Avoid unnecessary privilege escalation"
      }
    },
    "observability": {
      "telemetry": {
        "required_events": [
          "function_call",
          "function_duration",
          "error_occurred",
          "cache_hit",
          "cache_miss"
        ],
        "structured_data": "Include structured data in telemetry events",
        "event_naming": "Use consistent event naming conventions"
      },
      "structured_logging": {
        "context": "Include relevant context in log messages",
        "log_levels": "Use appropriate log levels",
        "correlation_ids": "Include correlation IDs for tracing",
        "ericsson_style": "Use Ericsson-style structured logging patterns"
      },
      "slo_monitoring": {
        "availability": "Track service availability (99.9%, 99.99%)",
        "latency": "Track P50, P95, P99 latency percentiles",
        "error_rate": "Track error rate thresholds",
        "throughput": "Track requests per second",
        "sla_breach": "Alert on SLA breaches"
      },
      "health_checks": {
        "liveness": "Implement liveness probes",
        "readiness": "Implement readiness probes",
        "dependency_checks": "Check external dependencies"
      },
      "metrics": {
        "counter_metrics": "Track counts of operations",
        "histogram_metrics": "Track operation durations",
        "gauge_metrics": "Track current values",
        "slo_metrics": "Track SLO compliance metrics"
      }
    },
    "testing": {
      "required": true,
      "coverage_target": 95,
      "must_test": [
        "public_api",
        "error_paths",
        "edge_cases",
        "boundary_conditions",
        "concurrency_scenarios"
      ],
      "types": [
        "unit",
        "integration",
        "property_based",
        "performance",
        "load"
      ],
      "async_default": true,
      "test_organization": {
        "describe_blocks": "Use describe blocks for logical grouping",
        "setup_teardown": "Proper setup and teardown",
        "test_isolation": "Ensure tests don't interfere with each other"
      }
    },
    "configuration": {
      "application_config": {
        "environment_specific": "Use Application config for environment-specific settings",
        "validation": "Validate configuration at startup",
        "documentation": "Document all configuration options"
      },
      "runtime_config": {
        "dynamic_settings": "Use runtime configuration for dynamic settings",
        "hot_reloading": "Support hot reloading when possible"
      },
      "environment_variables": {
        "documentation": "Document required environment variables",
        "validation": "Validate environment variables at startup",
        "defaults": "Provide sensible defaults"
      }
    },
    "resilience": {
      "circuit_breaker": {
        "external_services": "Implement circuit breakers for external dependencies",
        "failure_thresholds": "Define appropriate failure thresholds",
        "recovery_time": "Implement exponential backoff"
      },
      "retry_logic": {
        "exponential_backoff": "Use exponential backoff for retries",
        "max_attempts": "Define maximum retry attempts",
        "jitter": "Add jitter to prevent thundering herd"
      },
      "graceful_degradation": {
        "fallback_behavior": "Provide fallback behavior when services unavailable",
        "feature_flags": "Use feature flags for gradual rollouts",
        "caching": "Use caching to improve resilience"
      },
      "timeout_handling": {
        "operation_timeouts": "Set appropriate timeouts for operations",
        "cascade_timeouts": "Prevent timeout cascades",
        "timeout_recovery": "Implement timeout recovery strategies"
      }
    },
    "code_style": {
      "naming": "snake_case",
      "module_naming": "PascalCase",
      "max_function_lines": 25,
      "max_module_lines": 400,
      "max_line_length": 120,
      "prefer_pattern_matching": true,
      "prefer_guard_clauses": true,
      "pipe_operator": "encouraged_small_transform_chains",
      "avoid_nested_with": true,
      "function_arity": "prefer_fewer_parameters"
    },
    "code_smells": {
      "forbidden": [
        "TODO",
        "FIXME",
        "HACK",
        "XXX"
      ],
      "warn": [
        "deep_nesting",
        "long_functions",
        "god_modules",
        "duplicate_code",
        "magic_numbers"
      ],
      "long_function_threshold": 25,
      "max_nesting_depth": 3
    },
    "design_principles": {
      "single_responsibility": true,
      "explicit_boundaries": true,
      "prefer_composition_over_inheritance": true,
      "pure_functions_for_business_logic": true,
      "immutable_data_structures": true,
      "explicit_dependencies": true
    },
    "complexity": {
      "max_decision_points": 8,
      "refactor_if_exceeds": true,
      "cyclomatic_complexity": "track_and_limit"
    },
    "relationship_annotations": {
      "required": true,
      "patterns": {
        "calls": "# @calls: module.function/arity - purpose",
        "called_by": "# @called_by: module.function/arity - purpose",
        "depends_on": "# @depends_on: module - purpose",
        "used_by": "# @used_by: module - purpose",
        "integrates_with": "# @integrates_with: service/component - purpose",
        "error_flow": "# @error_flow: error_atom -> description",
        "telemetry": "# @telemetry: event_name - purpose",
        "slo": "# @slo: operation -> threshold_ms",
        "evolves": "# @evolves: module::function - Auto-upgrades based on usage patterns",
        "learns": "# @learns: pattern::type - Learns from successful patterns",
        "adapts": "# @adapts: environment::change - Adapts to environment changes",
        "business_rule": "# @business_rule: rule_name::policy - Maps to business rule",
        "compliance": "# @compliance: standard::required - Compliance requirement",
        "audit_trail": "# @audit_trail: required::true - Audit trail required",
        "ai_generated": "# @ai_generated: pattern::type - AI-generated code with confidence score",
        "ai_validated": "# @ai_validated: human::review - Human-validated AI code",
        "ai_learned": "# @ai_learned: usage::pattern - Learned from usage patterns"
      },
      "placement": "before_function_definition"
    },
    "template_versioning": {
      "required": true,
      "format": {
        "header_comment": "# Template: template_name vX.Y.Z | Applied: YYYY-MM-DD | Upgrade: vX.Y.Z -> vX.Y+1.Z",
        "module_attribute": "@template_version \"template_name vX.Y.Z\"",
        "upgrade_tracking": "Track template upgrades in module documentation"
      },
      "upgrade_detection": "Compare @template_version with latest template version"
    }
  },
  "patterns": {
    "genserver_basic": {
      "intent": "Stateful process abstraction with message handling",
      "pseudocode": "use GenServer -> init(state) -> handle_call/handle_cast -> state transitions",
      "when_to_use": [
        "stateful_logic",
        "infrequent_mutation",
        "coordination",
        "caching"
      ],
      "avoid_if": [
        "pure_stateless_transform"
      ],
      "quality_checks": [
        "terminate/2 only if needed",
        "don't leak PIDs",
        "reply consistency",
        "state validation"
      ]
    },
    "supervision_tree": {
      "intent": "Fault tolerance via hierarchical supervision",
      "pseudocode": "Supervisor.start_link(children, strategy: :one_for_one)",
      "strategies": [
        "one_for_one",
        "rest_for_one",
        "one_for_all"
      ],
      "requirements": [
        "keep children small",
        "restart only what's needed",
        "proper child specs"
      ]
    },
    "circuit_breaker": {
      "intent": "Prevent cascading failures in external service calls",
      "pseudocode": "CircuitBreaker.call(fn -> external_call() end)",
      "when_to_use": [
        "external_api_calls",
        "database_queries",
        "network_operations"
      ],
      "configuration": [
        "failure_threshold",
        "recovery_timeout",
        "half_open_max_calls"
      ]
    },
    "retry_with_backoff": {
      "intent": "Retry failed operations with exponential backoff",
      "pseudocode": "retry_with_backoff(fun, max_attempts, base_delay)",
      "when_to_use": [
        "transient_failures",
        "network_timeouts",
        "rate_limited_requests"
      ],
      "configuration": [
        "max_attempts",
        "base_delay",
        "max_delay",
        "jitter"
      ]
    },
    "cache_with_ttl": {
      "intent": "Cache expensive computations with time-to-live",
      "pseudocode": "Cache.get_or_store(key, ttl, fun)",
      "when_to_use": [
        "expensive_computations",
        "external_api_calls",
        "database_queries"
      ],
      "considerations": [
        "memory_usage",
        "cache_invalidation",
        "cache_warming"
      ]
    },
    "rate_limiter": {
      "intent": "Limit the rate of operations to prevent abuse",
      "pseudocode": "RateLimiter.check_rate(user_id, window, limit)",
      "when_to_use": [
        "api_endpoints",
        "user_actions",
        "resource_intensive_operations"
      ],
      "algorithms": [
        "token_bucket",
        "sliding_window",
        "fixed_window"
      ]
    },
    "health_check": {
      "intent": "Monitor system health and dependencies",
      "pseudocode": "HealthCheck.check_dependencies()",
      "when_to_use": [
        "service_monitoring",
        "dependency_checks",
        "deployment_validation"
      ],
      "types": [
        "liveness",
        "readiness",
        "startup"
      ]
    },
    "telemetry_instrumentation": {
      "intent": "Instrument code for observability and monitoring",
      "pseudocode": ":telemetry.execute([:module, :function, :start], metadata)",
      "when_to_use": [
        "performance_monitoring",
        "error_tracking",
        "business_metrics"
      ],
      "events": [
        "start",
        "stop",
        "exception",
        "span"
      ]
    },
    "hot_code_swapping": {
      "intent": "Enable zero-downtime code updates",
      "pseudocode": "@impl GenServer\ndef code_change(old_vsn, state, extra) do\n  # Handle state migration\n  {:ok, migrate_state(old_vsn, state)}\nend",
      "when_to_use": [
        "production_systems",
        "self_evolving_systems",
        "continuous_deployment"
      ],
      "considerations": [
        "state_schema_changes",
        "callback_signature_changes",
        "backward_compatibility"
      ]
    },
    "process_monitoring": {
      "intent": "Monitor and handle process crashes gracefully",
      "pseudocode": "def handle_info({:DOWN, ref, :process, pid, reason}, state) do\n  # Handle monitored process crashes\n  {:noreply, state}\nend",
      "when_to_use": [
        "critical_processes",
        "external_dependencies",
        "fault_tolerant_systems"
      ],
      "patterns": [
        "monitor_external_services",
        "restart_on_crash",
        "circuit_breaker"
      ]
    },
    "ets_lifecycle_management": {
      "intent": "Manage ETS tables with proper lifecycle",
      "pseudocode": "def init(_opts) do\n  :ets.new(:cache, [:set, :public, :named_table])\n  {:ok, %{cache: :cache}}\nend\ndef terminate(_reason, state) do\n  :ets.delete(state.cache)\n  :ok\nend",
      "when_to_use": [
        "high_performance_caching",
        "shared_state",
        "lookup_tables"
      ],
      "lifecycle": [
        "creation",
        "cleanup",
        "migration"
      ]
    },
    "memory_pressure_handling": {
      "intent": "Handle memory pressure and optimize GC",
      "pseudocode": "def handle_info(:gc, state) do\n  :erlang.garbage_collect(self())\n  schedule_gc()\n  {:noreply, state}\nend",
      "when_to_use": [
        "memory_intensive_applications",
        "long_running_processes",
        "performance_critical_systems"
      ],
      "strategies": [
        "periodic_gc",
        "memory_monitoring",
        "gc_tuning"
      ]
    },
    "distribution_patterns": {
      "intent": "Handle distributed systems and clustering",
      "pseudocode": "def start_link(opts) do\n  GenServer.start_link(__MODULE__, opts, name: {:via, :gproc, {:n, :l, :service}})\nend",
      "when_to_use": [
        "distributed_systems",
        "clustering",
        "fault_tolerance"
      ],
      "patterns": [
        "node_discovery",
        "global_registry",
        "partition_handling"
      ]
    },
    "ericsson_structured_logging": {
      "intent": "Ericsson-style structured logging with SLO monitoring",
      "pseudocode": "Logger.info(\"Operation completed\", %{operation: :create_user, user_id: user_id, duration_ms: duration, slo_status: :within_sla})",
      "when_to_use": [
        "production_systems",
        "slo_monitoring",
        "distributed_tracing"
      ],
      "patterns": [
        "structured_metadata",
        "slo_compliance",
        "correlation_tracking",
        "performance_metrics"
      ]
    },
    "slo_monitoring": {
      "intent": "Monitor Service Level Objectives and SLA compliance",
      "pseudocode": "def track_slo_metric(operation, duration, success) do\n  :telemetry.execute([:slo, :operation, :complete], %{operation: operation, duration: duration, success: success})\nend",
      "when_to_use": [
        "production_services",
        "sla_compliance",
        "performance_monitoring"
      ],
      "metrics": [
        "availability_percentage",
        "latency_percentiles",
        "error_rate",
        "throughput"
      ]
    },
    "self_evolving_system": {
      "intent": "Enable self-evolving system capabilities with automatic adaptation",
      "pseudocode": "# @evolves: module::function - Auto-upgrades based on usage patterns\n# @learns: pattern::type - Learns from successful patterns\n# @adapts: environment::change - Adapts to environment changes\ndef evolve_based_on_usage(operation, success_rate, performance_metrics) do\n  if success_rate > 0.95 and performance_metrics.avg_latency < threshold do\n    :telemetry.execute([:evolution, :pattern_learned], %{operation: operation, pattern: :successful})\n    adapt_behavior(operation, :optimize)\n  end\nend",
      "when_to_use": [
        "self_evolving_systems",
        "adaptive_behavior",
        "machine_learning_integration",
        "performance_optimization"
      ],
      "patterns": [
        "usage_pattern_learning",
        "automatic_optimization",
        "environment_adaptation",
        "success_pattern_recognition"
      ]
    },
    "business_logic_mapping": {
      "intent": "Map code to business rules and compliance requirements",
      "pseudocode": "# @business_rule: user_creation::policy - Maps to business rule\n# @compliance: sox::required - SOX compliance required\n# @audit_trail: required::true - Audit trail required\ndef create_user_with_business_rules(user_data) do\n  :telemetry.execute([:business_rule, :user_creation, :start], %{policy: :user_creation_policy})\n  \n  with :ok <- validate_business_rules(user_data),\n       :ok <- check_compliance_requirements(:sox),\n       {:ok, user} <- create_user(user_data) do\n    \n    audit_trail(:user_created, user.id, user_data)\n    {:ok, user}\n  end\nend",
      "when_to_use": [
        "enterprise_systems",
        "compliance_requirements",
        "audit_trail_needs",
        "business_rule_validation"
      ],
      "patterns": [
        "business_rule_mapping",
        "compliance_tracking",
        "audit_trail_generation",
        "policy_validation"
      ]
    },
    "ai_assisted_patterns": {
      "intent": "Integrate AI-assisted code generation and validation",
      "pseudocode": "# @ai_generated: pattern::type - AI-generated code with confidence score\n# @ai_validated: human::review - Human-validated AI code\n# @ai_learned: usage::pattern - Learned from usage patterns\ndef ai_generate_function(description, context) do\n  case AI.CodeGenerator.generate(description, context) do\n    {:ok, code, confidence} when confidence > 0.8 ->\n      :telemetry.execute([:ai, :code_generated, :high_confidence], %{confidence: confidence})\n      {:ok, code}\n    \n    {:ok, code, confidence} when confidence > 0.6 ->\n      :telemetry.execute([:ai, :code_generated, :medium_confidence], %{confidence: confidence})\n      {:ok, code, :requires_review}\n    \n    {:error, reason} ->\n      :telemetry.execute([:ai, :code_generated, :failed], %{reason: reason})\n      {:error, reason}\n  end\nend",
      "when_to_use": [
        "ai_integrated_systems",
        "code_generation_automation",
        "pattern_learning",
        "intelligent_optimization"
      ],
      "patterns": [
        "ai_code_generation",
        "confidence_scoring",
        "human_validation_workflow",
        "usage_pattern_learning"
      ]
    }
  },
  "anti_patterns": {
    "long_function": {
      "symptom": "> 25 lines",
      "why_bad": "Hard to reason about, violates single responsibility",
      "fix": "Extract pure helper functions"
    },
    "process_mailbox_leak": {
      "symptom": "receive loops without timeouts or selective patterns",
      "why_bad": "Unbounded mailbox growth",
      "fix": "Use GenServer or add timeout + pattern narrowing"
    },
    "raise_for_control_flow": {
      "symptom": "Using raise to signal expected domain failures",
      "why_bad": "Breaks tagged tuple conventions",
      "fix": "Return {:error, reason}"
    },
    "global_state_via_module_attribute": {
      "symptom": "@state mutated at compile then treated as runtime",
      "why_bad": "Unexpected immutability / stale values",
      "fix": "Use proper process or configuration"
    },
    "generic_names": {
      "symptom": "Modules named Util/Helper/Misc",
      "why_bad": "Non-descriptive, hinders discoverability",
      "fix": "Rename to domain-specific responsibility"
    },
    "unbounded_task_spawning": {
      "symptom": "Creating tasks without limits or supervision",
      "why_bad": "Can exhaust system resources",
      "fix": "Use Task.Supervisor or limit concurrency"
    },
    "missing_error_handling": {
      "symptom": "Functions that can fail but don't handle errors",
      "why_bad": "Crashes propagate to callers",
      "fix": "Handle all possible error cases"
    },
    "hardcoded_configuration": {
      "symptom": "Configuration values hardcoded in source",
      "why_bad": "Not environment-specific, hard to change",
      "fix": "Use Application config or environment variables"
    }
  },
  "quality_gates": {
    "dialyzer": {
      "required": true,
      "warnings": "none_allowed",
      "typespecs": "required"
    },
    "credo": {
      "required": true,
      "strict_mode": true,
      "warnings": "none_allowed"
    },
    "test_coverage": {
      "minimum": 95,
      "required": true
    },
    "documentation_coverage": {
      "minimum": 90,
      "required": true
    },
    "compilation_warnings": {
      "allowed": 0,
      "required": true
    }
  },
  "examples": {
    "good_code": "defmodule UserService do\n  @moduledoc \"\"\"\n  User management service with caching and validation.\n  \n  ## Public API Contract\n  - create_user(user_data) :: {:ok, User.t()} | {:error, reason()}\n  - get_user(id) :: {:ok, User.t()} | {:error, :not_found}\n  - update_user(id, changes) :: {:ok, User.t()} | {:error, reason()}\n  \n  ## Error Matrix\n  :invalid_data | User data validation failed\n  :not_found | User with given ID not found\n  :database_error | Database operation failed\n  :rate_limited | Too many requests\n  \n  ## Performance Notes\n  - User lookups are cached for 5 minutes\n  - Database queries use connection pooling\n  - Rate limiting: 100 requests/minute per user\n  \n  ## Concurrency Semantics\n  - GenServer serializes all operations\n  - Cache is process-local and thread-safe\n  - Database operations are connection-pooled\n  \n  ## Security Considerations\n  - All inputs validated and sanitized\n  - Password hashing uses bcrypt\n  - Rate limiting prevents abuse\n  \n  ## Examples\n      iex> UserService.create_user(%{name: \"John\", email: \"john@example.com\"})\n      {:ok, %User{id: 1, name: \"John\", email: \"john@example.com\"}}\n      \n      iex> UserService.get_user(999)\n      {:error, :not_found}\n      \n      iex> UserService.create_user(%{name: \"\"})\n      {:error, :invalid_data}\n  \"\"\"\n  \n  use GenServer\n  require Logger\n  \n  @cache_ttl 300_000  # 5 minutes\n  @rate_limit 100\n  @rate_window 60_000  # 1 minute\n  \n  @type user_data :: %{name: String.t(), email: String.t()}\n  @type user_id :: pos_integer()\n  @type reason :: :invalid_data | :not_found | :database_error | :rate_limited\n  \n  @spec start_link(keyword()) :: GenServer.on_start()\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n  \n  @spec create_user(user_data()) :: {:ok, User.t()} | {:error, reason()}\n  def create_user(user_data) do\n    GenServer.call(__MODULE__, {:create_user, user_data})\n  end\n  \n  @spec get_user(user_id()) :: {:ok, User.t()} | {:error, :not_found}\n  def get_user(id) do\n    GenServer.call(__MODULE__, {:get_user, id})\n  end\n  \n  @spec update_user(user_id(), map()) :: {:ok, User.t()} | {:error, reason()}\n  def update_user(id, changes) do\n    GenServer.call(__MODULE__, {:update_user, id, changes})\n  end\n  \n  # GenServer callbacks\n  \n  @impl GenServer\n  def init(_opts) do\n    :telemetry.execute([:user_service, :init, :start], %{})\n    \n    state = %{\n      cache: %{},\n      rate_limiter: RateLimiter.new(@rate_limit, @rate_window)\n    }\n    \n    :telemetry.execute([:user_service, :init, :stop], %{})\n    {:ok, state}\n  end\n  \n  @impl GenServer\n  def handle_call({:create_user, user_data}, from, state) do\n    start_time = System.monotonic_time(:millisecond)\n    correlation_id = generate_correlation_id()\n    \n    Logger.info(\"User creation started\", %{\n      operation: :create_user,\n      correlation_id: correlation_id,\n      user_email: user_data.email,\n      slo_target_ms: 1000\n    })\n    \n    :telemetry.execute([:user_service, :create_user, :start], %{\n      user_data: user_data,\n      correlation_id: correlation_id\n    })\n    \n    with {:ok, validated_data} <- validate_user_data(user_data),\n         {:ok, user} <- create_user_in_db(validated_data) do\n      \n      duration = System.monotonic_time(:millisecond) - start_time\n      slo_status = if duration <= 1000, do: :within_sla, else: :sla_breach\n      \n      Logger.info(\"User creation completed\", %{\n        operation: :create_user,\n        correlation_id: correlation_id,\n        user_id: user.id,\n        duration_ms: duration,\n        slo_status: slo_status,\n        success: true\n      })\n      \n      :telemetry.execute([:user_service, :create_user, :stop], %{\n        user_id: user.id,\n        duration: duration,\n        slo_status: slo_status,\n        correlation_id: correlation_id\n      })\n      \n      # Track SLO metrics\n      track_slo_metric(:create_user, duration, true)\n      \n      {:reply, {:ok, user}, state}\n    else\n      {:error, reason} = error ->\n        duration = System.monotonic_time(:millisecond) - start_time\n        \n        Logger.error(\"User creation failed\", %{\n          operation: :create_user,\n          correlation_id: correlation_id,\n          error_reason: reason,\n          duration_ms: duration,\n          slo_status: :error,\n          success: false\n        })\n        \n        :telemetry.execute([:user_service, :create_user, :exception], %{\n          reason: reason,\n          duration: duration,\n          correlation_id: correlation_id\n        })\n        \n        # Track SLO metrics for error case\n        track_slo_metric(:create_user, duration, false)\n        \n        {:reply, error, state}\n    end\n  end\n  \n  @impl GenServer\n  def handle_call({:get_user, id}, _from, state) do\n    :telemetry.execute([:user_service, :get_user, :start], %{user_id: id})\n    \n    case get_user_from_cache_or_db(id, state) do\n      {:ok, user} = result ->\n        :telemetry.execute([:user_service, :get_user, :stop], %{user_id: id, cache_hit: true})\n        {:reply, result, state}\n      \n      {:error, :not_found} = error ->\n        :telemetry.execute([:user_service, :get_user, :stop], %{user_id: id, cache_hit: false})\n        {:reply, error, state}\n    end\n  end\n  \n  @impl GenServer\n  def code_change(old_vsn, state, extra) do\n    Logger.info(\"UserService code change\", %{old_vsn: old_vsn, extra: extra})\n    \n    # Handle state migration based on version\n    new_state = case old_vsn do\n      :undefined -> state  # Initial load\n      vsn when is_list(vsn) -> migrate_state_from_version(vsn, state)\n      _ -> state  # Unknown version, keep current state\n    end\n    \n    {:ok, new_state}\n  end\n  \n  @impl GenServer\n  def terminate(reason, state) do\n    Logger.info(\"UserService terminating\", %{reason: reason, cache_size: map_size(state.cache)})\n    \n    # Clean up ETS table if it exists\n    if Map.has_key?(state, :ets_table) do\n      :ets.delete(state.ets_table)\n    end\n    \n    :ok\n  end\n  \n  # Private functions\n  \n  defp validate_user_data(data) do\n    with :ok <- validate_required_fields(data),\n         :ok <- validate_email_format(data.email),\n         :ok <- validate_name_length(data.name) do\n      {:ok, data}\n    else\n      {:error, reason} -> {:error, reason}\n    end\n  end\n  \n  defp validate_required_fields(%{name: name, email: email}) when is_binary(name) and is_binary(email) do\n    :ok\n  end\n  defp validate_required_fields(_), do: {:error, :invalid_data}\n  \n  defp validate_email_format(email) do\n    case Regex.run(~r/^[^\\s]+@[^\\s]+\\.[^\\s]+$/, email) do\n      [_] -> :ok\n      nil -> {:error, :invalid_data}\n    end\n  end\n  \n  defp validate_name_length(name) when byte_size(name) in 1..100 do\n    :ok\n  end\n  defp validate_name_length(_), do: {:error, :invalid_data}\n  \n  defp create_user_in_db(user_data) do\n    # Simulate database call with potential failure\n    case :rand.uniform() do\n      n when n < 0.1 -> {:error, :database_error}\n      _ -> {:ok, %User{id: :rand.uniform(1000), name: user_data.name, email: user_data.email}}\n    end\n  end\n  \n  defp get_user_from_cache_or_db(id, %{cache: cache} = state) do\n    case Map.get(cache, id) do\n      {user, timestamp} when System.monotonic_time(:millisecond) - timestamp < @cache_ttl ->\n        {:ok, user}\n      \n      _ ->\n        case get_user_from_db(id) do\n          {:ok, user} = result ->\n            new_cache = Map.put(cache, id, {user, System.monotonic_time(:millisecond)})\n            {:ok, user}\n          \n          error ->\n            error\n        end\n    end\n  end\n  \n  defp get_user_from_db(id) do\n    # Simulate database call\n    case :rand.uniform() do\n      n when n < 0.2 -> {:error, :not_found}\n      _ -> {:ok, %User{id: id, name: \"User #{id}\", email: \"user#{id}@example.com\"}}\n    end\n  end\n  \n  # Hot code swapping support\n  defp migrate_state_from_version(old_vsn, state) do\n    case old_vsn do\n      [1, 0, 0] -> migrate_from_v1_0_0(state)\n      [1, 1, 0] -> migrate_from_v1_1_0(state)\n      _ -> state  # Unknown version, keep current state\n    end\n  end\n  \n  defp migrate_from_v1_0_0(state) do\n    # Example: Add new field to state\n    Map.put(state, :version, \"1.1.0\")\n  end\n  \n  defp migrate_from_v1_1_0(state) do\n    # Example: Transform existing field\n    Map.put(state, :version, \"1.2.0\")\n  end\n  \n  # SLO monitoring and Ericsson-style logging\n  defp generate_correlation_id do\n    :crypto.strong_rand_bytes(16) |> Base.encode64() |> binary_part(0, 22)\n  end\n  \n  defp track_slo_metric(operation, duration, success) do\n    :telemetry.execute([:slo, :operation, :complete], %{\n      operation: operation,\n      duration: duration,\n      success: success,\n      timestamp: System.system_time(:millisecond)\n    })\n  end\n  \n  defp log_slo_breach(operation, duration, threshold) do\n    Logger.warn(\"SLO breach detected\", %{\n      operation: operation,\n      duration_ms: duration,\n      threshold_ms: threshold,\n      breach_percentage: (duration / threshold * 100) |> Float.round(2),\n      severity: :high\n    })\n  end\nend",
    "bad_code": "defmodule UserService do\n  def create_user(data) do\n    # TODO: add validation\n    User.create(data)  # Can raise!\n  end\n  \n  def get_user(id) do\n    User.get(id)  # Returns nil on not found\n  end\n  \n  def update_user(id, changes) do\n    user = User.get(id)\n    user = Map.merge(user, changes)  # Can crash if user is nil\n    User.update(user)\n  end\nend"
  },
  "quality_checklist": [
    "@moduledoc present with all required sections",
    "@doc for every public function with examples",
    "@spec for every function",
    "No raises used for normal domain errors",
    "Functions <= 25 LOC",
    "Meaningful module & function names",
    "Tagged tuple error style consistent",
    "Edge cases covered in tests",
    "Performance characteristics documented",
    "Security considerations documented",
    "Telemetry instrumentation present",
    "Health checks implemented",
    "Rate limiting where appropriate",
    "Circuit breakers for external calls",
    "Proper error handling throughout",
    "Configuration externalized",
    "Tests cover error paths",
    "Integration tests present",
    "Property-based tests where applicable",
    "Hot code swapping implemented (code_change/3)",
    "State migration functions present",
    "ETS lifecycle management",
    "Process monitoring for critical processes",
    "Memory pressure handling",
    "Distribution patterns for clustered systems",
    "Graceful shutdown implemented",
    "Resource cleanup in terminate/2",
    "Version handling for upgrades",
    "Backward compatibility maintained",
    "Ericsson-style structured logging implemented",
    "SLO monitoring and tracking",
    "Correlation IDs for distributed tracing",
    "SLA breach detection and alerting",
    "Performance metrics collection",
    "Error rate tracking and reporting",
    "Relationship annotations present",
    "Template versioning implemented",
    "Upgrade path documented",
    "Dependency relationships mapped",
    "Integration points documented",
    "Error flow relationships mapped",
    "Telemetry relationships documented",
    "SLO relationships mapped",
    "Self-evolving system patterns implemented",
    "Business logic mapping annotations present",
    "AI-assisted pattern annotations present",
    "Evolution tracking implemented",
    "Business rule compliance tracking",
    "Audit trail generation implemented",
    "AI code generation confidence scoring",
    "Usage pattern learning implemented",
    "Environment adaptation patterns present"
  ],
  "scoring_weights": {
    "docs": 1.0,
    "specs": 1.0,
    "tests": 1.0,
    "error_style": 1.0,
    "structure": 0.8,
    "naming": 0.6,
    "performance": 0.8,
    "security": 0.9,
    "observability": 0.7,
    "resilience": 0.8
  },
  "prompts": {
    "system_prompt": "You are an expert Elixir developer producing production-quality code: clean, documented, tested, secure, performant, observable, and resilient. Follow all OTP patterns and best practices.",
    "code_generation": "Generate production Elixir module for: {task}\nREQUIREMENTS:\n- Complete @moduledoc with all required sections\n- @doc for every public function with examples\n- @spec for every function\n- Use {:ok, _} | {:error, _} pattern (no raise for control flow)\n- Pattern match + guards for validation\n- Functions <= 25 LOC\n- No TODO/FIXME\n- Include telemetry instrumentation\n- Add health checks\n- Implement proper error handling\n- Add performance documentation\n- Include security considerations\nOUTPUT ONLY CODE.",
    "tests": "Generate comprehensive ExUnit tests for: {code}\nCover: happy paths, edge cases (nil/empty/boundaries), error cases, concurrency scenarios. Include property-based tests where appropriate. Ensure isolation and use async when safe. OUTPUT ONLY TEST MODULE.",
    "refactor_quality": "Refactor this Elixir code to production quality standards: {code}\nAdd missing docs/specs, simplify branching, replace raise with tagged tuples, break up long functions, add telemetry, implement proper error handling, add security considerations, improve performance. OUTPUT ONLY REFACTORED CODE."
  },
  "parent_pattern": null
}