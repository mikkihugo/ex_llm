{
  "$schema": "../UNIFIED_TEMPLATE_SCHEMA.json",
  "id": "base-elixir-module",
  "category": "base",
  "metadata": {
    "name": "Elixir Module Base (Production)",
    "version": "2.0.0",
    "description": "Production-ready base template for Elixir modules with comprehensive documentation, error handling, and integration examples",
    "language": "elixir",
    "tags": ["base", "elixir", "module", "production", "documentation", "error-handling"],
    "created": "2025-01-09",
    "updated": "2025-10-12",
    "compliance": ["production-standards", "error-matrix", "integration-examples", "edge-cases"]
  },
  "content": {
    "type": "code",
    "code": "defmodule {{module_name}} do\n  @moduledoc \"\"\"\n  {{description}}\n\n  ## Overview\n\n  {{overview}}\n\n  ## Public API Contract\n\n  {{api_contract}}\n\n  ## Error Matrix\n\n  {{error_matrix}}\n\n  ## Performance Notes\n\n  {{performance_notes}}\n\n  ## Concurrency Semantics\n\n  {{concurrency_notes}}\n\n  ## Security Considerations\n\n  {{security_notes}}\n\n  ## Examples\n\n  {{examples}}\n\n  ## Relationships\n\n  {{relationships}}\n\n  ## Template Version\n\n  {{template_version}}\n  \"\"\"\n\n  {{content}}\nend",
    "variables": {
      "module_name": {
        "type": "string",
        "description": "Module name (e.g., MyApp.Worker)",
        "required": true
      },
      "description": {
        "type": "string",
        "description": "Brief module description",
        "required": true
      },
      "overview": {
        "type": "string",
        "description": "High-level overview answering what/why/how",
        "required": true,
        "default": "Provides core functionality for [domain]. This module exists to [purpose] rather than [alternatives] because [reason]. Key capabilities include [list 2-3 main features]."
      },
      "api_contract": {
        "type": "string",
        "description": "List of stable public functions with contracts",
        "required": true,
        "default": "- `function_name(args) :: return_type` - Short purpose description\n- `another_function(args) :: return_type` - Another purpose"
      },
      "error_matrix": {
        "type": "string",
        "description": "All possible error atoms with meanings",
        "required": true,
        "default": "- `:invalid_input` - When input validation fails\n- `:not_found` - When requested resource doesn't exist\n- `:timeout` - When operation exceeds time limits\n- `:unauthorized` - When access is denied"
      },
      "performance_notes": {
        "type": "string",
        "description": "Big-O complexity and performance characteristics",
        "required": true,
        "default": "- **Time Complexity:** O(1) for lookups, O(n) for processing\n- **Space Complexity:** O(n) where n is [data size]\n- **Memory Usage:** [expected memory patterns]"
      },
      "concurrency_notes": {
        "type": "string",
        "description": "Thread safety and process boundaries",
        "required": true,
        "default": "- **Thread Safe:** Yes/No - [explanation]\n- **GenServer State:** [state management approach]\n- **Shared State:** [how shared state is handled]"
      },
      "security_notes": {
        "type": "string",
        "description": "Input validation and security considerations",
        "required": true,
        "default": "- **Input Validation:** [validation approach]\n- **Sanitization:** [data sanitization methods]\n- **Privilege Requirements:** [required permissions]"
      },
      "examples": {
        "type": "string",
        "description": "Comprehensive examples covering success/error/edge cases",
        "required": true,
        "default": "    # Success case\n    {:ok, result} = {{module_name}}.function_name(valid_input)\n    # => {:ok, expected_result}\n\n    # Error cases\n    {:error, :invalid_input} = {{module_name}}.function_name(invalid_input)\n    {:error, :not_found} = {{module_name}}.function_name(missing_resource)\n\n    # Edge cases\n    {:ok, default_result} = {{module_name}}.function_name(empty_input)\n    {:error, :timeout} = {{module_name}}.function_name(large_input)"
      },
      "relationships": {
        "type": "string",
        "description": "Module relationships and integration points",
        "required": true,
        "default": "- **Calls:** OtherModule.function/2 - For data processing\n- **Called by:** WebController.action/2 - HTTP request handling\n- **Depends on:** DatabaseModule - Data persistence\n- **Integrates with:** CacheService - Performance optimization"
      },
      "template_version": {
        "type": "string",
        "description": "Template version and upgrade information",
        "required": true,
        "default": "- **Applied:** base-elixir-module v1.0.0\n- **Applied on:** 2025-01-09\n- **Upgrade path:** base-elixir-module v1.0.0 -> v1.1.0"
      },
      "content": {
        "type": "string",
        "description": "Module implementation content",
        "required": true
      }
    }
  },
  "quality_standard": "quality_standards/elixir/production",
  "examples": [
    {
      "description": "Production-ready module with comprehensive documentation",
      "variables": {
        "module_name": "MyApp.UserService",
        "description": "User management service with authentication and profile management",
        "overview": "Provides comprehensive user management functionality including registration, authentication, and profile management. This module exists as a centralized service rather than scattered functions because it ensures consistent user data handling and security policies across the application. Key capabilities include secure password hashing, session management, and user preference storage.",
        "api_contract": "- `register(params) :: {:ok, user} | {:error, reason}` - Creates new user account\n- `authenticate(email, password) :: {:ok, user} | {:error, reason}` - Validates user credentials\n- `get_profile(user_id) :: {:ok, profile} | {:error, reason}` - Retrieves user profile\n- `update_profile(user_id, params) :: {:ok, profile} | {:error, reason}` - Updates user profile",
        "error_matrix": "- `:invalid_input` - When required fields are missing or malformed\n- `:email_taken` - When attempting to register with existing email\n- `:invalid_credentials` - When login credentials don't match\n- `:not_found` - When requested user doesn't exist\n- `:unauthorized` - When user lacks permission for operation\n- `:rate_limited` - When too many requests from same source",
        "performance_notes": "- **Time Complexity:** O(1) for authentication, O(log n) for user lookups\n- **Space Complexity:** O(n) where n is number of users\n- **Memory Usage:** Sessions cached in ETS, profiles in database\n- **Database Load:** ~10ms per authentication request",
        "concurrency_notes": "- **Thread Safe:** Yes - Uses GenServer for state management\n- **GenServer State:** Maintains connection pool and cache\n- **Shared State:** User sessions shared via distributed Erlang",
        "security_notes": "- **Input Validation:** All inputs validated with Ecto schemas\n- **Sanitization:** Email normalization, password complexity requirements\n- **Privilege Requirements:** Admin role required for user deletion",
        "examples": "    # Success case - user registration\n    {:ok, user} = MyApp.UserService.register(%{email: \"user@example.com\", password: \"secure123!\"})\n    # => {:ok, %User{id: 123, email: \"user@example.com\"}}\n\n    # Success case - authentication\n    {:ok, user} = MyApp.UserService.authenticate(\"user@example.com\", \"secure123!\")\n    # => {:ok, %User{id: 123, email: \"user@example.com\"}}\n\n    # Error cases\n    {:error, :invalid_input} = MyApp.UserService.register(%{email: \"invalid-email\", password: \"\"})\n    {:error, :invalid_credentials} = MyApp.UserService.authenticate(\"user@example.com\", \"wrongpass\")\n    {:error, :not_found} = MyApp.UserService.get_profile(999)\n\n    # Edge cases\n    {:error, :rate_limited} = MyApp.UserService.register(%{email: \"new@example.com\", password: \"pass\"}) # After 10 attempts\n    {:ok, default_profile} = MyApp.UserService.get_profile(123) # User with no custom profile",
        "relationships": "- **Calls:** MyApp.Repo - Database operations\n- **Calls:** MyApp.Cache - Session caching\n- **Calls:** MyApp.Mailer - Email notifications\n- **Called by:** MyAppWeb.UserController - HTTP request handling\n- **Called by:** MyAppWeb.AuthPlug - Authentication middleware\n- **Depends on:** PostgreSQL - User data storage\n- **Integrates with:** Redis - Session storage\n- **Integrates with:** SendGrid - Email delivery",
        "template_version": "- **Applied:** base-elixir-module v1.0.0\n- **Applied on:** 2025-01-09\n- **Upgrade path:** base-elixir-module v1.0.0 -> v1.1.0",
        "content": "  use GenServer\n  alias MyApp.{Repo, User, UserProfile}\n\n  @doc \"\"\"\n  Registers a new user account.\n\n  ## Parameters\n  - `params` - Map with `:email` and `:password` keys\n\n  ## Returns\n  - `{:ok, user}` - Successfully created user\n  - `{:error, reason}` - Registration failed\n\n  ## Errors\n  - `:invalid_input` - Missing or invalid parameters\n  - `:email_taken` - Email already registered\n\n  ## Examples\n\n      {:ok, user} = MyApp.UserService.register(%{email: \"user@example.com\", password: \"secure123!\"})\n      {:error, :email_taken} = MyApp.UserService.register(%{email: \"existing@example.com\", password: \"pass\"})\n  \"\"\"\n  @spec register(map()) :: {:ok, User.t()} | {:error, atom()}\n  def register(params) do\n    # Implementation here\n  end"
      },
      "output": "defmodule MyApp.UserService do\n  @moduledoc \"\"\"\n  User management service with authentication and profile management\n\n  ## Overview\n\n  Provides comprehensive user management functionality including registration, authentication, and profile management. This module exists as a centralized service rather than scattered functions because it ensures consistent user data handling and security policies across the application. Key capabilities include secure password hashing, session management, and user preference storage.\n\n  ## Public API Contract\n\n  - `register(params) :: {:ok, user} | {:error, reason}` - Creates new user account\n  - `authenticate(email, password) :: {:ok, user} | {:error, reason}` - Validates user credentials\n  - `get_profile(user_id) :: {:ok, profile} | {:error, reason}` - Retrieves user profile\n  - `update_profile(user_id, params) :: {:ok, profile} | {:error, reason}` - Updates user profile\n\n  ## Error Matrix\n\n  - `:invalid_input` - When required fields are missing or malformed\n  - `:email_taken` - When attempting to register with existing email\n  - `:invalid_credentials` - When login credentials don't match\n  - `:not_found` - When requested user doesn't exist\n  - `:unauthorized` - When user lacks permission for operation\n  - `:rate_limited` - When too many requests from same source\n\n  ## Performance Notes\n\n  - **Time Complexity:** O(1) for authentication, O(log n) for user lookups\n  - **Space Complexity:** O(n) where n is number of users\n  - **Memory Usage:** Sessions cached in ETS, profiles in database\n  - **Database Load:** ~10ms per authentication request\n\n  ## Concurrency Semantics\n\n  - **Thread Safe:** Yes - Uses GenServer for state management\n  - **GenServer State:** Maintains connection pool and cache\n  - **Shared State:** User sessions shared via distributed Erlang\n\n  ## Security Considerations\n\n  - **Input Validation:** All inputs validated with Ecto schemas\n  - **Sanitization:** Email normalization, password complexity requirements\n  - **Privilege Requirements:** Admin role required for user deletion\n\n  ## Examples\n\n      # Success case - user registration\n      {:ok, user} = MyApp.UserService.register(%{email: \"user@example.com\", password: \"secure123!\"})\n      # => {:ok, %User{id: 123, email: \"user@example.com\"}}\n\n      # Success case - authentication\n      {:ok, user} = MyApp.UserService.authenticate(\"user@example.com\", \"secure123!\")\n      # => {:ok, %User{id: 123, email: \"user@example.com\"}}\n\n      # Error cases\n      {:error, :invalid_input} = MyApp.UserService.register(%{email: \"invalid-email\", password: \"\"})\n      {:error, :invalid_credentials} = MyApp.UserService.authenticate(\"user@example.com\", \"wrongpass\")\n      {:error, :not_found} = MyApp.UserService.get_profile(999)\n\n      # Edge cases\n      {:error, :rate_limited} = MyApp.UserService.register(%{email: \"new@example.com\", password: \"pass\"}) # After 10 attempts\n      {:ok, default_profile} = MyApp.UserService.get_profile(123) # User with no custom profile\n\n  ## Relationships\n\n  - **Calls:** MyApp.Repo - Database operations\n  - **Calls:** MyApp.Cache - Session caching\n  - **Calls:** MyApp.Mailer - Email notifications\n  - **Called by:** MyAppWeb.UserController - HTTP request handling\n  - **Called by:** MyAppWeb.AuthPlug - Authentication middleware\n  - **Depends on:** PostgreSQL - User data storage\n  - **Integrates with:** Redis - Session storage\n  - **Integrates with:** SendGrid - Email delivery\n\n  ## Template Version\n\n  - **Applied:** base-elixir-module v1.0.0\n  - **Applied on:** 2025-01-09\n  - **Upgrade path:** base-elixir-module v1.0.0 -> v1.1.0\n  \"\"\"\n\n  use GenServer\n  alias MyApp.{Repo, User, UserProfile}\n\n  @doc \"\"\"\n  Registers a new user account.\n\n  ## Parameters\n  - `params` - Map with `:email` and `:password` keys\n\n  ## Returns\n  - `{:ok, user}` - Successfully created user\n  - `{:error, reason}` - Registration failed\n\n  ## Errors\n  - `:invalid_input` - Missing or invalid parameters\n  - `:email_taken` - Email already registered\n\n  ## Examples\n\n      {:ok, user} = MyApp.UserService.register(%{email: \"user@example.com\", password: \"secure123!\"})\n      {:error, :email_taken} = MyApp.UserService.register(%{email: \"existing@example.com\", password: \"pass\"})\n  \"\"\"\n  @spec register(map()) :: {:ok, User.t()} | {:error, atom()}\n  def register(params) do\n    # Implementation here\n  end\nend"
    }
  ]
}
