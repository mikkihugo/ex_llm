{
  "$schema": "../UNIFIED_TEMPLATE_SCHEMA.json",
  "id": "base-elixir-supervisor-nested",
  "category": "base",
  "metadata": {
    "name": "Elixir Nested Supervisor (Production)",
    "version": "1.0.0",
    "description": "Production-ready template for nested Elixir supervisors with layered architecture, comprehensive documentation, and dependency tracking",
    "language": "elixir",
    "tags": [
      "base",
      "elixir",
      "supervisor",
      "otp",
      "production",
      "nested",
      "layered"
    ],
    "created": "2025-10-12",
    "updated": "2025-10-12",
    "compliance": [
      "production-standards",
      "otp-best-practices",
      "dependency-documentation"
    ]
  },
  "content": {
    "type": "code",
    "code": "defmodule {{module_name}} do\n  @moduledoc \"\"\"\n  {{description}}\n\n  {{purpose}}\n\n  ## Managed Processes\n\n  {{managed_processes}}\n\n  ## Restart Strategy\n\n  {{restart_strategy}}\n\n  ## Dependencies\n\n  {{dependencies}}\n  \"\"\"\n\n  use Supervisor\n  require Logger\n\n  def start_link(opts \\\\ []) do\n    Supervisor.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl true\n  def init(_opts) do\n    Logger.info(\"Starting {{module_name}}...\")\n\n    children = [\n      {{children}}\n    ]\n\n    Supervisor.init(children, strategy: {{strategy}})\n  end\nend",
    "variables": {
      "module_name": {
        "type": "string",
        "description": "Full supervisor module name (e.g., MyApp.NATS.Supervisor)",
        "required": true
      },
      "description": {
        "type": "string",
        "description": "Brief one-line supervisor description",
        "required": true
      },
      "purpose": {
        "type": "string",
        "description": "Detailed purpose explaining what this supervisor manages and why",
        "required": true,
        "default": "Supervises {{domain}} infrastructure components, ensuring fault tolerance and proper startup ordering."
      },
      "managed_processes": {
        "type": "string",
        "description": "List of child processes managed by this supervisor with brief descriptions",
        "required": true,
        "default": "- `ChildModule1` - GenServer managing {{functionality1}}\n- `ChildModule2` - GenServer managing {{functionality2}}"
      },
      "restart_strategy": {
        "type": "string",
        "description": "Explanation of restart strategy and why it was chosen",
        "required": true,
        "default": "Uses `:one_for_one` because each child is independent.\n\nAlternatives:\n- `:rest_for_one` - Use when children depend on earlier siblings\n- `:one_for_all` - Use when all children must restart together"
      },
      "dependencies": {
        "type": "string",
        "description": "List of dependencies this supervisor requires to be started first",
        "required": true,
        "default": "Depends on:\n- Repo - For database access\n- Telemetry - For metrics collection"
      },
      "children": {
        "type": "string",
        "description": "List of child modules to supervise (one per line, with comments)",
        "required": true,
        "default": "# Comment explaining purpose\n      ChildModule1,\n      ChildModule2"
      },
      "strategy": {
        "type": "string",
        "description": "Supervisor strategy (:one_for_one, :rest_for_one, :one_for_all)",
        "required": true,
        "default": ":one_for_one",
        "enum": [
          ":one_for_one",
          ":rest_for_one",
          ":one_for_all"
        ]
      }
    }
  },
  "quality_standard": "quality_standards/elixir/production",
  "examples": [
    {
      "description": "NATS messaging infrastructure supervisor",
      "variables": {
        "module_name": "MyApp.NATS.Supervisor",
        "description": "NATS Supervisor - Manages NATS messaging infrastructure.",
        "purpose": "Supervises all NATS-related processes in the correct startup order:\n  1. NatsServer - Main NATS server connection\n  2. NatsClient - Client interface for publishing/subscribing\n  3. NatsExecutionRouter - Routes NATS messages to appropriate handlers",
        "managed_processes": "- `MyApp.NatsServer` - GenServer managing NATS connection\n- `MyApp.NatsClient` - GenServer providing client interface\n- `MyApp.NatsExecutionRouter` - GenServer routing messages",
        "restart_strategy": "Uses `:rest_for_one` because dependencies flow in order:\n  - If NatsServer crashes, restart Client and Router (they depend on it)\n  - If NatsClient crashes, restart Router (it depends on client)\n  - If NatsExecutionRouter crashes, only restart it",
        "dependencies": "None - NATS infrastructure is self-contained and starts early.",
        "children": "# Order matters! Server must start before Client, Client before Router\n      MyApp.NatsServer,\n      MyApp.NatsClient,\n      MyApp.NatsExecutionRouter",
        "strategy": ":rest_for_one"
      },
      "output": "defmodule MyApp.NATS.Supervisor do\n  @moduledoc \"\"\"\n  NATS Supervisor - Manages NATS messaging infrastructure.\n\n  Supervises all NATS-related processes in the correct startup order:\n  1. NatsServer - Main NATS server connection\n  2. NatsClient - Client interface for publishing/subscribing\n  3. NatsExecutionRouter - Routes NATS messages to appropriate handlers\n\n  ## Managed Processes\n\n  - `MyApp.NatsServer` - GenServer managing NATS connection\n  - `MyApp.NatsClient` - GenServer providing client interface\n  - `MyApp.NatsExecutionRouter` - GenServer routing messages\n\n  ## Restart Strategy\n\n  Uses `:rest_for_one` because dependencies flow in order:\n  - If NatsServer crashes, restart Client and Router (they depend on it)\n  - If NatsClient crashes, restart Router (it depends on client)\n  - If NatsExecutionRouter crashes, only restart it\n\n  ## Dependencies\n\n  None - NATS infrastructure is self-contained and starts early.\n  \"\"\"\n\n  use Supervisor\n  require Logger\n\n  def start_link(opts \\\\ []) do\n    Supervisor.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl true\n  def init(_opts) do\n    Logger.info(\"Starting MyApp.NATS.Supervisor...\")\n\n    children = [\n      # Order matters! Server must start before Client, Client before Router\n      MyApp.NatsServer,\n      MyApp.NatsClient,\n      MyApp.NatsExecutionRouter\n    ]\n\n    Supervisor.init(children, strategy: :rest_for_one)\n  end\nend"
    },
    {
      "description": "Knowledge domain supervisor with independent children",
      "variables": {
        "module_name": "MyApp.Knowledge.Supervisor",
        "description": "Knowledge Supervisor - Manages knowledge base and template infrastructure.",
        "purpose": "Supervises all knowledge-related processes including templates, performance tracking, and code storage.\n\nThis supervisor manages the \"Living Knowledge Base\" components:\n- Templates (JSON \u2192 PostgreSQL \u2192 ETS cache)\n- Performance metrics (usage tracking, success rates)\n- Code storage (parsed code chunks with embeddings)",
        "managed_processes": "- `MyApp.Knowledge.TemplateService` - GenServer managing template loading/caching\n- `MyApp.TemplatePerformanceTracker` - GenServer tracking template usage/performance\n- `MyApp.CodeStore` - GenServer managing code chunk storage",
        "restart_strategy": "Uses `:one_for_one` because each child is independent.\n\nChildren can fail and restart independently without affecting siblings. All children depend on Repo but not on each other.",
        "dependencies": "Depends on:\n- Repo - For PostgreSQL access (knowledge_artifacts table)\n- EmbeddingModelLoader (Infrastructure.Supervisor) - For generating embeddings",
        "children": "MyApp.Knowledge.TemplateService,\n      MyApp.TemplatePerformanceTracker,\n      MyApp.CodeStore",
        "strategy": ":one_for_one"
      },
      "output": "defmodule MyApp.Knowledge.Supervisor do\n  @moduledoc \"\"\"\n  Knowledge Supervisor - Manages knowledge base and template infrastructure.\n\n  Supervises all knowledge-related processes including templates, performance tracking, and code storage.\n\n  This supervisor manages the \"Living Knowledge Base\" components:\n  - Templates (JSON \u2192 PostgreSQL \u2192 ETS cache)\n  - Performance metrics (usage tracking, success rates)\n  - Code storage (parsed code chunks with embeddings)\n\n  ## Managed Processes\n\n  - `MyApp.Knowledge.TemplateService` - GenServer managing template loading/caching\n  - `MyApp.TemplatePerformanceTracker` - GenServer tracking template usage/performance\n  - `MyApp.CodeStore` - GenServer managing code chunk storage\n\n  ## Restart Strategy\n\n  Uses `:one_for_one` because each child is independent.\n\n  Children can fail and restart independently without affecting siblings. All children depend on Repo but not on each other.\n\n  ## Dependencies\n\n  Depends on:\n  - Repo - For PostgreSQL access (knowledge_artifacts table)\n  - EmbeddingModelLoader (Infrastructure.Supervisor) - For generating embeddings\n  \"\"\"\n\n  use Supervisor\n  require Logger\n\n  def start_link(opts \\\\ []) do\n    Supervisor.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl true\n  def init(_opts) do\n    Logger.info(\"Starting MyApp.Knowledge.Supervisor...\")\n\n    children = [\n      MyApp.Knowledge.TemplateService,\n      MyApp.TemplatePerformanceTracker,\n      MyApp.CodeStore\n    ]\n\n    Supervisor.init(children, strategy: :one_for_one)\n  end\nend"
    }
  ],
  "parent_pattern": null
}