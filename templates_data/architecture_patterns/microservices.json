{
  "id": "microservices",
  "name": "Microservices Architecture",
  "category": "architecture",
  "version": "1.0.0",
  "description": "Architecture pattern where application is composed of multiple independent services that communicate through well-defined APIs or message brokers. Each service is independently deployable, scalable, and maintainable.",
  "aliases": [
    "Service-Oriented Architecture (SOA)",
    "Microservices Pattern",
    "Distributed Services"
  ],
  "indicators": [
    {
      "name": "multiple_services",
      "description": "Multiple independent services with separate codebases or clear boundaries",
      "weight": 0.9,
      "required": true,
      "detection_hints": [
        "Multiple package.json/Cargo.toml/mix.exs files",
        "Separate service directories",
        "Multiple build configurations"
      ]
    },
    {
      "name": "api_boundaries",
      "description": "Clear API contracts between services (REST, gRPC, GraphQL)",
      "weight": 0.85,
      "required": true,
      "detection_hints": [
        "OpenAPI/Swagger specs",
        "gRPC .proto files",
        "GraphQL schemas"
      ]
    },
    {
      "name": "independent_deployment",
      "description": "Each service can be deployed independently",
      "weight": 0.8,
      "required": false,
      "detection_hints": [
        "Separate Dockerfiles",
        "Service-specific deployment configs",
        "CI/CD per service"
      ]
    },
    {
      "name": "inter_service_communication",
      "description": "Services communicate via network (sync or async)",
      "weight": 0.75,
      "required": false,
      "detection_hints": [
        "HTTP clients",
        "Message brokers (NATS, Kafka, RabbitMQ)",
        "Service mesh"
      ]
    },
    {
      "name": "containerization",
      "description": "Services containerized for deployment",
      "weight": 0.7,
      "required": false,
      "detection_hints": [
        "Dockerfiles",
        "Kubernetes manifests",
        "docker-compose.yml"
      ]
    }
  ],
  "benefits": [
    "Independent scaling of services based on demand",
    "Technology diversity (choose best tool for each service)",
    "Fault isolation (failure in one service doesn't crash entire system)",
    "Independent deployment (deploy services separately, faster releases)",
    "Team autonomy (teams own services end-to-end)",
    "Easier to understand (smaller codebases per service)"
  ],
  "concerns": [
    "Distributed systems complexity (network latency, failures)",
    "Data consistency challenges (no ACID transactions across services)",
    "Operational overhead (monitoring, logging, tracing across services)",
    "Deployment complexity (many services to manage)",
    "Testing difficulty (integration testing across services)",
    "Debugging challenges (requests span multiple services)"
  ],
  "when_to_use": [
    "Large teams (>50 developers) needing autonomy",
    "Complex domains with distinct bounded contexts",
    "Different scaling requirements per service",
    "Need for technology diversity",
    "High deployment frequency requirements (>10/day)"
  ],
  "when_not_to_use": [
    "Small teams (<10 developers) - overhead outweighs benefits",
    "Simple domains - monolith is simpler",
    "Strong consistency requirements everywhere",
    "Limited operational maturity (no DevOps expertise)",
    "Tight coupling between components"
  ],
  "required_practices": [
    {
      "practice": "Circuit Breakers",
      "priority": "REQUIRED",
      "description": "Prevent cascading failures when services are down",
      "adoption_rate": 0.94,
      "sources": [
        "Netflix Hystrix",
        "Martin Fowler"
      ]
    },
    {
      "practice": "Distributed Tracing",
      "priority": "REQUIRED",
      "description": "Track requests across service boundaries",
      "adoption_rate": 0.78,
      "sources": [
        "OpenTelemetry",
        "Google Dapper"
      ]
    },
    {
      "practice": "API Gateway",
      "priority": "RECOMMENDED",
      "description": "Single entry point for external clients",
      "adoption_rate": 0.65,
      "sources": [
        "Kong",
        "NGINX",
        "Traefik"
      ]
    },
    {
      "practice": "Service Discovery",
      "priority": "RECOMMENDED",
      "description": "Dynamic service location and health checking",
      "adoption_rate": 0.88,
      "sources": [
        "Consul",
        "Kubernetes DNS"
      ]
    },
    {
      "practice": "Service Mesh",
      "priority": "OPTIONAL",
      "description": "Traffic management and observability layer",
      "adoption_rate": 0.42,
      "sources": [
        "Istio",
        "Linkerd"
      ]
    }
  ],
  "llm_team_validation": {
    "validated": true,
    "consensus_score": 82,
    "validated_by": [
      "claude-opus",
      "gpt-4.1",
      "gemini-2.5-pro",
      "claude-sonnet",
      "gpt-5-mini"
    ],
    "validation_date": "2025-10-23",
    "approved": true,
    "conditions": [
      "Circuit breakers MUST be implemented",
      "Distributed tracing MUST be implemented",
      "Monitoring and alerting MUST be comprehensive"
    ]
  },
  "authoritative_sources": [
    {
      "author": "Martin Fowler",
      "title": "Microservices",
      "url": "https://martinfowler.com/articles/microservices.html",
      "type": "article"
    },
    {
      "author": "Chris Richardson",
      "title": "Microservices Patterns",
      "url": "https://microservices.io",
      "type": "website"
    },
    {
      "author": "Sam Newman",
      "title": "Building Microservices (2nd Edition)",
      "type": "book"
    }
  ],
  "metadata": {
    "created_at": "2025-10-23",
    "updated_at": "2025-10-23",
    "version": "1.0.0",
    "detection_template": "detect-microservices.lua",
    "llm_team_templates": [
      "analyst-discover-pattern.lua",
      "validator-validate-pattern.lua",
      "critic-critique-pattern.lua",
      "researcher-research-pattern.lua",
      "coordinator-build-consensus.lua"
    ]
  },
  "parent_pattern": null
}