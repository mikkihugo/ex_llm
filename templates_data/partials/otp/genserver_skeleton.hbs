use GenServer
require Logger

@type state :: %{
  {{#each state_fields}}
  {{name}}: {{type}},
  {{/each}}
}

## Client API

@doc """
Start the {{module_type}}.

## Options
{{#if start_link_options}}
{{start_link_options}}
{{else}}
- `:name` - Process name (optional)
{{/if}}
"""
@spec start_link(keyword()) :: GenServer.on_start()
def start_link(opts \\ []) do
  {{#if use_via_tuple}}
  name = Keyword.get(opts, :name, __MODULE__)
  GenServer.start_link(__MODULE__, opts, name: via_tuple(name))
  {{else}}
  GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  {{/if}}
end

{{#if use_child_spec}}
@doc false
def child_spec(opts) do
  %{
    id: __MODULE__,
    start: {__MODULE__, :start_link, [opts]},
    type: :worker,
    restart: :permanent,
    shutdown: 5000
  }
end
{{/if}}

## Server Callbacks

@impl true
def init(opts) do
  {{#if init_subscribe}}
  # Subscribe to channels/topics on init
  {{init_subscribe}}
  {{/if}}

  state = %{
    {{#each state_fields}}
    {{name}}: {{default}},
    {{/each}}
  }

  {{#if async_init}}
  # Continue initialization asynchronously
  {:ok, state, {:continue, :async_init}}
  {{else}}
  {:ok, state}
  {{/if}}
end

{{#if async_init}}
@impl true
def handle_continue(:async_init, state) do
  # Perform async initialization here
  {:noreply, state}
end
{{/if}}

@impl true
def handle_call(request, _from, state) do
  Logger.warning("Unhandled call: #{inspect(request)}")
  {:reply, {:error, :not_implemented}, state}
end

@impl true
def handle_cast(msg, state) do
  Logger.warning("Unhandled cast: #{inspect(msg)}")
  {:noreply, state}
end

@impl true
def handle_info(msg, state) do
  Logger.warning("Unhandled info: #{inspect(msg)}")
  {:noreply, state}
end

{{#if use_via_tuple}}
defp via_tuple(name) do
  {:via, Registry, {{{registry_name}}, name}}
end
{{/if}}
