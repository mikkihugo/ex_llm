================================================================================
                    TASK & JOB EXECUTION INVENTORY - FINAL SUMMARY
================================================================================

PROJECT: Singularity (Internal AI Development Tooling)
SCOPE: All task execution, job orchestration, and work processing systems
DATE: 2025-10-24

================================================================================
PART 1: EXECUTION PATTERNS FOUND (4 DISTINCT SYSTEMS)
================================================================================

1. OBAN BACKGROUND JOBS (18 files, 2,902 lines)
   Location: /singularity/lib/singularity/jobs/ (15 files)
             /centralcloud/lib/centralcloud/jobs/ (3 files)
   
   Pattern: use Oban.Worker → implement perform/1 → return :ok or {:error, ...}
   Invocation: JobOrchestrator.enqueue(:job_type, args)
   Queuing: PostgreSQL via Oban
   Scheduling: Oban.Plugins.Cron (*/5 * * * * to daily intervals)
   Concurrency: Async queue (Oban manages multiple workers)
   
   Key Jobs:
   - Metrics aggregation (5 min)
   - Pattern mining & syncing (5 min - 1 hour)
   - Agent evolution (1 hour)
   - Cache maintenance (5 min - 6 hours)
   - ML model training (on-demand)
   - Dead code detection (daily/weekly)
   
   Infrastructure:
   - JobOrchestrator - Config-driven job discovery and enqueue
   - JobType behavior - Contract for all jobs

2. NATS MESSAGE HANDLERS (5 files, ~1,400 lines)
   Location: /singularity/lib/singularity/nats/ (3 files)
             /centralcloud/lib/centralcloud/ (2 files)
   
   Pattern: use GenServer → subscribe to NATS subjects → handle_info/2
   Invocation: NatsClient.publish(subject, message, reply_to: response_subject)
   Queuing: NATS JetStream (optional persistence)
   Scheduling: None (fire-and-forget or request-reply)
   Concurrency: Async via Task.async() + reply publishing
   
   Key Handlers:
   - NatsExecutionRouter (execution.request.task)
   - IntelligenceHubSubscriber (intelligence.hub.*.*)
   - PatternValidatorSubscriber (pattern validation)
   
   Characteristics:
   - GenServer-based
   - Fire-and-forget or request-reply pattern
   - No persistence by default
   - Decoupled from main Singularity process

3. TASK GRAPH / TODO STORE EXECUTION (13,114 lines)
   Location: /singularity/lib/singularity/execution/ (90 files)
   
   Core Components:
   - TaskGraph.Orchestrator - Enqueue tasks with dependencies
   - TaskGraph.WorkerPool - GenServer that polls for ready tasks every 5s
   - TaskGraph.Worker - Individual worker process
   - TodoStore - PostgreSQL persistence
   - 4 Execution Adapters (Shell, Docker, Lua, Http)
   
   Pattern: enqueue task → store in DB → poll for ready → spawn worker → execute
   Invocation: TaskGraph.Orchestrator.enqueue(task)
   Queuing: PostgreSQL todos table with depends_on tracking
   Scheduling: None (on-demand enqueue)
   Concurrency: Poll-based, max 10 concurrent workers
   
   Unique Features:
   - Dependency graph support (depends_on_ids)
   - Role-based security policies (:coder, :tester, :critic, :admin)
   - Pluggable execution adapters
   - Result storage in database
   - Workflow orchestration

4. GENSERVER AGENT/EXECUTOR EXECUTION (7+ files, ~2,500 lines)
   Location: /singularity/lib/singularity/agents/
             /singularity/lib/singularity/execution/planning/
             /singularity/lib/singularity/tools/
   
   Pattern: GenServer.start_link() → Agent.execute() → GenServer.call()
   Invocation: Agent.execute(agent_id, task) or direct GenServer.call()
   Queuing: None (synchronous blocking calls)
   Scheduling: None (on-demand)
   Concurrency: 1 task per agent process (sequential)
   
   Key Agents:
   - CostOptimizedAgent - Model selection & cost optimization
   - SelfImprovingAgent - Learning & improvement
   - RuntimeBootstrapper - Startup initialization
   - Various executors (TaskGraph, Lua, Methodology, DB Tools)

================================================================================
PART 2: CURRENT INTEGRATION LANDSCAPE
================================================================================

EXECUTION ENTRY POINTS (from application code):

1. Background Periodic Tasks:
   JobOrchestrator.enqueue(:job_type, args) → Oban Queue → Worker.perform()

2. Request-Reply Messaging:
   NatsClient.publish(subject, message, reply_to: ...) → GenServer handler → reply

3. Dependency-Driven Workflows:
   TaskGraph.Orchestrator.enqueue(task_with_dependencies) → TodoStore → polling → execution

4. Direct Agent Execution:
   Agent.execute(agent_id, task) → GenServer.call() → synchronous result

5. Orchestrators (Auto-detection):
   ExecutionOrchestrator.execute(goal) → detects strategy → routes to appropriate engine

CONFIGURATION SCATTERING:

- Oban jobs: /singularity/config.exs (job_types + crontab)
- NATS handlers: Hard-coded in module init()
- TodoStore: Hard-coded in application code
- Agents: Hard-coded agent creation
- ExecutionOrchestrator: Auto-detection heuristics

================================================================================
PART 3: ABSTRACTION GAPS (CONSOLIDATION OPPORTUNITIES)
================================================================================

GAP 1: No Unified Task Interface
   Problem: 4 completely different patterns with different return types
   Impact: Learning system must handle all 4 patterns separately
   Opportunity: Create TaskExecutor protocol/behavior

GAP 2: No Unified Discovery
   Problem: Oban has JobOrchestrator.get_job_types_info(), others don't
   Impact: Cannot enumerate all tasks in system
   Opportunity: Unified task registry discoverable via config

GAP 3: No Unified Learning/Observability
   Problem: Only Oban has optional learn_from_job/1 callback
   Impact: Other execution patterns invisible to improvement loop
   Opportunity: All patterns feed into unified learning system

GAP 4: No Unified Timeouts
   Problem: Oban (none), NATS (manual), TodoStore (adapter-specific), Agent (none)
   Impact: Inconsistent timeout behavior
   Opportunity: Unified timeout policy in TaskExecutor

GAP 5: Scattered Configuration
   Problem: Job config in config.exs, NATS subjects hard-coded, etc.
   Impact: Hard to manage, hard to test, hard to discover
   Opportunity: Central task registry in config

GAP 6: Multiple Orchestrators
   Problem: 5+ different orchestrator modules with overlapping functionality
   Impact: Confusion about which to use, code duplication
   Opportunity: Single unified orchestrator with strategy selection

================================================================================
PART 4: CONSOLIDATION SCOPE & EFFORT
================================================================================

HIGH PRIORITY (Scattered, Similar Code):

A. Oban Jobs (15 files) → ~2,900 lines
   - 10 maintenance jobs (~70 lines each): batch into 1 template
   - 3 training jobs (~150-200 lines each): batch into 1 generic trainer
   - 2 analysis jobs (~100 lines each): batch into 1 analyzer
   - Reduction: 2,900 → ~500 lines (83% consolidation)

B. NATS Handlers (3 files) → ~1,400 lines
   - Unify subscription pattern
   - Centralize message routing
   - Reduction: 1,400 → ~800 lines (43% consolidation)

MEDIUM PRIORITY (Scattered but Specialized):

C. Execution Orchestrators (5+ files) → ~1,500 lines
   - Unify under ExecutionOrchestrator
   - Keep strategy-specific logic in adapters
   - Reduction: minor (mostly refactoring)

LOWER PRIORITY (Already Somewhat Unified):

D. TodoStore System (5 files) → already has adapter pattern
   - Good separation of concerns
   - Keep as-is

E. Agent System (7+ files) → has base class but some duplication
   - Minor consolidation possible

================================================================================
PART 5: FILES INVENTORY
================================================================================

MAIN EXECUTION SYSTEM FILES:

Jobs (Oban):
- /singularity/lib/singularity/jobs/job_orchestrator.ex (298 lines) ← orchestrator
- /singularity/lib/singularity/jobs/job_type.ex (215 lines) ← behavior
- /singularity/lib/singularity/jobs/*_worker.ex (15 files)
- /centralcloud/lib/centralcloud/jobs/*.ex (3 files)

NATS:
- /singularity/lib/singularity/nats/nats_execution_router.ex (245 lines) ← router
- /singularity/lib/singularity/nats/nats_server.ex (~500 lines)
- /singularity/lib/singularity/nats/nats_client.ex (~300 lines)
- /centralcloud/lib/centralcloud/intelligence_hub_subscriber.ex (~100 lines)

Task Graph:
- /singularity/lib/singularity/execution/task_graph/orchestrator.ex (200+ lines) ← orchestrator
- /singularity/lib/singularity/execution/task_graph/worker_pool.ex (250+ lines)
- /singularity/lib/singularity/execution/task_graph/worker.ex (300+ lines)
- /singularity/lib/singularity/execution/task_graph/toolkit.ex (300+ lines)
- /singularity/lib/singularity/execution/task_graph/policy.ex (150+ lines)
- /singularity/lib/singularity/execution/task_graph/adapters/*.ex (4 adapters)

Execution Planning:
- /singularity/lib/singularity/execution/planning/task_graph_executor.ex
- /singularity/lib/singularity/execution/planning/task_graph_core.ex
- /singularity/lib/singularity/execution/planning/lua_strategy_executor.ex
- /singularity/lib/singularity/execution/planning/safe_work_planner.ex
- (8+ more planning modules)

Agents:
- /singularity/lib/singularity/agents/agent.ex (400+ lines) ← base
- /singularity/lib/singularity/agents/cost_optimized_agent.ex (300+ lines)
- /singularity/lib/singularity/agents/self_improving_agent.ex (250+ lines)
- (7+ more agent modules)

Todos (Storage):
- /singularity/lib/singularity/execution/todos/todo_store.ex (300+ lines)
- /singularity/lib/singularity/execution/todos/todo_nats_interface.ex (150+ lines)
- (4+ more todos modules)

Orchestrators:
- /singularity/lib/singularity/execution/execution_orchestrator.ex (126 lines) ← unified attempt
- /singularity/lib/singularity/execution/sparc/orchestrator.ex (400+ lines)
- /singularity/lib/singularity/quality/methodology_executor.ex (200+ lines)

================================================================================
PART 6: CONSOLIDATION STRATEGY RECOMMENDATIONS
================================================================================

PHASE 1: Create Unified Interface (1-2 weeks)
- Define TaskExecutor protocol/behavior
- Map each execution pattern to adapter
- Create shared types/structures

PHASE 2: Implement Adapters (2-3 weeks)
- ObanAdapter wrapping Oban execution
- NatsAdapter wrapping NATS messaging
- TodoStorageAdapter wrapping TodoStore
- AgentAdapter wrapping Agent execution

PHASE 3: Consolidate Jobs (1-2 weeks)
- Replace 15 individual job files with template system
- Register all jobs in central config
- Update JobOrchestrator to use templates

PHASE 4: Unify Configuration (1 week)
- Central task registry in config.exs
- Unified discovery mechanism
- Learning system integration points

PHASE 5: Migrate Code (2-3 weeks)
- Update all task invocation points
- Test each execution pattern
- Documentation & examples

ESTIMATED TOTAL EFFORT: 7-11 weeks of focused work

ESTIMATED CODE REDUCTION:
- Jobs: 2,900 → 500 lines (83% reduction)
- NATS: 1,400 → 800 lines (43% reduction)
- Total: ~4,400 lines of infrastructure code removed

================================================================================
DOCUMENTS CREATED:
================================================================================

1. TASK_EXECUTION_INVENTORY.md (15K)
   - Complete task/job inventory
   - Execution patterns & signatures
   - Integration points
   - Abstraction gaps
   - Consolidation roadmap

2. EXECUTION_PATTERN_ANALYSIS.md (18K)
   - Detailed comparison matrix
   - Module inventory with line counts
   - Execution flow diagrams
   - Gap analysis
   - Consolidation priority matrix

3. This summary (reference guide)

================================================================================
