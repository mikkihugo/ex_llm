# Answer File Storage Strategy

## Current State

**Database (Primary):** ✅ Already implemented
- Table: `template_generations`
- Column: `answers` (JSONB)
- Purpose: Query stats, find generations, calculate success rates

**File System (Optional):** ❌ Not yet implemented
- Would write: `.template-answers.yml` next to generated files
- Purpose: Git history, manual inspection, local upgrades

## Recommendation: Dual Storage (DB + File)

### Why Both?

**Database = Runtime queries**
```elixir
# Fast queries
TemplateGeneration.calculate_success_rate("quality_template:elixir-production")
TemplateGeneration.list_by_template("quality_template:elixir-genserver")
```

**File System = Git history + human inspection**
```bash
# See what questions generated this file
cat lib/my_genserver.ex.template-answers.yml

# Git history shows changes
git log lib/my_genserver.ex.template-answers.yml

# Manual editing + regeneration
vim lib/my_genserver.ex.template-answers.yml
mix template.regenerate lib/my_genserver.ex
```

## File Naming: `.template-answers.yml` NOT `.copier-answers.yml`

**Why not `.copier-answers.yml`?**
- We're NOT using Copier (Python tool)
- Would confuse developers
- Not accurate naming

**Why `.template-answers.yml`?**
- Descriptive: "answers for template generation"
- Consistent with our implementation
- Similar pattern to `.copier-answers.yml` (familiar)

**Alternative: `.singularity-answers.yml`**
- More specific to our project
- But ".template-answers.yml" is more generic/reusable

## Implementation Plan

### 1. Add Automatic File Writing

**Modify:** `lib/singularity/knowledge/template_generation.ex`

```elixir
defmodule Singularity.Knowledge.TemplateGeneration do
  # ... existing code ...

  @doc """
  Record template generation WITH automatic answer file writing.
  """
  def record(attrs) do
    # Insert to DB (existing)
    changeset = TemplateGeneration.changeset(%TemplateGeneration{}, attrs)

    case Repo.insert(changeset) do
      {:ok, generation} = result ->
        # NEW: Write answer file to disk
        write_answer_file(generation)
        result

      error ->
        error
    end
  end

  @doc """
  Write .template-answers.yml next to generated file.
  """
  def write_answer_file(%TemplateGeneration{} = generation) do
    if generation.file_path do
      answer_file_path = generation.file_path <> ".template-answers.yml"

      yaml_content = export_answer_file_content(generation)

      case File.write(answer_file_path, yaml_content) do
        :ok ->
          Logger.debug("Wrote answer file: #{answer_file_path}")
          {:ok, answer_file_path}

        {:error, reason} ->
          Logger.warning("Failed to write answer file: #{inspect(reason)}")
          {:error, reason}
      end
    else
      {:ok, :no_file_path}
    end
  end

  defp export_answer_file_content(%TemplateGeneration{} = gen) do
    """
    # Template Answer File
    # Generated by Singularity - DO NOT EDIT MANUALLY
    # To regenerate: mix template.regenerate #{gen.file_path}

    _template_id: #{gen.template_id}
    _template_version: #{gen.template_version}
    _generated_at: #{gen.generated_at}
    _success: #{gen.success}

    # Answers provided during generation:
    #{format_answers_as_yaml(gen.answers)}
    """
  end

  defp format_answers_as_yaml(answers) when is_map(answers) do
    answers
    |> Enum.map(fn {key, value} -> "#{key}: #{inspect(value)}" end)
    |> Enum.join("\n")
  end
end
```

### 2. Update QualityCodeGenerator

**No changes needed!** Since `TemplateGeneration.record/1` now automatically writes files.

### 3. Add Regeneration Support

**New file:** `lib/mix/tasks/template.regenerate.ex`

```elixir
defmodule Mix.Tasks.Template.Regenerate do
  use Mix.Task
  alias Singularity.{QualityCodeGenerator, Knowledge.TemplateGeneration}

  @shortdoc "Regenerate file from .template-answers.yml"

  def run([file_path]) do
    Mix.Task.run("app.start")

    answer_file = file_path <> ".template-answers.yml"

    with {:ok, answers_yaml} <- File.read(answer_file),
         {:ok, answers} <- parse_answer_file(answers_yaml),
         {:ok, generation} <- TemplateGeneration.find_by_file(file_path) do

      # Regenerate with same template but potentially updated answers
      {:ok, result} = QualityCodeGenerator.generate(
        task: answers["task"],
        language: answers["language"],
        quality: String.to_atom(answers["quality"]),
        output_path: file_path,
        # Use answers from file (might have been manually edited)
        template_answers: answers
      )

      Mix.shell().info("✅ Regenerated #{file_path}")
      Mix.shell().info("   Quality score: #{result.quality_score}")
    else
      {:error, :enoent} ->
        Mix.shell().error("❌ Answer file not found: #{answer_file}")
        Mix.shell().info("   Generate one with: TemplateGeneration.write_answer_file(file_path)")

      {:error, reason} ->
        Mix.shell().error("❌ Failed: #{inspect(reason)}")
    end
  end

  defp parse_answer_file(yaml) do
    # Parse YAML to map
    # TODO: Use YAML parser or simple string parsing
    {:ok, %{}}
  end
end
```

## File Location Strategy

### Option A: Next to Generated File (Recommended)

```
lib/
  my_genserver.ex
  my_genserver.ex.template-answers.yml  ← Answer file
  my_worker.ex
  my_worker.ex.template-answers.yml
```

**Pros:**
- Easy to find (same directory as generated file)
- Git tracks together
- Clear association

**Cons:**
- Clutters directories with .yml files

### Option B: Hidden Directory

```
lib/
  .template-answers/
    my_genserver.yml  ← Answer file
    my_worker.yml
  my_genserver.ex
  my_worker.ex
```

**Pros:**
- Cleaner directories
- All answers in one place

**Cons:**
- Hidden directory might be ignored
- Harder to discover

### Option C: Project Root

```
.template-answers/
  lib/my_genserver.yml
  lib/my_worker.yml
lib/
  my_genserver.ex
  my_worker.ex
```

**Pros:**
- Central location
- Easy to .gitignore or include

**Cons:**
- Far from generated files
- Complex path mapping

## Recommendation: **Option A** (next to file)

Most similar to Copier's approach and easiest to discover.

## Gitignore Strategy

**Option 1: Track answer files** (Recommended)
```gitignore
# Don't ignore - we want git history
# *.template-answers.yml
```

**Pros:**
- See what changed when template upgraded
- Collaborate on generation parameters
- Full history of template evolution

**Option 2: Ignore answer files**
```gitignore
*.template-answers.yml
```

**Pros:**
- Cleaner commits
- Only DB has authoritative data

**Cons:**
- Lose git history
- Can't manually edit and regenerate locally

## Implementation Timeline

**Phase 1 (30 min):** Add `write_answer_file/1` to TemplateGeneration
**Phase 2 (30 min):** Update `.gitignore` and test file creation
**Phase 3 (1h):** Add `mix template.regenerate` task
**Phase 4 (30 min):** Add `mix template.upgrade` to read answer files

**Total:** ~2.5h

## Example Workflow

### 1. Generate with tracking
```elixir
QualityCodeGenerator.generate(
  task: "User cache GenServer",
  language: "elixir",
  quality: :production,
  output_path: "lib/user_cache.ex"
)
```

### 2. Files created
```
lib/user_cache.ex                          ← Generated code
lib/user_cache.ex.template-answers.yml    ← Answer file (NEW!)
```

### 3. Inspect answer file
```bash
cat lib/user_cache.ex.template-answers.yml
```

Output:
```yaml
# Template Answer File
# Generated by Singularity - DO NOT EDIT MANUALLY
# To regenerate: mix template.regenerate lib/user_cache.ex

_template_id: quality_template:elixir-production
_template_version: 2.3.0
_generated_at: 2025-10-24T05:30:00Z
_success: true

# Answers provided during generation:
task: "User cache GenServer"
language: "elixir"
quality: :production
quality_score: 0.92
```

### 4. Template upgraded to v2.4.0

```bash
mix template.upgrade lib/user_cache.ex --to 2.4.0
```

Reads `.template-answers.yml`, re-asks new questions, regenerates code.

### 5. Manual edit + regenerate

```bash
vim lib/user_cache.ex.template-answers.yml  # Change quality: :production → :standard
mix template.regenerate lib/user_cache.ex   # Regenerate with new answer
```

## Summary

**Storage Strategy:**
- ✅ **Primary:** Database (fast queries, stats)
- ✅ **Secondary:** File system (git history, manual editing)

**File Naming:**
- ✅ `.template-answers.yml` (descriptive, not Copier-specific)

**File Location:**
- ✅ Next to generated file (e.g., `lib/file.ex.template-answers.yml`)

**Gitignore:**
- ✅ Track files (enables git history and collaboration)

**Next Action:**
Implement `write_answer_file/1` in TemplateGeneration module (30 min).
