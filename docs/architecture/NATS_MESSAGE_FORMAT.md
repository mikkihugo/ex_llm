# pgflow Message Format Specification

Complete specification for pgflow queue naming and message formats in Singularity's distributed architecture.

**Note:** This document has been updated from NATS subjects to pgflow queues as part of the migration from NATS to pgflow-based messaging.

## Table of Contents

1. [Overview](#overview)
2. [Queue Naming Convention](#queue-naming-convention)
3. [Message Format Standards](#message-format-standards)
4. [Intelligence Hub Messages](#intelligence-hub-messages)
5. [Pattern Learning Messages](#pattern-learning-messages)
6. [Package Intelligence Messages](#package-intelligence-messages)
7. [Training & Model Messages](#training--model-messages)
8. [Statistics & Metrics Messages](#statistics--metrics-messages)
9. [Subscription & Filtering](#subscription--filtering)
10. [Error Handling](#error-handling)
11. [Best Practices](#best-practices)

---

## Overview

Singularity uses **pgflow** (PostgreSQL-based messaging) for distributed messaging between:

- **Singularity instances** (local development environments)
- **Central Cloud** (global aggregation service)
- **Rust engines** (high-performance analysis)
- **AI Server** (LLM provider orchestration)

**Architecture:**

```
┌─────────────────┐
│ Singularity #1  │──┐
└─────────────────┘  │
                     │
┌─────────────────┐  │    ┌──────────────┐    ┌──────────────────┐
│ Singularity #2  │──┼───→│ NATS Server  │←──→│ Central Cloud    │
└─────────────────┘  │    └──────────────┘    └──────────────────┘
                     │           ↑
┌─────────────────┐  │           │
│ Singularity #3  │──┘           │
└─────────────────┘              ↓
                         ┌──────────────┐
                         │ Rust Engines │
                         └──────────────┘
```

**Message Flow Types:**

1. **Publish/Subscribe** - One-to-many broadcasts (patterns, insights)
2. **Request/Reply** - One-to-one queries (package lookup, knowledge request)
3. **Work Queue** - Distributed job processing (analysis tasks)

---

## Subject Naming Convention

### Hierarchical Structure

NATS subjects use **dot-separated hierarchy**:

```
<domain>.<subdomain>.<resource>.<action>
```

**Examples:**

```
intelligence.hub.architecture.analysis  # Domain: intelligence, Subdomain: hub
packages.storage.store                  # Domain: packages, Subdomain: storage
llm.provider.request                    # Domain: llm, Subdomain: provider
```

### Subject Patterns

#### Wildcards

- `*` - Single token wildcard
  - `intelligence.hub.*.analysis` matches:
    - `intelligence.hub.architecture.analysis`
    - `intelligence.hub.code.analysis`
    - `intelligence.hub.prompt.analysis`

- `>` - Multi-token wildcard (must be last)
  - `intelligence.hub.>` matches:
    - `intelligence.hub.architecture.analysis`
    - `intelligence.hub.package.index`
    - `intelligence.hub.knowledge.cache`

#### Request/Reply Pattern

Most services use **request/reply** subjects:

```
<service>.<operation>         # Request subject
<service>.<operation>.result  # Response subject (optional, can use reply_to)
```

**Example:**

```
# Request
Subject: intelligence.hub.package.query
Reply-To: _INBOX.abc123def456  # Auto-generated by NATS

# Response (sent to _INBOX.abc123def456)
Subject: _INBOX.abc123def456
```

---

## Message Format Standards

### Standard Message Envelope

All messages follow this JSON structure:

```json
{
  "type": "message_type",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "source": {
    "instance_id": "singularity-dev-001",
    "hostname": "localhost",
    "environment": "development"
  },
  "correlation_id": "req_abc123",
  "data": {
    // Message-specific payload
  },
  "metadata": {
    // Optional metadata
  }
}
```

**Fields:**

- `type` - Message type discriminator (e.g., "analysis", "package_index")
- `version` - Schema version for backwards compatibility
- `timestamp` - ISO 8601 UTC timestamp
- `source` - Origin of the message
- `correlation_id` - Trace requests across services
- `data` - Message payload (structure varies by type)
- `metadata` - Optional context (tags, environment, etc.)

### Request Message Format

```json
{
  "type": "request",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "correlation_id": "req_abc123",
  "request": {
    "query": "search_packages",
    "parameters": {
      "ecosystem": "npm",
      "pattern": "react-*"
    }
  },
  "timeout_ms": 5000
}
```

### Response Message Format

```json
{
  "type": "response",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:01Z",
  "correlation_id": "req_abc123",
  "success": true,
  "data": {
    // Response payload
  },
  "error": null
}
```

### Error Response Format

```json
{
  "type": "response",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:01Z",
  "correlation_id": "req_abc123",
  "success": false,
  "data": null,
  "error": {
    "code": "NOT_FOUND",
    "message": "Package not found",
    "details": {
      "ecosystem": "npm",
      "package_name": "nonexistent-package"
    }
  }
}
```

---

## Intelligence Hub Messages

Central Cloud subscribes to `intelligence.hub.*` to collect intelligence from all engines.

### Engine Analysis Results

**Subject:** `intelligence.hub.<engine>.analysis`

**Engines:**
- `architecture` - Architecture analysis
- `code` - Code analysis
- `embedding` - Vector embeddings
- `generator` - Code generation
- `parser` - Parsing results
- `prompt` - Prompt optimization
- `quality` - Quality analysis
- `knowledge` - Knowledge extraction

**Message Format:**

```json
{
  "type": "analysis",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "source": {
    "instance_id": "singularity-dev-001",
    "hostname": "localhost",
    "environment": "development"
  },
  "correlation_id": "analysis_abc123",
  "data": {
    "engine": "architecture",
    "analysis_type": "framework_detection",
    "file_path": "/path/to/project",
    "result": {
      "frameworks": [
        {
          "name": "Phoenix",
          "version": "1.7.0",
          "confidence": 0.98
        }
      ],
      "architecture_patterns": ["MVC", "CQRS"],
      "quality_score": 0.85
    },
    "metrics": {
      "execution_time_ms": 1234,
      "files_analyzed": 150,
      "lines_of_code": 15000
    }
  },
  "metadata": {
    "tags": ["framework-detection", "elixir"],
    "codebase_id": "my-project"
  }
}
```

**Example (Prompt Engine):**

```json
{
  "type": "analysis",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "source": {
    "instance_id": "singularity-dev-001",
    "engine": "prompt",
    "version": "0.1.0"
  },
  "correlation_id": "prompt_xyz789",
  "data": {
    "engine": "prompt",
    "analysis_type": "prompt_optimization",
    "prompt_id": "prompt_456",
    "result": {
      "original_tokens": 500,
      "optimized_tokens": 350,
      "improvement_percentage": 30.0,
      "optimized_prompt": "Analyze this code for...",
      "quality_metrics": {
        "clarity": 0.92,
        "specificity": 0.88
      }
    },
    "metrics": {
      "execution_time_ms": 250
    }
  }
}
```

### Engine Artifacts

**Subject:** `intelligence.hub.<engine>.artifact`

**Message Format:**

```json
{
  "type": "artifact",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "source": {
    "instance_id": "singularity-dev-001",
    "engine": "generator"
  },
  "correlation_id": "artifact_def456",
  "data": {
    "engine": "generator",
    "artifact_type": "generated_code",
    "artifact_id": "gen_123",
    "content": {
      "type": "generated_code",
      "language": "elixir",
      "code": "defmodule MyModule do\n  def hello, do: :world\nend",
      "context": {
        "description": "Basic Elixir module",
        "framework": "Phoenix",
        "pattern": "GenServer"
      },
      "metadata": {
        "generated_at": "2025-01-23T10:30:00Z",
        "generator_version": "0.1.0",
        "quality_score": 0.95
      }
    }
  },
  "metadata": {
    "tags": ["code-generation", "elixir", "genserver"]
  }
}
```

**Artifact Types:**

- `generated_code` - Code snippets
- `prompt_template` - Optimized prompts
- `test_suite` - Generated tests
- `documentation` - Generated docs
- `configuration` - Config files

### Package Indexing

**Subject:** `intelligence.hub.package.index`

**Message Format:**

```json
{
  "type": "package_index",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "source": {
    "instance_id": "singularity-dev-001"
  },
  "correlation_id": "pkg_index_123",
  "data": {
    "package": {
      "name": "phoenix",
      "version": "1.7.10",
      "ecosystem": "hex",
      "language": "elixir",
      "description": "Productive web framework",
      "repository": "https://github.com/phoenixframework/phoenix",
      "homepage": "https://www.phoenixframework.org",
      "license": "MIT",
      "dependencies": {
        "plug": "~> 1.14",
        "phoenix_html": "~> 3.3"
      },
      "quality_metrics": {
        "downloads_total": 5000000,
        "downloads_recent": 50000,
        "github_stars": 20000,
        "github_forks": 2500,
        "last_updated": "2024-11-15T00:00:00Z",
        "has_tests": true,
        "has_docs": true,
        "maintenance_score": 0.98
      },
      "analysis": {
        "framework_type": "web",
        "architecture_patterns": ["MVC", "Channels"],
        "use_cases": ["web-api", "real-time", "websockets"]
      }
    }
  },
  "metadata": {
    "indexed_at": "2025-01-23T10:30:00Z",
    "source": "hex.pm"
  }
}
```

### Package Query (Request/Reply)

**Request Subject:** `intelligence.hub.package.query`

**Request Format:**

```json
{
  "type": "package_query",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "correlation_id": "query_789",
  "request": {
    "package_name": "phoenix",
    "ecosystem": "hex",
    "version": "latest"
  }
}
```

**Response Format:**

```json
{
  "type": "response",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:01Z",
  "correlation_id": "query_789",
  "success": true,
  "data": {
    "package": {
      "name": "phoenix",
      "version": "1.7.10",
      "ecosystem": "hex",
      // ... full package data
    }
  },
  "error": null
}
```

### Knowledge Cache

**Subject:** `intelligence.hub.knowledge.cache`

**Message Format:**

```json
{
  "type": "knowledge_cache",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "source": {
    "instance_id": "singularity-dev-001"
  },
  "correlation_id": "cache_456",
  "data": {
    "knowledge": {
      "id": "pattern_123",
      "type": "pattern",
      "category": "architecture",
      "content": {
        "pattern": "CQRS",
        "description": "Command Query Responsibility Segregation",
        "implementation": "// Code example...",
        "language": "elixir",
        "framework": "Phoenix",
        "use_cases": ["event-sourcing", "scalability"]
      },
      "quality_metrics": {
        "success_rate": 0.95,
        "usage_count": 150,
        "last_used": "2025-01-23T10:00:00Z"
      }
    }
  },
  "metadata": {
    "tags": ["pattern", "cqrs", "architecture"]
  }
}
```

### Knowledge Request (Request/Reply)

**Request Subject:** `intelligence.hub.knowledge.request`

**Request Format:**

```json
{
  "type": "knowledge_request",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "correlation_id": "know_req_123",
  "request": {
    "knowledge_id": "pattern_123",
    "type": "pattern"
  }
}
```

**Response Format:**

```json
{
  "type": "response",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:01Z",
  "correlation_id": "know_req_123",
  "success": true,
  "data": {
    "knowledge": {
      "id": "pattern_123",
      "type": "pattern",
      // ... full knowledge data
    }
  },
  "error": null
}
```

### Vector Embeddings

**Subject:** `intelligence.hub.embeddings`

**Message Format:**

```json
{
  "type": "embedding",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "source": {
    "instance_id": "singularity-dev-001",
    "engine": "embedding"
  },
  "correlation_id": "embed_123",
  "data": {
    "embedding_id": "emb_abc123",
    "text": "Elixir GenServer implementation for...",
    "model": "text-embedding-004",
    "dimensions": 768,
    "vector": [0.123, -0.456, 0.789, /* ... 768 dimensions */],
    "metadata": {
      "language": "elixir",
      "context": "code_snippet",
      "source_file": "lib/my_module.ex"
    }
  }
}
```

---

## Pattern Learning Messages

Singularity instances publish learned patterns to Central Cloud for aggregation.

### Pattern Publishing (Singularity → Central Cloud)

**Subject:** `patterns.learned.<instance_id>`

**Message Format:**

```json
{
  "type": "pattern_learned",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "source": {
    "instance_id": "singularity-dev-001",
    "hostname": "localhost",
    "user": "developer",
    "environment": "development"
  },
  "correlation_id": "pattern_learn_123",
  "data": {
    "pattern": {
      "id": "pattern_abc123",
      "type": "code_pattern",
      "category": "error_handling",
      "language": "elixir",
      "framework": "Phoenix",
      "pattern_name": "with-clause-error-handling",
      "code_template": "with {:ok, result} <- operation() do\n  # Success\nelse\n  {:error, reason} -> {:error, reason}\nend",
      "context": {
        "description": "Elixir with-clause for error handling",
        "use_case": "Chaining multiple operations with early return",
        "alternatives": ["case/cond", "try/rescue"]
      },
      "quality_metrics": {
        "success_rate": 1.0,
        "usage_count": 25,
        "first_seen": "2025-01-15T00:00:00Z",
        "last_used": "2025-01-23T10:00:00Z",
        "confidence": 0.95
      },
      "occurrences": [
        {
          "file_path": "lib/my_app/service.ex",
          "line_range": [10, 15],
          "similarity": 0.98
        }
      ]
    }
  },
  "metadata": {
    "tags": ["elixir", "error-handling", "with-clause"],
    "codebase": "my-project"
  }
}
```

### Insight Broadcasting (Central Cloud → Singularities)

**Subject:** `insights.global.<category>`

**Categories:**
- `patterns` - Most common patterns
- `frameworks` - Trending frameworks
- `best_practices` - Emerging best practices
- `anti_patterns` - Common mistakes to avoid

**Message Format:**

```json
{
  "type": "global_insight",
  "version": "1.0",
  "timestamp": "2025-01-23T11:00:00Z",
  "source": {
    "service": "central-cloud",
    "hostname": "centralcloud.local"
  },
  "correlation_id": "insight_xyz789",
  "data": {
    "category": "patterns",
    "insight_type": "trending_pattern",
    "content": {
      "pattern_name": "with-clause-error-handling",
      "language": "elixir",
      "adoption_stats": {
        "total_instances": 50,
        "using_instances": 35,
        "adoption_rate": 0.70,
        "total_usages": 1250,
        "average_success_rate": 0.96
      },
      "recommendation": {
        "confidence": 0.92,
        "message": "This pattern is widely adopted with high success rate",
        "benefits": [
          "Clear error handling flow",
          "Reduces nested conditionals",
          "Improves code readability"
        ],
        "example": "with {:ok, user} <- get_user(id),\n     {:ok, profile} <- get_profile(user.id) do\n  {:ok, {user, profile}}\nend"
      }
    }
  },
  "metadata": {
    "aggregated_from_instances": 35,
    "time_period": "2025-01-16T00:00:00Z to 2025-01-23T00:00:00Z"
  }
}
```

### Pattern Subscription Filtering

Singularity instances can filter insights by:

```elixir
# Subscribe to all insights
NatsClient.subscribe("insights.global.>")

# Subscribe to specific categories
NatsClient.subscribe("insights.global.patterns")
NatsClient.subscribe("insights.global.frameworks")

# Filter in message handler
def handle_message(%{subject: "insights.global." <> category, data: data}) do
  case Jason.decode(data) do
    {:ok, %{"data" => %{"language" => "elixir"}}} ->
      # Only process Elixir insights
      process_insight(data)
    _ ->
      :ignore
  end
end
```

---

## Package Intelligence Messages

### Package Search Request

**Subject:** `packages.search`

**Request Format:**

```json
{
  "type": "package_search",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "correlation_id": "search_123",
  "request": {
    "query": "web framework",
    "ecosystems": ["npm", "cargo", "hex", "pypi"],
    "filters": {
      "min_downloads": 10000,
      "min_stars": 100,
      "languages": ["javascript", "elixir"],
      "updated_within_days": 365
    },
    "limit": 20,
    "offset": 0,
    "sort_by": "popularity"
  }
}
```

**Response Format:**

```json
{
  "type": "response",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:01Z",
  "correlation_id": "search_123",
  "success": true,
  "data": {
    "packages": [
      {
        "name": "express",
        "ecosystem": "npm",
        "version": "4.18.2",
        "description": "Fast, unopinionated web framework",
        "quality_score": 0.95,
        "relevance_score": 0.92
      },
      {
        "name": "phoenix",
        "ecosystem": "hex",
        "version": "1.7.10",
        "description": "Productive web framework",
        "quality_score": 0.98,
        "relevance_score": 0.90
      }
    ],
    "total_count": 150,
    "pagination": {
      "limit": 20,
      "offset": 0,
      "has_more": true
    }
  },
  "error": null
}
```

### Package Metadata Sync

**Subject:** `packages.sync.<ecosystem>`

**Ecosystems:** `npm`, `cargo`, `hex`, `pypi`

**Message Format:**

```json
{
  "type": "package_sync",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "source": {
    "service": "package-sync-worker",
    "ecosystem": "npm"
  },
  "correlation_id": "sync_npm_123",
  "data": {
    "sync_batch": {
      "batch_id": "batch_123",
      "ecosystem": "npm",
      "packages_synced": 1000,
      "packages_updated": 150,
      "packages_new": 50,
      "sync_duration_ms": 45000,
      "errors": []
    }
  },
  "metadata": {
    "next_sync_at": "2025-01-24T02:00:00Z"
  }
}
```

---

## Training & Model Messages

### Training Job Notification

**Subject:** `training.job.started`

**Message Format:**

```json
{
  "type": "training_started",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "source": {
    "instance_id": "singularity-dev-001",
    "gpu_id": "GPU-0"
  },
  "correlation_id": "train_abc123",
  "data": {
    "job": {
      "job_id": "job_123",
      "model_type": "t5-small",
      "task": "code_generation",
      "dataset": {
        "codebase_path": "/path/to/project",
        "files_count": 500,
        "total_lines": 50000
      },
      "config": {
        "batch_size": 8,
        "learning_rate": 0.001,
        "epochs": 10,
        "max_tokens": 512
      },
      "estimated_duration_minutes": 120
    }
  }
}
```

### Training Progress Update

**Subject:** `training.job.progress.<job_id>`

**Message Format:**

```json
{
  "type": "training_progress",
  "version": "1.0",
  "timestamp": "2025-01-23T10:45:00Z",
  "correlation_id": "train_abc123",
  "data": {
    "job_id": "job_123",
    "progress": {
      "epoch": 3,
      "total_epochs": 10,
      "step": 150,
      "total_steps": 500,
      "progress_percentage": 30.0,
      "metrics": {
        "loss": 0.45,
        "accuracy": 0.78,
        "learning_rate": 0.001
      },
      "estimated_time_remaining_minutes": 84
    }
  }
}
```

### Training Completion

**Subject:** `training.job.completed`

**Message Format:**

```json
{
  "type": "training_completed",
  "version": "1.0",
  "timestamp": "2025-01-23T12:30:00Z",
  "correlation_id": "train_abc123",
  "data": {
    "job_id": "job_123",
    "result": {
      "status": "success",
      "final_metrics": {
        "loss": 0.15,
        "accuracy": 0.95,
        "validation_loss": 0.18,
        "validation_accuracy": 0.92
      },
      "model_path": "/models/t5-small-code-gen-2025-01-23.bin",
      "model_size_mb": 242,
      "training_duration_minutes": 118,
      "checkpoints": [
        "/models/checkpoints/epoch_5.bin",
        "/models/checkpoints/epoch_10.bin"
      ]
    }
  },
  "metadata": {
    "gpu_hours": 1.97,
    "samples_processed": 50000
  }
}
```

---

## Statistics & Metrics Messages

### Instance Statistics

**Subject:** `stats.instance.<instance_id>`

**Message Format:**

```json
{
  "type": "instance_stats",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:00Z",
  "source": {
    "instance_id": "singularity-dev-001",
    "hostname": "localhost"
  },
  "correlation_id": "stats_123",
  "data": {
    "instance": {
      "uptime_seconds": 86400,
      "environment": "development",
      "version": "0.1.0"
    },
    "patterns": {
      "total_patterns": 1250,
      "patterns_learned_today": 15,
      "average_confidence": 0.89
    },
    "code_analysis": {
      "files_analyzed": 5000,
      "total_lines_analyzed": 500000,
      "frameworks_detected": ["Phoenix", "Ecto", "Broadway"]
    },
    "llm_usage": {
      "total_requests": 350,
      "total_tokens": 450000,
      "average_tokens_per_request": 1286,
      "total_cost_usd": 15.50
    },
    "performance": {
      "average_response_time_ms": 250,
      "cache_hit_rate": 0.85,
      "error_rate": 0.02
    }
  }
}
```

### Global Statistics

**Subject:** `stats.global.hourly`

**Message Format:**

```json
{
  "type": "global_stats",
  "version": "1.0",
  "timestamp": "2025-01-23T11:00:00Z",
  "source": {
    "service": "central-cloud"
  },
  "correlation_id": "global_stats_123",
  "data": {
    "time_period": {
      "start": "2025-01-23T10:00:00Z",
      "end": "2025-01-23T11:00:00Z"
    },
    "instances": {
      "total_instances": 50,
      "active_instances": 35,
      "inactive_instances": 15
    },
    "patterns": {
      "total_patterns": 50000,
      "new_patterns": 250,
      "most_common": [
        {"pattern": "with-clause-error-handling", "count": 1250},
        {"pattern": "genserver-state-machine", "count": 980}
      ]
    },
    "packages": {
      "total_indexed": 150000,
      "updated_today": 350,
      "trending": [
        {"name": "phoenix", "ecosystem": "hex", "growth": 0.15},
        {"name": "axum", "ecosystem": "cargo", "growth": 0.25}
      ]
    },
    "learning_efficiency": {
      "average_pattern_confidence": 0.91,
      "cross_instance_agreement": 0.87,
      "model_accuracy": 0.94
    }
  }
}
```

---

## Subscription & Filtering

### Subscribing to Messages

**Elixir (Gnat):**

```elixir
# Subscribe to all intelligence hub messages
{:ok, sid} = Gnat.sub(conn, self(), "intelligence.hub.>")

# Subscribe to specific engine
{:ok, sid} = Gnat.sub(conn, self(), "intelligence.hub.architecture.analysis")

# Subscribe to all patterns from specific instance
{:ok, sid} = Gnat.sub(conn, self(), "patterns.learned.singularity-dev-001")

# Subscribe to global insights
{:ok, sid} = Gnat.sub(conn, self(), "insights.global.>")
```

**Rust (async-nats):**

```rust
// Subscribe to package queries
let mut subscriber = client
    .subscribe("intelligence.hub.package.query".to_string())
    .await?;

while let Some(msg) = subscriber.next().await {
    let payload: PackageQuery = serde_json::from_slice(&msg.payload)?;
    // Process query
}
```

### Message Filtering

**Client-Side Filtering:**

```elixir
def handle_info({:msg, %{topic: topic, body: body}}, state) do
  case Jason.decode(body) do
    {:ok, %{"data" => data}} ->
      # Filter by language
      if data["language"] == "elixir" do
        process_message(data)
      end

      # Filter by confidence threshold
      if data["quality_metrics"]["confidence"] > 0.9 do
        store_high_confidence_pattern(data)
      end

      {:noreply, state}

    {:error, _} ->
      {:noreply, state}
  end
end
```

**Server-Side Filtering (Request/Reply):**

```elixir
# Request with filters
request = %{
  "type" => "package_search",
  "request" => %{
    "query" => "web framework",
    "filters" => %{
      "language" => "elixir",
      "min_stars" => 1000
    }
  }
}

{:ok, response} = NatsClient.request("packages.search", Jason.encode!(request))
```

---

## Error Handling

### Error Response Format

```json
{
  "type": "response",
  "version": "1.0",
  "timestamp": "2025-01-23T10:30:01Z",
  "correlation_id": "req_123",
  "success": false,
  "data": null,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message",
    "details": {
      // Error-specific context
    },
    "retryable": true,
    "retry_after_seconds": 60
  }
}
```

### Error Codes

| Code | Description | Retryable |
|------|-------------|-----------|
| `NOT_FOUND` | Resource not found | No |
| `INVALID_REQUEST` | Malformed request | No |
| `UNAUTHORIZED` | Authentication failed | No |
| `RATE_LIMITED` | Too many requests | Yes (with backoff) |
| `SERVICE_UNAVAILABLE` | Service down | Yes |
| `TIMEOUT` | Request timeout | Yes |
| `INTERNAL_ERROR` | Server error | Yes |
| `VALIDATION_ERROR` | Invalid data | No |
| `CONFLICT` | Resource conflict | No |
| `INSUFFICIENT_RESOURCES` | Out of capacity | Yes |

### Error Handling Example

```elixir
def handle_nats_response(response_json) do
  case Jason.decode(response_json) do
    {:ok, %{"success" => true, "data" => data}} ->
      {:ok, data}

    {:ok, %{"success" => false, "error" => error}} ->
      handle_error(error)

    {:error, decode_error} ->
      {:error, {:decode_failed, decode_error}}
  end
end

defp handle_error(%{"code" => "RATE_LIMITED", "retry_after_seconds" => seconds}) do
  # Exponential backoff
  Process.sleep(seconds * 1000)
  {:error, :rate_limited}
end

defp handle_error(%{"code" => "NOT_FOUND"}) do
  {:error, :not_found}
end

defp handle_error(%{"code" => code, "retryable" => true}) do
  {:error, {:retryable, code}}
end

defp handle_error(%{"code" => code}) do
  {:error, {:fatal, code}}
end
```

### Timeout Handling

```elixir
# Set timeout on request
case Gnat.request(conn, subject, payload, receive_timeout: 5_000) do
  {:ok, %{body: body}} ->
    {:ok, body}

  {:error, :timeout} ->
    Logger.warning("NATS request timeout", subject: subject)
    {:error, :timeout}

  {:error, reason} ->
    {:error, reason}
end
```

---

## Best Practices

### 1. Always Include Correlation IDs

```elixir
correlation_id = "req_#{:crypto.strong_rand_bytes(8) |> Base.encode16(case: :lower)}"

message = %{
  "type" => "analysis",
  "correlation_id" => correlation_id,
  "data" => %{...}
}
```

**Benefits:**
- Trace requests across services
- Debug distributed workflows
- Monitor end-to-end latency

### 2. Use ISO 8601 Timestamps

```elixir
timestamp = DateTime.utc_now() |> DateTime.to_iso8601()

message = %{
  "timestamp" => timestamp,  # "2025-01-23T10:30:00Z"
  "data" => %{...}
}
```

### 3. Version Your Message Schemas

```elixir
# V1 message
%{"type" => "analysis", "version" => "1.0", "data" => %{...}}

# V2 message (backwards compatible)
%{"type" => "analysis", "version" => "2.0", "data" => %{...}}

# Handler supports both
def handle_message(%{"version" => "1.0"} = msg), do: handle_v1(msg)
def handle_message(%{"version" => "2.0"} = msg), do: handle_v2(msg)
```

### 4. Validate Messages

```elixir
defmodule MessageValidator do
  def validate_analysis(message) do
    required_fields = ["type", "version", "timestamp", "data"]

    case Enum.all?(required_fields, &Map.has_key?(message, &1)) do
      true -> {:ok, message}
      false -> {:error, :invalid_message}
    end
  end
end
```

### 5. Handle Missing Fields Gracefully

```elixir
# Use Map.get with defaults
language = Map.get(data, "language", "unknown")
confidence = Map.get(data["quality_metrics"], "confidence", 0.0)

# Use pattern matching with defaults
def process(%{"data" => data}) do
  language = data["language"] || "unknown"
  # ...
end
```

### 6. Set Appropriate Timeouts

```elixir
# Quick queries: 5 seconds
Gnat.request(conn, "packages.search", payload, receive_timeout: 5_000)

# Heavy analysis: 30 seconds
Gnat.request(conn, "intelligence.hub.architecture.analysis", payload, receive_timeout: 30_000)

# ML training: 1 hour
Gnat.request(conn, "training.job.start", payload, receive_timeout: 3_600_000)
```

### 7. Use Request/Reply for Queries

```elixir
# ✅ GOOD: Request/Reply for queries
{:ok, response} = Gnat.request(conn, "packages.search", query)

# ❌ BAD: Publish for queries (no response!)
Gnat.pub(conn, "packages.search", query)
```

### 8. Use Publish for Events

```elixir
# ✅ GOOD: Publish for events (no response needed)
Gnat.pub(conn, "patterns.learned.dev-001", pattern_data)

# ❌ BAD: Request/Reply for events (wasteful)
Gnat.request(conn, "patterns.learned.dev-001", pattern_data)
```

### 9. Keep Messages Small

```elixir
# ❌ BAD: Embedding large binary data
%{"type" => "artifact", "data" => %{"code" => "<10MB of code>"}}

# ✅ GOOD: Reference external storage
%{"type" => "artifact", "data" => %{"s3_key" => "artifacts/abc123.tar.gz"}}
```

### 10. Log NATS Communication

```elixir
def publish(subject, data) do
  Logger.debug("NATS publish", subject: subject, size: byte_size(data))

  case Gnat.pub(conn, subject, data) do
    :ok ->
      Logger.info("NATS publish succeeded", subject: subject)
      :ok

    {:error, reason} ->
      Logger.error("NATS publish failed", subject: subject, reason: inspect(reason))
      {:error, reason}
  end
end
```

---

## Summary

**NATS Message Checklist:**

- ✅ Use hierarchical subject naming (`domain.subdomain.resource.action`)
- ✅ Include correlation IDs for tracing
- ✅ Use ISO 8601 timestamps
- ✅ Version message schemas
- ✅ Validate incoming messages
- ✅ Handle errors gracefully
- ✅ Set appropriate timeouts
- ✅ Use request/reply for queries, publish for events
- ✅ Keep messages small (< 1MB)
- ✅ Log all NATS communication
- ✅ Filter messages client-side when needed
- ✅ Support backwards compatibility

**Further Reading:**

- [NATS Subjects Documentation](../messaging/NATS_SUBJECTS.md)
- [Intelligence Hub Architecture](./FRAMEWORK_DETECTION_GUIDE.md)
- [Package Intelligence NATS](../../rust_global/package_registry/NATS_SUBJECTS.md)
