{
  "id": "typescript-api-endpoint-generator",
  "name": "TypeScript API Endpoint Generator",
  "description": "Generates TypeScript API endpoints using AI signatures optimized for LLM coders",
  "steps": [
    {
      "name": "sparc-phase-1-research",
      "operation": {
        "type": "generate",
        "generate": "sparc-research"
      }
    },
    {
      "name": "sparc-phase-2-architecture",
      "operation": {
        "type": "generate", 
        "generate": "sparc-architecture"
      }
    },
    {
      "name": "sparc-phase-3-security",
      "operation": {
        "type": "generate",
        "generate": "sparc-security"
      }
    },
    {
      "name": "sparc-phase-4-performance",
      "operation": {
        "type": "generate",
        "generate": "sparc-performance"
      }
    },
    {
      "name": "sparc-phase-5-implementation",
      "operation": {
        "type": "generate",
        "generate": "typescript-api-endpoint"
      }
    }
  ],
  "metadata": {
    "version": "1.0.0",
    "author": "SPARC Team",
    "created_at": "2024-01-15T10:00:00Z",
    "updated_at": "2024-01-15T10:00:00Z",
    "tags": ["typescript", "api", "express", "dspy", "llm-coder", "code-generation"],
    "performance": {
      "avg_execution_time_ms": 80.0,
      "memory_usage_bytes": 1572864,
      "complexity": 5
    }
  },
  "ai_signature": {
    "name": "typescript_api_endpoint_generator",
    "inputs": {
      "entity_name": "The entity name in camelCase (e.g., user, product)",
      "api_version": "API version (v1, v2, etc.)",
      "endpoint_type": "Endpoint type (rest, graphql, grpc)",
      "authentication": "Authentication method (jwt, api_key, oauth)",
      "validation_rules": "Input validation rules (required, optional, constraints)"
    },
    "outputs": {
      "typescript_code": "Generated TypeScript API endpoint code",
      "routes": "API route definitions",
      "middleware": "Authentication and validation middleware",
      "tests": "API endpoint tests"
    },
    "instruction": "Generate a complete TypeScript API endpoint with proper request/response handling, validation, authentication, error handling, and comprehensive tests. The code should be production-ready and optimized for LLM coders."
  },
  "template_content": "/**\n * @business-domain {{business_domain}}\n * @architecture-pattern api-endpoint\n * @architecture-layer presentation\n * @security-level {{security_level}}\n * @performance-profile {{performance_profile}}\n * @dspy-signature typescript_api_endpoint_generator\n * @llm-coder-optimized true\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { z } from 'zod';\nimport { Logger } from 'winston';\n\n/**\n * @business-entity {{EntityName}}Response\n * @architecture-pattern response-dto\n * @security-pattern data-transfer-object\n * @dspy-output typescript_code: response_interface\n */\nexport interface {{EntityName}}Response {\n  /** @business-field {{entityName}}Id */\n  id: string;\n  name: string;\n  status: string;\n  createdAt: string;\n}\n\n/**\n * @business-entity {{EntityName}}Request\n * @architecture-pattern request-dto\n * @security-pattern data-transfer-object\n * @dspy-output typescript_code: request_interface\n */\nexport interface {{EntityName}}Request {\n  /** @business-field {{entityName}}Name @security-validation input-sanitization */\n  name: string;\n}\n\n/**\n * @business-entity {{EntityName}}CreateRequestSchema\n * @architecture-pattern validation-schema\n * @security-pattern input-validation\n */\nexport const {{EntityName}}CreateRequestSchema = z.object({\n  name: z.string().min(1).max(255).trim(),\n});\n\nexport type {{EntityName}}CreateRequest = z.infer<typeof {{EntityName}}CreateRequestSchema>;\n\n/**\n * @business-operation get{{EntityName}}\n * @architecture-pattern controller\n * @security-operation data-retrieval\n * @performance-metric response-time\n * @test-scenario happy-path\n * @test-scenario not-found\n * @dspy-output typescript_code: endpoint_handler\n */\nexport async function get{{EntityName}}(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> {\n  const logger: Logger = req.app.get('logger');\n  const { id } = req.params;\n  \n  try {\n    logger.info('Getting {{entityName}} with id:', id);\n    \n    // @security-validation input-sanitization\n    // @performance-critical-section\n    const {{entityName}} = await {{entityName}}Service.getById(id);\n    \n    if (!{{entityName}}) {\n      logger.warn('{{EntityName}} not found:', id);\n      return res.status(404).json({\n        success: false,\n        message: '{{EntityName}} not found',\n        error: 'NOT_FOUND'\n      });\n    }\n    \n    const response: {{EntityName}}Response = {\n      id: {{entityName}}.id,\n      name: {{entityName}}.name,\n      status: 'active',\n      createdAt: {{entityName}}.createdAt.toISOString(),\n    };\n    \n    res.json({\n      success: true,\n      data: response\n    });\n  } catch (error) {\n    logger.error('Error getting {{entityName}}:', error);\n    next(error);\n  }\n}\n\n/**\n * @business-operation create{{EntityName}}\n * @architecture-pattern controller\n * @security-operation data-creation\n * @performance-metric response-time\n * @test-scenario happy-path\n * @test-scenario validation-error\n * @dspy-output typescript_code: endpoint_handler\n */\nexport async function create{{EntityName}}(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> {\n  const logger: Logger = req.app.get('logger');\n  \n  try {\n    logger.info('Creating {{entityName}} with data:', req.body);\n    \n    // @security-validation input-sanitization\n    const validatedData = {{EntityName}}CreateRequestSchema.parse(req.body);\n    \n    // @performance-critical-section\n    const {{entityName}} = await {{entityName}}Service.create(validatedData);\n    \n    const response: {{EntityName}}Response = {\n      id: {{entityName}}.id,\n      name: {{entityName}}.name,\n      status: 'active',\n      createdAt: {{entityName}}.createdAt.toISOString(),\n    };\n    \n    res.status(201).json({\n      success: true,\n      data: response,\n      message: '{{EntityName}} created successfully'\n    });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      logger.warn('Validation error creating {{entityName}}:', error.errors);\n      return res.status(400).json({\n        success: false,\n        message: 'Validation error',\n        errors: error.errors\n      });\n    }\n    \n    logger.error('Error creating {{entityName}}:', error);\n    next(error);\n  }\n}\n\n/**\n * @business-operation update{{EntityName}}\n * @architecture-pattern controller\n * @security-operation data-update\n * @performance-metric response-time\n * @test-scenario happy-path\n * @test-scenario not-found\n * @dspy-output typescript_code: endpoint_handler\n */\nexport async function update{{EntityName}}(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> {\n  const logger: Logger = req.app.get('logger');\n  const { id } = req.params;\n  \n  try {\n    logger.info('Updating {{entityName}} with id:', id, 'data:', req.body);\n    \n    // @security-validation input-sanitization\n    const validatedData = {{EntityName}}CreateRequestSchema.partial().parse(req.body);\n    \n    // @performance-critical-section\n    const {{entityName}} = await {{entityName}}Service.update(id, validatedData);\n    \n    if (!{{entityName}}) {\n      logger.warn('{{EntityName}} not found for update:', id);\n      return res.status(404).json({\n        success: false,\n        message: '{{EntityName}} not found'\n      });\n    }\n    \n    const response: {{EntityName}}Response = {\n      id: {{entityName}}.id,\n      name: {{entityName}}.name,\n      status: 'active',\n      createdAt: {{entityName}}.createdAt.toISOString(),\n    };\n    \n    res.json({\n      success: true,\n      data: response,\n      message: '{{EntityName}} updated successfully'\n    });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      logger.warn('Validation error updating {{entityName}}:', error.errors);\n      return res.status(400).json({\n        success: false,\n        message: 'Validation error',\n        errors: error.errors\n      });\n    }\n    \n    logger.error('Error updating {{entityName}}:', error);\n    next(error);\n  }\n}\n\n/**\n * @business-operation delete{{EntityName}}\n * @architecture-pattern controller\n * @security-operation data-deletion\n * @performance-metric response-time\n * @test-scenario happy-path\n * @test-scenario not-found\n * @dspy-output typescript_code: endpoint_handler\n */\nexport async function delete{{EntityName}}(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> {\n  const logger: Logger = req.app.get('logger');\n  const { id } = req.params;\n  \n  try {\n    logger.info('Deleting {{entityName}} with id:', id);\n    \n    // @security-validation input-sanitization\n    // @performance-critical-section\n    const deleted = await {{entityName}}Service.delete(id);\n    \n    if (!deleted) {\n      logger.warn('{{EntityName}} not found for deletion:', id);\n      return res.status(404).json({\n        success: false,\n        message: '{{EntityName}} not found'\n      });\n    }\n    \n    res.status(204).send();\n  } catch (error) {\n    logger.error('Error deleting {{entityName}}:', error);\n    next(error);\n  }\n}\n\n/**\n * @architecture-pattern router\n * @security-boundary api-gateway\n * @dspy-output routes: api_routes\n */\nexport function create{{EntityName}}Routes() {\n  const router = express.Router();\n  \n  router.get('/:id', get{{EntityName}});\n  router.post('/', create{{EntityName}});\n  router.put('/:id', update{{EntityName}});\n  router.delete('/:id', delete{{EntityName}});\n  \n  return router;\n}\n\n/**\n * @test-scenario happy-path\n * @dspy-output tests: api_test\n */\ndescribe('{{EntityName}} API Endpoints', () => {\n  let app: express.Application;\n  let mockLogger: jest.Mocked<Logger>;\n  \n  beforeEach(() => {\n    mockLogger = {\n      info: jest.fn(),\n      error: jest.fn(),\n      warn: jest.fn(),\n      debug: jest.fn(),\n    } as any;\n    \n    app = express();\n    app.use(express.json());\n    app.set('logger', mockLogger);\n    app.use('/{{entityName}}s', create{{EntityName}}Routes());\n  });\n\n  it('should get {{entityName}} successfully', async () => {\n    const response = await request(app)\n      .get('/{{entityName}}s/test-id')\n      .expect(200);\n    \n    expect(response.body.success).toBe(true);\n    expect(response.body.data).toBeDefined();\n  });\n\n  it('should create {{entityName}} successfully', async () => {\n    const {{entityName}}Data = { name: 'Test {{EntityName}}' };\n    \n    const response = await request(app)\n      .post('/{{entityName}}s')\n      .send({{entityName}}Data)\n      .expect(201);\n    \n    expect(response.body.success).toBe(true);\n    expect(response.body.data.name).toBe('Test {{EntityName}}');\n  });\n\n  it('should handle validation error', async () => {\n    const invalidData = { name: '' };\n    \n    const response = await request(app)\n      .post('/{{entityName}}s')\n      .send(invalidData)\n      .expect(400);\n    \n    expect(response.body.success).toBe(false);\n    expect(response.body.message).toBe('Validation error');\n  });\n});"
}
