{
  "name": "elixir-genserver-worker",
  "version": "1.0.0",
  "language": "elixir",
  "quality_level": "production",
  "description": "Production GenServer worker with supervision and telemetry",
  "template": "defmodule {{module_name}} do\n  use GenServer\n  require Logger\n\n  @moduledoc \"\"\"\n  {{description}}\n  \n  Supervised worker process with:\n  - Graceful shutdown\n  - Telemetry instrumentation\n  - Error recovery\n  - State persistence (optional)\n  \"\"\"\n\n  defstruct [:id, :state, :config, started_at: nil]\n\n  ## Client API\n\n  @doc \"\"\"\n  Starts the {{module_name}} worker.\n  \"\"\"\n  @spec start_link(keyword()) :: GenServer.on_start()\n  def start_link(opts) do\n    name = Keyword.get(opts, :name, __MODULE__)\n    GenServer.start_link(__MODULE__, opts, name: name)\n  end\n\n  @doc \"\"\"\n  Processes a job asynchronously.\n  \"\"\"\n  @spec process(GenServer.server(), term()) :: :ok\n  def process(server, job) do\n    GenServer.cast(server, {:process, job})\n  end\n\n  @doc \"\"\"\n  Gets the current worker state.\n  \"\"\"\n  @spec get_state(GenServer.server()) :: map()\n  def get_state(server) do\n    GenServer.call(server, :get_state)\n  end\n\n  ## Server Callbacks\n\n  @impl true\n  def init(opts) do\n    Process.flag(:trap_exit, true)\n    \n    state = %__MODULE__{\n      id: Keyword.get(opts, :id, make_ref()),\n      config: Keyword.get(opts, :config, %{}),\n      state: :idle,\n      started_at: DateTime.utc_now()\n    }\n\n    :telemetry.execute(\n      [:{{app_name}}, :worker, :started],\n      %{count: 1},\n      %{worker: __MODULE__}\n    )\n\n    {:ok, state}\n  end\n\n  @impl true\n  def handle_call(:get_state, _from, state) do\n    {:reply, state, state}\n  end\n\n  @impl true\n  def handle_cast({:process, job}, state) do\n    start_time = System.monotonic_time()\n\n    result = \n      case do_process(job, state) do\n        {:ok, result} ->\n          emit_telemetry(:success, start_time)\n          {:ok, result}\n        \n        {:error, reason} ->\n          Logger.error(\"Job processing failed: #{inspect(reason)}\")\n          emit_telemetry(:error, start_time)\n          {:error, reason}\n      end\n\n    {:noreply, %{state | state: :idle}}\n  end\n\n  @impl true\n  def terminate(reason, state) do\n    Logger.info(\"Worker terminating: #{inspect(reason)}\")\n    \n    :telemetry.execute(\n      [:{{app_name}}, :worker, :stopped],\n      %{count: 1},\n      %{worker: __MODULE__, reason: reason}\n    )\n    \n    :ok\n  end\n\n  ## Private Functions\n\n  defp do_process(job, state) do\n    # Process job logic here\n    {:ok, :processed}\n  end\n\n  defp emit_telemetry(status, start_time) do\n    duration = System.monotonic_time() - start_time\n    \n    :telemetry.execute(\n      [:{{app_name}}, :worker, :job],\n      %{duration: duration},\n      %{status: status}\n    )\n  end\nend",
  "variables": {
    "module_name": "MyApp.Worker",
    "app_name": "my_app",
    "description": "Background job worker process"
  },
  "supervisor_spec": "children = [\n  {{{module_name}}, name: {{module_name}}, config: %{}}\n]\n\nSupervisor.init(children, strategy: :one_for_one)"
}