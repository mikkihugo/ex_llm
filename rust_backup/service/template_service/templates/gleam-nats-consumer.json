{
  "id": "gleam-nats-consumer",
  "name": "Gleam NATS Consumer Generator",
  "description": "Generates type-safe Gleam NATS consumers with actor model",
  "steps": [
    {
      "name": "sparc-phase-1-research",
      "operation": {"type": "generate", "generate": "sparc-research"}
    },
    {
      "name": "sparc-phase-2-architecture",
      "operation": {"type": "generate", "generate": "sparc-architecture"}
    },
    {
      "name": "sparc-phase-5-implementation",
      "operation": {"type": "generate", "generate": "gleam-nats-consumer"}
    }
  ],
  "metadata": {
    "version": "1.0.0",
    "author": "SPARC Team",
    "created_at": "2025-10-04T00:00:00Z",
    "updated_at": "2025-10-04T00:00:00Z",
    "tags": ["gleam", "nats", "actor", "type-safe", "beam"],
    "performance": {
      "avg_execution_time_ms": 85.0,
      "memory_usage_bytes": 1572864,
      "complexity": 4
    }
  },
  "detector_signatures": {
    "package_files": ["gleam.toml"],
    "dependencies": ["gleam_erlang", "gleam_otp"],
    "file_patterns": ["src/**/*.gleam"],
    "code_patterns": [
      "import gleam/otp/actor",
      "actor.start",
      "import gnat"
    ],
    "min_confidence": 0.75
  },
  "ai_signature": {
    "name": "gleam_nats_consumer",
    "inputs": {
      "subject": "NATS subject pattern",
      "consumer_name": "Consumer module name",
      "message_type": "Message type definition"
    },
    "outputs": {
      "actor_code": "Actor implementation with type safety",
      "message_handlers": "Typed message handlers",
      "types": "Custom type definitions",
      "tests": "Gleam tests with mocks"
    },
    "instruction": "Generate production-ready Gleam NATS consumer with: (1) Actor-based concurrency with OTP, (2) Strong typing for messages, (3) Pattern matching for message handling, (4) Error handling with Result types, (5) Integration with Erlang NATS client, (6) Comprehensive tests. Follow Gleam best practices and leverage type system."
  },
  "template_content": "import gleam/erlang/process\nimport gleam/otp/actor\nimport gleam/io\nimport gleam/result\nimport gleam/string\nimport gleam/json\nimport gleam/dynamic\n\n/// Message type for {{subject}}\npub type {{MessageType}} {\n  {{MessageType}}(\n    id: String,\n    data: String,\n    timestamp: Int,\n  )\n}\n\n/// Consumer state\npub type State {\n  State(\n    nats_conn: process.Subject(String),\n    subject: String,\n    messages_processed: Int,\n  )\n}\n\n/// Consumer messages\npub type Message {\n  NatsMessage(body: String)\n  GetStats(reply_with: process.Subject(Int))\n  Shutdown\n}\n\n/// Start the consumer\npub fn start(subject: String) -> Result(process.Subject(Message), actor.StartError) {\n  let initial_state = State(\n    nats_conn: todo,  // Connect to NATS via Erlang interop\n    subject: subject,\n    messages_processed: 0,\n  )\n  \n  actor.start(initial_state, handle_message)\n}\n\n/// Handle incoming messages\nfn handle_message(message: Message, state: State) -> actor.Next(Message, State) {\n  case message {\n    NatsMessage(body) -> {\n      // Parse and process message\n      case parse_message(body) {\n        Ok(msg) -> {\n          io.println(\"Processing message: \" <> msg.id)\n          \n          // TODO: Implement message processing logic\n          let new_state = State(\n            ..state,\n            messages_processed: state.messages_processed + 1,\n          )\n          \n          actor.continue(new_state)\n        }\n        \n        Error(err) -> {\n          io.println(\"Failed to parse message: \" <> err)\n          actor.continue(state)\n        }\n      }\n    }\n    \n    GetStats(reply_with) -> {\n      process.send(reply_with, state.messages_processed)\n      actor.continue(state)\n    }\n    \n    Shutdown -> {\n      io.println(\"Shutting down {{consumer_name}} consumer\")\n      actor.Stop(process.Normal)\n    }\n  }\n}\n\n/// Parse message from JSON\nfn parse_message(body: String) -> Result({{MessageType}}, String) {\n  // Use json.decode with dynamic decoders\n  json.decode(body, message_decoder())\n  |> result.map_error(fn(_) { \"Invalid JSON\" })\n}\n\n/// JSON decoder for {{MessageType}}\nfn message_decoder() -> dynamic.Decoder({{MessageType}}) {\n  dynamic.decode3(\n    {{MessageType}},\n    dynamic.field(\"id\", dynamic.string),\n    dynamic.field(\"data\", dynamic.string),\n    dynamic.field(\"timestamp\", dynamic.int),\n  )\n}\n\n// Test module\nimport gleeunit\nimport gleeunit/should\n\npub fn main() {\n  gleeunit.main()\n}\n\npub fn parse_valid_message_test() {\n  let json = \"{\\\"id\\\": \\\"123\\\", \\\"data\\\": \\\"test\\\", \\\"timestamp\\\": 1234567890}\"\n  \n  parse_message(json)\n  |> should.be_ok\n}\n\npub fn parse_invalid_message_test() {\n  let json = \"invalid json\"\n  \n  parse_message(json)\n  |> should.be_error\n}\n"
}
