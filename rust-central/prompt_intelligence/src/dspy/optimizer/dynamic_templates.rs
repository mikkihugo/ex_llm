//! Dynamic Template Generation for SPARC DSPy
//!
//! AI-generated templates that adapt based on context, memory, and previous runs
//! to continuously improve SPARC methodology execution.

use std::collections::HashMap;

use anyhow::Result;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

use super::{sparc_coordinator::SessionType, sparc_optimizer::SPARCPhase};
use crate::dspy_data::ConversationHistory;

/// Dynamic template that evolves based on AI-generated insights
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DynamicTemplate {
  /// Template identifier
  pub template_id: String,
  /// Current template content
  pub content: String,
  /// AI-generated context that influenced this template
  pub ai_context: AIGeneratedContext,
  /// Memory of successful patterns
  pub memory_patterns: Vec<SuccessCodePattern>,
  /// Performance metrics for this template
  pub performance_score: f64,
  /// Number of times this template has been used
  pub usage_count: u32,
  /// Last time template was updated
  pub last_updated: DateTime<Utc>,
}

/// AI-generated context that shapes templates
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AIGeneratedContext {
  /// Domain-specific insights generated by AI
  pub domain_insights: Vec<String>,
  /// CodePatterns the AI observed from successful runs
  pub observed_patterns: Vec<String>,
  /// AI's suggestions for template improvements
  pub improvement_suggestions: Vec<String>,
  /// Context about current project/codebase
  pub project_context: HashMap<String, String>,
  /// User/team preferences learned by AI
  pub learned_preferences: HashMap<String, String>,
}

/// Successful pattern remembered from previous runs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuccessCodePattern {
  /// Description of what made this pattern successful
  pub pattern_description: String,
  /// Template fragment that worked well
  pub template_fragment: String,
  /// Context where this pattern was successful
  pub success_context: HashMap<String, String>,
  /// Performance score when this pattern was used
  pub success_score: f64,
  /// Frequency of successful use
  pub frequency: u32,
}

/// Template generator that uses AI to create dynamic templates
#[derive(Debug)]
pub struct DynamicTemplateGenerator {
  /// Cache of generated templates
  template_cache: HashMap<String, DynamicTemplate>,
  /// Memory of all successful patterns across projects
  global_memory: Vec<SuccessCodePattern>,
  /// AI-generated insights about template effectiveness
  ai_insights: AIGeneratedContext,
}

impl DynamicTemplateGenerator {
  /// Create new dynamic template generator
  pub fn new() -> Self {
    Self {
      template_cache: HashMap::new(),
      global_memory: Vec::new(),
      ai_insights: AIGeneratedContext {
        domain_insights: Vec::new(),
        observed_patterns: Vec::new(),
        improvement_suggestions: Vec::new(),
        project_context: HashMap::new(),
        learned_preferences: HashMap::new(),
      },
    }
  }

  /// Use AI insights to enhance template generation
  pub fn apply_ai_insights(&self, base_template: &str) -> String {
    let insights_summary = self.ai_insights.improvement_suggestions.iter().map(|suggestion| format!("- {}", suggestion)).collect::<Vec<_>>().join("\n");

    if !insights_summary.is_empty() {
      format!("{}\n\n## AI Insights\n{}\n", base_template, insights_summary)
    } else {
      base_template.to_string()
    }
  }

  /// Generate dynamic template for specific SPARC phase and session type
  pub async fn generate_template(
    &mut self,
    phase: &SPARCPhase,
    session_type: &SessionType,
    context: &HashMap<String, String>,
    memory_context: Option<&ConversationHistory>,
  ) -> Result<DynamicTemplate> {
    let template_key = format!("{:?}_{:?}", phase, session_type);

    // Check if we have a recent template
    if let Some(existing) = self.template_cache.get(&template_key) {
      if existing.last_updated > Utc::now() - chrono::Duration::hours(6) {
        return Ok(existing.clone());
      }
    }

    // Generate AI context for template creation
    let ai_context = self.generate_ai_context(phase, session_type, context, memory_context).await?;

    // Create base template content
    let base_content = self.create_base_template_content(phase, session_type);

    // Enhance template with AI insights
    let enhanced_content = self.enhance_with_ai_insights(&base_content, &ai_context).await?;

    // Apply memory patterns
    let final_content = self.apply_memory_patterns(&enhanced_content, phase, session_type);

    // Create dynamic template
    let template = DynamicTemplate {
      template_id: template_key.clone(),
      content: final_content,
      ai_context,
      memory_patterns: self.get_relevant_patterns(phase, session_type),
      performance_score: 0.8, // Initial score
      usage_count: 0,
      last_updated: Utc::now(),
    };

    // Cache the template
    self.template_cache.insert(template_key, template.clone());

    Ok(template)
  }

  /// Generate AI context by analyzing current situation
  async fn generate_ai_context(
    &self,
    phase: &SPARCPhase,
    session_type: &SessionType,
    context: &HashMap<String, String>,
    memory_context: Option<&ConversationHistory>,
  ) -> Result<AIGeneratedContext> {
    // Build context analysis prompt
    let analysis_prompt = self.build_context_analysis_prompt(phase, session_type, context, memory_context);

    // For now, return a placeholder response
    // The actual LLM integration will be handled by the main sparc-engine
    let ai_response = format!("AI Analysis for phase: {:?} with context: {}", phase, analysis_prompt);

    // Parse AI response into structured insights
    self.parse_ai_insights(&ai_response, context)
  }

  /// Build prompt for AI to analyze context
  fn build_context_analysis_prompt(
    &self,
    phase: &SPARCPhase,
    session_type: &SessionType,
    context: &HashMap<String, String>,
    memory_context: Option<&ConversationHistory>,
  ) -> String {
    let mut prompt = String::new();

    prompt.push_str("ðŸ§  DYNAMIC TEMPLATE ANALYSIS\n\n");
    prompt.push_str("Analyze the following context to generate insights for dynamic template creation:\n\n");

    // Add phase and session context
    prompt.push_str(&format!("SPARC Phase: {:?}\nSession Type: {:?}\n\n", phase, session_type));

    // Add project context
    if !context.is_empty() {
      prompt.push_str("Project Context:\n");
      for (key, value) in context {
        prompt.push_str(&format!("- {}: {}\n", key, value));
      }
      prompt.push('\n');
    }

    // Add conversation memory if available
    if let Some(memory) = memory_context {
      prompt.push_str("Recent Conversation CodePatterns:\n");
      for message in memory.messages.iter().rev().take(5) {
        let preview = message.content.chars().take(150).collect::<String>();
        prompt.push_str(&format!("- {}: {}\n", message.role, preview));
      }
      prompt.push('\n');
    }

    // Add successful patterns from memory
    if !self.global_memory.is_empty() {
      prompt.push_str("Previously Successful CodePatterns:\n");
      for pattern in self.global_memory.iter().take(3) {
        prompt.push_str(&format!("- {} (score: {:.2})\n", pattern.pattern_description, pattern.success_score));
      }
      prompt.push('\n');
    }

    prompt.push_str("Generate insights for template optimization:\n");
    prompt.push_str("1. DOMAIN_INSIGHTS: What domain-specific knowledge should influence the template?\n");
    prompt.push_str("2. OBSERVED_PATTERNS: What patterns do you see that could improve effectiveness?\n");
    prompt.push_str("3. IMPROVEMENT_SUGGESTIONS: How should the template be customized for this context?\n");
    prompt.push_str("4. PROJECT_CONTEXT: What project-specific elements should be emphasized?\n");
    prompt.push_str("5. LEARNED_PREFERENCES: What user/team preferences should be considered?\n\n");

    prompt.push_str("Format your response as:\n");
    prompt.push_str("DOMAIN_INSIGHTS:\n- [insight 1]\n- [insight 2]\n\n");
    prompt.push_str("OBSERVED_PATTERNS:\n- [pattern 1]\n- [pattern 2]\n\n");
    prompt.push_str("And so on for each category.");

    prompt
  }

  /// Parse AI response into structured insights
  fn parse_ai_insights(&self, ai_response: &str, context: &HashMap<String, String>) -> Result<AIGeneratedContext> {
    let mut insights = AIGeneratedContext {
      domain_insights: Vec::new(),
      observed_patterns: Vec::new(),
      improvement_suggestions: Vec::new(),
      project_context: context.clone(),
      learned_preferences: HashMap::new(),
    };

    // Parse structured response
    let lines: Vec<&str> = ai_response.lines().collect();
    let mut current_section = "";

    for line in lines {
      let line = line.trim();

      if line.starts_with("DOMAIN_INSIGHTS:") {
        current_section = "domain";
      } else if line.starts_with("OBSERVED_PATTERNS:") {
        current_section = "patterns";
      } else if line.starts_with("IMPROVEMENT_SUGGESTIONS:") {
        current_section = "improvements";
      } else if line.starts_with("PROJECT_CONTEXT:") {
        current_section = "project";
      } else if line.starts_with("LEARNED_PREFERENCES:") {
        current_section = "preferences";
      } else if line.starts_with("- ") && !line.is_empty() {
        let content = line[2..].to_string();

        match current_section {
          "domain" => insights.domain_insights.push(content),
          "patterns" => insights.observed_patterns.push(content),
          "improvements" => insights.improvement_suggestions.push(content),
          "project" => {
            // Parse key: value format for project context
            if let Some(colon_pos) = content.find(':') {
              let key = content[..colon_pos].trim().to_string();
              let value = content[colon_pos + 1..].trim().to_string();
              insights.project_context.insert(key, value);
            }
          }
          "preferences" => {
            // Parse key: value format for preferences
            if let Some(colon_pos) = content.find(':') {
              let key = content[..colon_pos].trim().to_string();
              let value = content[colon_pos + 1..].trim().to_string();
              insights.learned_preferences.insert(key, value);
            }
          }
          _ => {}
        }
      }
    }

    Ok(insights)
  }

  /// Create base template content for phase/session combination
  fn create_base_template_content(&self, phase: &SPARCPhase, session_type: &SessionType) -> String {
    match (phase, session_type) {
            (SPARCPhase::Specification, SessionType::Analysis) => {
                "ðŸŽ¯ SPARC SPECIFICATION ANALYSIS\n\nSystematically analyze requirements:\n{task}\n\nConsider:\n- Functional requirements\n- Non-functional requirements\n- Constraints and assumptions\n- Success criteria".to_string()
            }
            (SPARCPhase::Architecture, SessionType::Design) => {
                "ðŸ—ï¸ SPARC ARCHITECTURE DESIGN\n\nDesign system architecture:\n{task}\n\nFocus on:\n- Component structure\n- Interface definitions\n- Data flow patterns\n- Scalability considerations".to_string()
            }
            (SPARCPhase::Completion, SessionType::Implementation) => {
                "ðŸ”§ SPARC IMPLEMENTATION\n\nImplement with PrimeCode standards:\n{task}\n\nEnsure:\n- TypeScript strict compliance\n- EventBus integration\n- Error handling\n- Enterprise patterns".to_string()
            }
            _ => {
                format!("ðŸŽ¯ SPARC {:?} - {:?}\n\nExecute task systematically:\n{{task}}\n\nApply SPARC methodology principles.", phase, session_type)
            }
        }
  }

  /// Enhance template with AI-generated insights
  async fn enhance_with_ai_insights(&self, base_content: &str, ai_context: &AIGeneratedContext) -> Result<String> {
    let enhancement_prompt = format!(
      "ðŸ§  TEMPLATE ENHANCEMENT\n\nEnhance this base template with AI insights:\n\nBASE TEMPLATE:\n{}\n\nAI INSIGHTS:\n\nDomain Insights:\n{}\n\nObserved CodePatterns:\n{}\n\nImprovement Suggestions:\n{}\n\nCreate an enhanced template that:\n1. Incorporates the domain insights\n2. Applies the observed patterns\n3. Implements the improvement suggestions\n4. Maintains the original structure\n5. Uses dynamic placeholders like {{task}}, {{context}}, etc.\n\nReturn ONLY the enhanced template content:",
      base_content,
      ai_context.domain_insights.join("\n"),
      ai_context.observed_patterns.join("\n"),
      ai_context.improvement_suggestions.join("\n")
    );

    // This will be called with the actual LLM function from sparc-engine
    // For now, return a placeholder that shows the enhancement logic
    let enhanced = format!("Enhanced template based on: {}", enhancement_prompt);

    Ok(enhanced)
  }

  /// Apply memory patterns to template
  fn apply_memory_patterns(&self, content: &str, phase: &SPARCPhase, session_type: &SessionType) -> String {
    let mut enhanced_content = content.to_string();

    // Find relevant patterns for this phase/session combination
    let relevant_patterns = self.get_relevant_patterns(phase, session_type);

    // Apply high-performing patterns
    for pattern in relevant_patterns.iter().filter(|p| p.success_score > 0.8) {
      // Insert successful pattern fragments where appropriate
      if enhanced_content.contains("Consider:") && pattern.template_fragment.contains("Consider") {
        enhanced_content = enhanced_content.replace("Consider:", &format!("Consider ({} pattern):", pattern.pattern_description));
      }
    }

    enhanced_content
  }

  /// Get patterns relevant to current phase/session
  fn get_relevant_patterns(&self, phase: &SPARCPhase, session_type: &SessionType) -> Vec<SuccessCodePattern> {
    self
      .global_memory
      .iter()
      .filter(|pattern| {
        pattern.success_context.get("phase") == Some(&format!("{:?}", phase))
          || pattern.success_context.get("session_type") == Some(&format!("{:?}", session_type))
      })
      .cloned()
      .collect()
  }

  /// Record successful template usage for future learning
  pub fn record_success(&mut self, template: &DynamicTemplate, performance_score: f64, context: HashMap<String, String>) {
    // Create success pattern from this usage
    let pattern = SuccessCodePattern {
      pattern_description: format!("Template {} pattern", template.template_id),
      template_fragment: template.content.clone(),
      success_context: context,
      success_score: performance_score,
      frequency: 1,
    };

    // Add to global memory
    self.global_memory.push(pattern);

    // Keep only top-performing patterns (limit memory size)
    self.global_memory.sort_by(|a, b| b.success_score.partial_cmp(&a.success_score).unwrap());
    self.global_memory.truncate(100); // Keep top 100 patterns
  }

  /// Update template based on usage feedback
  pub fn update_template_performance(&mut self, template_id: &str, new_score: f64) {
    if let Some(template) = self.template_cache.get_mut(template_id) {
      // Update performance using exponential moving average
      let alpha = 0.3; // Learning rate
      template.performance_score = alpha * new_score + (1.0 - alpha) * template.performance_score;
      template.usage_count += 1;
      template.last_updated = Utc::now();
    }
  }

  /// Get best template for given criteria
  pub fn get_best_template(&self, phase: &SPARCPhase, session_type: &SessionType) -> Option<&DynamicTemplate> {
    let template_key = format!("{:?}_{:?}", phase, session_type);
    self.template_cache.get(&template_key)
  }
}

impl Default for DynamicTemplateGenerator {
  fn default() -> Self {
    Self::new()
  }
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_template_generator_creation() {
    let generator = DynamicTemplateGenerator::new();
    assert!(generator.template_cache.is_empty());
    assert!(generator.global_memory.is_empty());
  }

  #[test]
  fn test_success_pattern_recording() {
    let mut generator = DynamicTemplateGenerator::new();

    let template = DynamicTemplate {
      template_id: "test".to_string(),
      content: "test content".to_string(),
      ai_context: AIGeneratedContext {
        domain_insights: vec![],
        observed_patterns: vec![],
        improvement_suggestions: vec![],
        project_context: HashMap::new(),
        learned_preferences: HashMap::new(),
      },
      memory_patterns: vec![],
      performance_score: 0.8,
      usage_count: 1,
      last_updated: Utc::now(),
    };

    generator.record_success(&template, 0.9, HashMap::new());
    assert_eq!(generator.global_memory.len(), 1);
  }
}
