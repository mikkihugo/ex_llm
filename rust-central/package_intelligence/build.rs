use std::fs;
use std::fmt::Write;
use std::path::Path;

fn main() {
    let templates_dir = Path::new("templates");
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let generated_file = Path::new(&out_dir).join("ai_templates.rs");
    
    if !templates_dir.exists() {
        println!("cargo:warning=Templates directory not found, skipping template generation");
        return;
    }
    
    let mut generated_code = String::new();
    generated_code.push_str("// Auto-generated AI templates from JSON files\n");
    generated_code.push_str("// Do not edit this file manually\n\n");
    generated_code.push_str("use serde_json::Value;\n\n");
    
    // Collect all JSON files recursively
    let mut json_files = Vec::new();
    collect_json_files(templates_dir, &mut json_files);
    
    for path in &json_files {
        let file_name = path.file_stem()
            .and_then(|s| s.to_str())
            .expect("Invalid file name");
        
        println!("cargo:rerun-if-changed={}", path.display());
        
        // Read JSON content
        let json_content = fs::read_to_string(path)
            .unwrap_or_else(|_| panic!("Failed to read template file: {}", path.display()));
        
        // Generate Rust function for this template
        // Create unique function name by including relative path
        let relative_path = path.strip_prefix(templates_dir)
            .expect("Path should be under templates directory");
        let path_str = relative_path.to_string_lossy();
        let function_name = path_str
            .replace('/', "_")
            .replace('-', "_")
            .replace('.', "_")
            .replace("__", "_")  // Remove double underscores
            .to_lowercase();
        let template_id = file_name;
        
        writeln!(generated_code, "/// Generated template function for {template_id}").unwrap();
        writeln!(generated_code, "pub fn create_{function_name}_template() -> Template {{").unwrap();
        generated_code.push_str("    let json_content = \"");
        // Properly escape the JSON content for string literals
        let escaped_content = json_content
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n")
            .replace('\r', "\\r")
            .replace('\t', "\\t");
        generated_code.push_str(&escaped_content);
        generated_code.push_str("\";\n\n");
        
        generated_code.push_str("    let template_data: Value = serde_json::from_str(json_content)\n");
        generated_code.push_str("        .expect(\"Failed to parse template JSON\");\n\n");
        
        generated_code.push_str("    Template {\n");
        generated_code.push_str("        id: template_data[\"id\"].as_str().unwrap().to_string(),\n");
        generated_code.push_str("        name: template_data[\"name\"].as_str().unwrap().to_string(),\n");
        generated_code.push_str("        description: template_data[\"description\"].as_str().unwrap().to_string(),\n");
        generated_code.push_str("        steps: serde_json::from_value(template_data[\"steps\"].clone()).unwrap(),\n");
        generated_code.push_str("        metadata: TemplateMetadata {\n");
        generated_code.push_str("            version: template_data[\"metadata\"][\"version\"].as_str().unwrap().to_string(),\n");
        generated_code.push_str("            author: template_data[\"metadata\"][\"author\"].as_str().unwrap().to_string(),\n");
        generated_code.push_str("            created_at: template_data[\"metadata\"][\"created_at\"].as_str().unwrap().to_string(),\n");
        generated_code.push_str("            updated_at: template_data[\"metadata\"][\"updated_at\"].as_str().unwrap().to_string(),\n");
        generated_code.push_str("            tags: serde_json::from_value(template_data[\"metadata\"][\"tags\"].clone()).unwrap(),\n");
        generated_code.push_str("            performance: PerformanceProfile {\n");
        generated_code.push_str("                avg_execution_time_ms: template_data[\"metadata\"][\"performance\"][\"avg_execution_time_ms\"].as_f64().unwrap(),\n");
        generated_code.push_str("                memory_usage_bytes: template_data[\"metadata\"][\"performance\"][\"memory_usage_bytes\"].as_u64().unwrap() as usize,\n");
        generated_code.push_str("                complexity: template_data[\"metadata\"][\"performance\"][\"complexity\"].as_u64().unwrap() as u8,\n");
        generated_code.push_str("            },\n");
        generated_code.push_str("        },\n");
        generated_code.push_str("        ai_signature: serde_json::from_value(template_data.get(\"ai_signature\").cloned().unwrap_or(Value::Null)).ok(),\n");
        generated_code.push_str("        template_content: template_data.get(\"template_content\").and_then(|v| v.as_str()).map(|s| s.to_string()),\n");
        generated_code.push_str("        extends: None,\n");
        generated_code.push_str("        compose: None,\n");
        generated_code.push_str("        workflows: None,\n");
        generated_code.push_str("    }\n");
        generated_code.push_str("}\n\n");
    }
    
    // Generate the registry function
    generated_code.push_str("/// Get all AI templates\n");
    generated_code.push_str("pub fn get_ai_templates() -> Vec<Template> {\n");
    generated_code.push_str("    vec![\n");
    
    // Add all template function calls
    for path in &json_files {
        // Create unique function name by including relative path
        let relative_path = path.strip_prefix(templates_dir)
            .expect("Path should be under templates directory");
        let path_str = relative_path.to_string_lossy();
        let function_name = path_str
            .replace('/', "_")
            .replace('-', "_")
            .replace('.', "_")
            .replace("__", "_")  // Remove double underscores
            .to_lowercase();
        writeln!(generated_code, "        create_{function_name}_template(),").unwrap();
    }
    
    generated_code.push_str("    ]\n");
    generated_code.push_str("}\n");
    
    // Write the generated file
    fs::write(&generated_file, generated_code)
        .expect("Failed to write generated template file");
    
    println!("cargo:warning=Generated AI templates: {}", generated_file.display());
}

/// Recursively collect all JSON files from a directory
fn collect_json_files(dir: &Path, json_files: &mut Vec<std::path::PathBuf>) {
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries {
            if let Ok(entry) = entry {
                let path = entry.path();
                if path.is_dir() {
                    // Recursively search subdirectories
                    collect_json_files(&path, json_files);
                } else if path.extension().and_then(|s| s.to_str()) == Some("json") {
                    json_files.push(path);
                }
            }
        }
    }
}
