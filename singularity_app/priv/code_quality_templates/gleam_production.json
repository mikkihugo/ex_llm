{
  "name": "Gleam Production Quality",
  "spec_version": "2.0",
  "capabilities": [
    "quality",
    "graph",
    "rag"
  ],
  "language": "gleam",
  "quality_level": "production",
  "description": "Production standards for Gleam - type-safe BEAM language",
  "requirements": {
    "documentation": {
      "module_docs": {
        "required": true,
        "format": "//// module documentation",
        "must_include": [
          "overview",
          "examples"
        ]
      },
      "function_docs": {
        "required": true,
        "format": "/// function documentation",
        "must_include": [
          "description",
          "examples"
        ]
      }
    },
    "type_safety": {
      "explicit_types": "encouraged",
      "exhaustive_patterns": "required",
      "no_dynamic": true
    },
    "error_handling": {
      "style": "Result(a, e)",
      "pattern": "Ok(value) | Error(reason)",
      "use_try": "for_chaining_results"
    },
    "testing": {
      "required": true,
      "framework": "gleeunit",
      "test_types": [
        "unit_tests",
        "property_tests"
      ]
    },
    "code_style": {
      "naming": "snake_case",
      "immutability": "enforced",
      "pattern_matching": "preferred"
    }
  },
  "semantic_patterns": {
    "common_patterns": [
      {
        "pattern": "HTTP API",
        "pseudocode": "request → parse_body → validate → process → to_json_response",
        "relationships": [
          "Result types",
          "custom types for domains",
          "pipelines"
        ],
        "keywords": [
          "request",
          "response",
          "api",
          "json",
          "decode"
        ]
      },
      {
        "pattern": "OTP GenServer equivalent",
        "pseudocode": "Actor → State → handle_message(state, msg) → #(new_state, reply)",
        "relationships": [
          "message passing",
          "state updates",
          "gleam/otp"
        ],
        "keywords": [
          "actor",
          "state",
          "message",
          "handle"
        ]
      },
      {
        "pattern": "Data transformation",
        "pseudocode": "input |> validate |> transform |> encode",
        "relationships": [
          "pipeline operator",
          "Result chaining with use",
          "custom types"
        ],
        "keywords": [
          "pipeline",
          "transform",
          "map",
          "decode"
        ]
      }
    ],
    "relationship_vectors": {
      "result_chaining": "use value <- result.try(operation()) → early_return_on_Error",
      "custom_types": "type MyType { Variant1(Int) Variant2(String) } → exhaustive_matching",
      "pipeline": "value |> function1 |> function2 |> function3",
      "actor_model": "process.start → process.send → receive messages"
    },
    "architectural_hints": {
      "type_driven": "Define types first → compiler guides implementation",
      "immutability": "All values immutable → pure functions → no side effects",
      "result_flow": "use for Result chaining → pattern match for branches",
      "interop": "Gleam ↔ Erlang/Elixir via FFI → @external declarations"
    }
  },
  "prompts": {
    "code_generation": "Generate production-quality Gleam code for: {task}\n\nREQUIREMENTS:\n- Module documentation (////)\n- Function documentation (///)\n- Result(a, e) for error handling\n- Exhaustive pattern matching\n- Use pipelines (|>)\n- Custom types for domain modeling\n- Gleeunit tests\n\nOUTPUT CODE ONLY.",
    "documentation": "Generate documentation for this Gleam code:\n\n```gleam\n{code}\n```\n\nInclude:\n- //// module documentation with examples\n- /// for every public function\n\nOUTPUT DOCUMENTATION ONLY.",
    "tests": "Generate Gleeunit tests for this code:\n\n```gleam\n{code}\n```\n\nInclude comprehensive test cases.\n\nOUTPUT TEST CODE ONLY."
  },
  "examples": {
    "good_code": "//// JSON parsing with Result types\n////\n//// # Examples\n////\n//// ```gleam\n//// parse(\"{\\\"key\\\": \\\"value\\\"}\")\n//// // Ok(dict.from_list([(\"key\", \"value\")]))\n//// ```\n\nimport gleam/json\nimport gleam/dict\nimport gleam/result\n\npub type ParseError {\n  InvalidJson(String)\n}\n\n/// Parses a JSON string into a dictionary.\n///\n/// # Examples\n///\n/// ```gleam\n/// parse(\"{\\\"name\\\": \\\"Alice\\\"}\")\n/// // Ok(dict.from_list([(\"name\", \"Alice\")]))\n/// ```\npub fn parse(input: String) -> Result(dict.Dict(String, String), ParseError) {\n  json.decode(input, json.dynamic)\n  |> result.map_error(fn(_) { InvalidJson(\"Invalid JSON input\") })\n}"
  },
  "quality_checklist": [
    "Has //// module documentation",
    "Has /// function documentation",
    "Uses Result(a, e) for errors",
    "Exhaustive pattern matching",
    "No partial functions",
    "Custom types for domain",
    "Tests with gleeunit"
  ]
}