{
  "name": "Elixir Production Quality",
  "language": "elixir",
  "quality_level": "production",
  "description": "Maximum quality standards for production Elixir code",

  "requirements": {
    "documentation": {
      "moduledoc": {
        "required": true,
        "min_length": 100,
        "must_include": ["overview", "examples", "usage"]
      },
      "doc": {
        "required_for": ["all_public_functions"],
        "min_length": 50,
        "must_include": ["description", "examples", "return_value"]
      },
      "inline_comments": {
        "required_for": ["complex_logic", "algorithms"],
        "style": "concise"
      }
    },

    "type_specs": {
      "required": true,
      "required_for": ["all_functions"],
      "style": "strict",
      "custom_types": "encouraged"
    },

    "error_handling": {
      "style": "tagged_tuples",
      "required_pattern": "{:ok, result} | {:error, reason}",
      "no_raise": true,
      "explicit_errors": true,
      "error_types": ["atom", "string", "custom_error_struct"]
    },

    "testing": {
      "required": true,
      "coverage_target": 90,
      "test_types": [
        "happy_path",
        "edge_cases",
        "error_cases",
        "property_based",
        "integration"
      ],
      "test_framework": "ExUnit",
      "must_test": ["all_public_functions", "error_paths"]
    },

    "code_style": {
      "naming_convention": "snake_case",
      "max_function_length": 30,
      "max_line_length": 120,
      "pattern_matching": "preferred",
      "guard_clauses": "required_for_validation",
      "pipe_operator": "encouraged",
      "with_statements": "for_multiple_operations"
    },

    "code_smells": {
      "forbidden": [
        "TODO",
        "FIXME",
        "XXX",
        "HACK"
      ],
      "warnings": [
        "long_functions",
        "deeply_nested",
        "god_modules"
      ]
    },

    "architecture": {
      "single_responsibility": true,
      "max_module_lines": 500,
      "separation_of_concerns": true,
      "prefer_composition": true
    }
  },

  "prompts": {
    "system_prompt": "You are an expert Elixir developer writing PRODUCTION-QUALITY code. Generate code that meets the highest standards: complete documentation, type specs, comprehensive tests, and explicit error handling. Follow Elixir best practices and idioms.",

    "code_generation": "Generate production-quality Elixir code for: {task}\n\nREQUIREMENTS:\n- @moduledoc with overview and examples\n- @doc for EVERY public function\n- @spec for EVERY function\n- Explicit error handling with {:ok, _} | {:error, _}\n- Guard clauses for validation\n- Pattern matching preferred\n- Functions under 30 lines\n- No TODOs or FIXMEs\n\nOUTPUT CODE ONLY - no explanations.",

    "documentation": "Generate complete documentation for this Elixir code:\n\n```elixir\n{code}\n```\n\nInclude:\n- @moduledoc with overview, examples, and important notes\n- @doc for every public function with:\n  - Clear description\n  - Parameter explanations\n  - Return value description\n  - Usage examples\n\nOUTPUT DOCUMENTATION ONLY.",

    "type_specs": "Generate @spec type specifications for this Elixir code:\n\n```elixir\n{code}\n```\n\nBe precise with types:\n- Use String.t(), integer(), float(), map(), list(), etc.\n- Define custom types with @type if needed\n- Include @spec for every function\n\nOUTPUT @spec DECLARATIONS ONLY.",

    "tests": "Generate comprehensive ExUnit tests for this code:\n\n```elixir\n{code}\n```\n\nInclude:\n- Happy path tests (valid inputs)\n- Edge cases (nil, empty, boundary values)\n- Error cases (invalid inputs, failures)\n- Property-based tests (if applicable)\n- Test coverage > 90%\n\nOUTPUT COMPLETE TEST MODULE ONLY.",

    "refactor_quality": "Refactor this Elixir code to meet production quality standards:\n\n```elixir\n{code}\n```\n\nAdd:\n- Missing @moduledoc/@doc/@spec\n- Explicit error handling\n- Guard clauses\n- Better variable names\n- Break long functions into smaller ones\n\nOUTPUT REFACTORED CODE ONLY."
  },

  "semantic_patterns": {
    "common_patterns": [
      {
        "pattern": "API client",
        "pseudocode": "module → client_state → request(method, path, params) → {:ok, response} | {:error, reason}",
        "relationships": ["GenServer for state", "HTTP client (Req/Finch)", "rate limiting", "retry logic"],
        "keywords": ["http", "api", "request", "client", "endpoint"]
      },
      {
        "pattern": "GenServer cache",
        "pseudocode": "GenServer → state:map → get(key) → {:ok, value} | :not_found, put(key, value) → :ok, ttl management",
        "relationships": ["ETS for backing", "periodic cleanup", "pub/sub for invalidation"],
        "keywords": ["cache", "genserver", "state", "ttl", "get", "put"]
      },
      {
        "pattern": "Data pipeline",
        "pseudocode": "Broadway → fetch → validate → transform → store → handle_failed",
        "relationships": ["producers", "processors", "batchers", "error handling"],
        "keywords": ["pipeline", "stream", "transform", "batch", "flow"]
      },
      {
        "pattern": "Ecto schema",
        "pseudocode": "schema → fields → associations → changeset → validations → repo operations",
        "relationships": ["belongs_to", "has_many", "many_to_many", "embeds"],
        "keywords": ["schema", "changeset", "repo", "association", "validation"]
      }
    ],

    "relationship_vectors": {
      "supervisor_tree": "Supervisor → children → restart_strategy → dynamic vs static",
      "umbrella_app": "Apps → shared deps → cross-app communication → separate releases",
      "pubsub_pattern": "Publisher → PubSub → Subscribers → topics → broadcast",
      "agent_pattern": "Agent → state → get/update → simple vs GenServer",
      "task_pattern": "Task.async → Task.await → supervision → Task.Supervisor",
      "nats_pub": "NATS.publish(subject, payload) → fire_and_forget → async messaging",
      "nats_sub": "NATS.subscribe(subject) → handle_message(msg) → ack/nak → consumer group",
      "nats_request": "NATS.request(subject, data, timeout) → await_reply → RPC pattern",
      "nats_stream": "JetStream → durable consumer → ack policy → replay capability",
      "kafka_producer": "Kafka.produce(topic, key, value) → partition → broker → ack → at_least_once",
      "kafka_consumer": "Kafka.consume(topic, group_id) → poll → process batch → commit offsets → exactly_once",
      "kafka_stream": "KafkaStreams → topology → stateful processing → windowing → aggregations",
      "service_registry": "NATS service → advertise endpoints → health checks → load balancing",
      "event_sourcing": "Event → NATS/Kafka stream → consumers → projections → state rebuild"
    },

    "architectural_hints": {
      "web_apps": "Context (business logic) → Schema (data) → View (presentation) [Phoenix web apps]",
      "libraries_platforms": "Domain folder → Functional subfolders (analyzers/, generators/, storage/) [Non-web libraries]",
      "interfaces_not_api": "Tools (WHAT) → Interfaces (HOW: MCP, NATS) → NO HTTP API [Distributed platforms]",
      "error_flow": "with statement → pattern match → early return → {:error, reason}",
      "data_flow": "input → validate → transform → side_effects → output",
      "supervision": "one_for_one | one_for_all | rest_for_one → max_restarts → shutdown",
      "microservices": "Service → NATS subjects → request/reply → pub/sub → streams",
      "distributed_state": "CRDT (DeltaCRDT) → eventual consistency → merge conflicts → distributed writes",
      "service_mesh": "NATS core → service discovery → load balancing → failover",
      "event_driven": "Command → Event → NATS stream → Consumers → Projections → Query models",
      "observability": "Telemetry → metrics → traces → logs → NATS monitoring subjects",
      "circuit_breaker": "Request → check_breaker → open/half_open/closed → fallback → reset timeout"
    },

    "distributed_patterns": {
      "nats_microservice": {
        "structure": "Service module → NATS.Connection → advertise(name, version) → handle_request(subject, payload) → reply",
        "relationships": [
          "Service discovery via NATS",
          "Health checks on $SYS.REQ.SERVER.PING",
          "Load balancing via queue groups",
          "Circuit breaker for resilience"
        ],
        "example_flow": "Client → NATS.request('user.get', user_id) → [Service1, Service2] queue → Service1.handle → reply → Client receives"
      },
      "event_sourcing_nats": {
        "structure": "Command → validate → Event → NATS.publish('events.user.created') → Stream → Consumers → update_read_models",
        "relationships": [
          "JetStream for durable events",
          "Multiple consumers for different projections",
          "Replay for rebuilding state",
          "Acknowledgment for at-least-once delivery"
        ]
      },
      "saga_pattern": {
        "structure": "Saga coordinator → step1 → publish(event1) → step2 → compensate_if_fails → publish(compensation)",
        "relationships": [
          "NATS for event bus",
          "State machine for progress tracking",
          "Compensation actions",
          "Idempotency for retries"
        ]
      },
      "cqrs": {
        "structure": "Command side → NATS/Kafka → Event → Stream → Query side → read model → materialized view",
        "relationships": [
          "Separate write/read models",
          "Eventual consistency",
          "Scalable reads",
          "Event replay for rebuilding"
        ]
      },
      "kafka_broadway_pipeline": {
        "structure": "Broadway → KafkaProducer → fetch batches → transform → acknowledge → offset commit",
        "relationships": [
          "Backpressure handling",
          "Batching for efficiency",
          "Fault tolerance with retries",
          "Dead letter queue"
        ],
        "example_flow": "Kafka topic → Broadway → processor pool → batch_handler → store in DB → commit offsets"
      },
      "kafka_exactly_once": {
        "structure": "Read → Process → Write → Commit (transactional) → idempotent producer",
        "relationships": [
          "Kafka transactions",
          "Idempotency keys",
          "Exactly-once semantics",
          "State coordination"
        ]
      }
    },

    "service_relationships": {
      "singularity_to_fact_system": "Singularity agent → NATS.request('facts.query', %{query: 'dependencies for repo X'}) → SPARC fact system → facts → enrich context",
      "fact_query_patterns": {
        "technology_stack": "NATS.request('facts.query', %{repo: 'singularity', type: 'tech_stack'}) → [elixir, rust, postgres, nats]",
        "dependencies": "NATS.request('facts.query', %{package: 'phoenix', type: 'dependents'}) → repos using phoenix",
        "code_patterns": "NATS.request('facts.query', %{pattern: 'GenServer cache'}) → examples from all repos",
        "security_vulns": "NATS.request('facts.query', %{repo: 'X', type: 'advisories'}) → CVEs and severity"
      },
      "agent_coordination": "Agent1 → publish('task.available') → Agent2 subscribes → claim task → publish('task.claimed')",
      "distributed_cache": "Service → request → check local cache → miss → NATS.request('cache.get') → cache service → store locally",
      "health_aggregation": "$SYS.REQ.SERVER.PING → all services reply → aggregate health → expose /health endpoint",
      "code_generation_with_facts": "User request → query facts about similar code → RAG retrieval → pattern indexer → generate with context"
    },

    "fact_system_integration": {
      "query_structure": {
        "basic": "NATS.request('facts.query', query_payload, timeout: 5000)",
        "payload_schema": "%{repo: String, type: :tech_stack | :dependencies | :patterns | :advisories, filters: map}",
        "response_schema": "{:ok, [%Fact{...}]} | {:error, reason}"
      },
      "example_queries": [
        {
          "query": "Find all repos using Rust",
          "nats": "NATS.request('facts.query', %{language: 'rust', type: :repos})",
          "use_case": "Before generating Rust code, find best examples from Rust repos"
        },
        {
          "query": "Get dependency graph",
          "nats": "NATS.request('facts.query', %{package: 'ecto', type: :dependency_graph})",
          "use_case": "Understand what other packages are typically used with Ecto"
        },
        {
          "query": "Find code patterns",
          "nats": "NATS.request('facts.query', %{pattern: 'http_client', language: 'elixir'})",
          "use_case": "Get examples of HTTP client implementations across all repos"
        }
      ],
      "deduplication_integration": "Before generating → query facts → find similar code → check fingerprints → reuse if duplicate"
    },

    "detector_framework_integration": {
      "purpose": "Auto-detect technology stack before code generation",
      "flow": "File analysis → detector → tech profile → facts → code generation context",
      "detectors": {
        "npm_detector": "package.json → dependencies → typescript/react/next.js → suggest patterns",
        "cargo_detector": "Cargo.toml → dependencies → tokio/serde/actix → suggest async patterns",
        "mix_detector": "mix.exs → deps → phoenix/ecto/broadway → suggest BEAM patterns",
        "go_mod_detector": "go.mod → require → gorilla/gin/grpc → suggest Go patterns"
      },
      "usage_in_generation": {
        "1_detect": "Scan repo → run detectors → build tech_profile.json",
        "2_store_facts": "tech_profile → SPARC facts → NATS.publish('facts.tech_stack', profile)",
        "3_query_on_generate": "Before generating → NATS.request('facts.query', %{repo: X}) → get tech stack",
        "4_context_enrichment": "Tech stack → find patterns for detected techs → include in prompts",
        "5_smart_defaults": "Detected Phoenix → use Phoenix patterns, Ecto schemas, LiveView"
      },
      "example_tech_profiles": {
        "elixir_phoenix_app": {
          "language": "elixir",
          "frameworks": ["phoenix", "ecto", "liveview"],
          "patterns_to_use": ["phoenix_controller", "ecto_schema", "liveview_component", "pubsub"],
          "dependencies": ["jason", "plug", "postgrex"],
          "code_gen_hints": "USE CONTEXTS: lib/app_name/ (business logic), lib/app_name_web/ (controllers/views) - Phoenix web apps ONLY"
        },
        "elixir_library_platform": {
          "language": "elixir",
          "frameworks": ["ecto", "nats", "genserver"],
          "patterns_to_use": ["genserver", "supervisor", "ecto_schema", "protocol", "behaviour"],
          "dependencies": ["jason", "ecto", "gnat"],
          "code_gen_hints": "USE DOMAIN FOLDERS: lib/app_name/domain/ with functional subfolders (analyzers/, generators/, storage/) - Non-web libraries/platforms"
        },
        "rust_tokio_service": {
          "language": "rust",
          "frameworks": ["tokio", "axum", "sqlx"],
          "patterns_to_use": ["async_fn", "tokio_spawn", "axum_handler", "sqlx_query"],
          "dependencies": ["serde", "anyhow", "tracing"],
          "code_gen_hints": "Use Result<T, E>, async/await, structured logging with tracing"
        }
      },
      "nats_detector_integration": "Detector runs → publishes to 'detector.tech_profile.{repo}' → fact collector subscribes → stores in DB"
    }
  },

  "ast_extraction": {
    "genserver_cache": {
      "ast_signature": ["defmodule", "use GenServer", "handle_call(:get", "handle_call(:put", "init(%{})"],
      "extract_pseudocode": "GenServer → state:map → get(key) → {:ok, value} | :not_found, put(key, value) → :ok",
      "confidence_score": 0.95,
      "required_functions": ["get", "put", "init"]
    },
    "with_error_handling": {
      "ast_signature": ["with", "<- [multiple]", "else"],
      "extract_pseudocode": "with step1 <- op1, step2 <- op2 do success else error end",
      "confidence_score": 0.90
    },
    "protocol_implementation": {
      "ast_signature": ["defprotocol", "defimpl Protocol, for:"],
      "extract_pseudocode": "defprotocol Protocol → defimpl for Type → polymorphism",
      "confidence_score": 0.98
    },
    "ecto_schema": {
      "ast_signature": ["schema", "field", "belongs_to", "has_many"],
      "extract_pseudocode": "schema → fields → associations → changeset → validations",
      "confidence_score": 0.97
    }
  },

  "singularity_patterns": {
    "technology_detection": {
      "pattern": "Technology Detection",
      "pseudocode": "TechnologyDetector.detect(path) → Port → Rust LayeredDetector → tree-sitter → {:ok, technologies}",
      "relationships": ["Rust via Port (not NIF)", "LayeredDetector (5 levels)", "Template matching", "Pattern store (PostgreSQL)"],
      "keywords": ["detection", "technology", "framework", "rust", "tree-sitter", "port"],
      "file_locations": ["lib/singularity/detection/technology_detector.ex", "rust/tool_doc_index/src/detection/"]
    },
    "interface_protocol": {
      "pattern": "Interface Abstraction",
      "pseudocode": "Tool definition → Protocol.execute_tool(interface, call) → defimpl for MCP/NATS → format result",
      "relationships": ["Protocol-based polymorphism", "MCP interface (AI assistants)", "NATS interface (distributed)", "NO HTTP API"],
      "keywords": ["interface", "protocol", "mcp", "nats", "abstraction", "polymorphism"],
      "file_locations": ["lib/singularity/interfaces/protocol.ex", "lib/singularity/interfaces/mcp.ex", "lib/singularity/interfaces/nats.ex"]
    },
    "domain_folder_organization": {
      "pattern": "Domain Folder Structure",
      "pseudocode": "lib/domain/ → functional_subfolders/ (analyzers/, generators/, storage/) → NOT contexts",
      "relationships": ["Library/platform pattern", "NOT Phoenix contexts", "Self-documenting structure", "Functional grouping"],
      "keywords": ["organization", "domain", "folder", "library", "platform", "structure"],
      "anti_pattern": "Phoenix contexts (for web apps only)"
    },
    "ecto_direct_access": {
      "pattern": "Direct Ecto (No db_service)",
      "pseudocode": "Module → Repo.insert(schema, attrs) → PostgreSQL (no NATS for DB)",
      "relationships": ["Direct Ecto access", "No db_service microservice", "10x faster than NATS", "Ecto schemas in schemas/"],
      "keywords": ["ecto", "database", "postgresql", "direct", "repo"],
      "removed_pattern": "NATS → db_service → PostgreSQL (deprecated)"
    }
  },

  "architecture_fingerprints": {
    "phoenix_web_app": {
      "detect_structure": {
        "required_paths": ["lib/*_web/"],
        "required_files": ["lib/*_web/router.ex", "lib/*_web/endpoint.ex"],
        "not_present": []
      },
      "architecture_type": "phoenix_web",
      "recommended_pattern": "Phoenix Contexts",
      "pseudocode_template": "Context (business) → Schema (data) → View (presentation)",
      "confidence": 0.98
    },
    "elixir_library_platform": {
      "detect_structure": {
        "required_paths": ["lib/*/"],
        "required_files": [],
        "not_present": ["lib/*_web/"]
      },
      "architecture_type": "library",
      "recommended_pattern": "Domain Folders",
      "pseudocode_template": "Domain folder → Functional subfolders (analyzers/, generators/)",
      "confidence": 0.95
    },
    "umbrella_app": {
      "detect_structure": {
        "required_paths": ["apps/"],
        "required_files": ["mix.exs"],
        "file_contains": {"mix.exs": "umbrella: true"}
      },
      "architecture_type": "umbrella",
      "recommended_pattern": "Multi-app",
      "pseudocode_template": "apps/ → app1/ + app2/ → shared deps",
      "confidence": 1.0
    }
  },

  "vector_search_config": {
    "embedding_model": "text-embedding-004",
    "embedding_dimensions": 768,
    "similarity_metric": "cosine",
    "similarity_thresholds": {
      "exact_match": 0.95,
      "very_similar": 0.85,
      "similar": 0.75,
      "somewhat_related": 0.65,
      "min_threshold": 0.60
    },
    "search_strategy": {
      "max_results": 10,
      "rerank": true,
      "boost_recent": 0.1,
      "boost_same_repo": 0.2
    }
  },

  "pattern_composition": {
    "genserver_with_supervision": {
      "combines": ["genserver_cache", "supervisor_tree"],
      "pseudocode": "Supervisor → starts GenServer cache → monitor → restart on crash",
      "relationship_strength": 0.9,
      "keywords": ["supervision", "genserver", "fault-tolerance", "otp"]
    },
    "nats_with_ecto": {
      "combines": ["nats_request", "ecto_direct_access"],
      "pseudocode": "NATS.request → Service → Ecto.Repo.query → reply",
      "relationship_strength": 0.85,
      "keywords": ["nats", "ecto", "distributed", "database"]
    },
    "interface_with_tools": {
      "combines": ["interface_protocol", "tool_registry"],
      "pseudocode": "Tool.register → Protocol.execute_tool(interface) → format per interface",
      "relationship_strength": 0.95,
      "keywords": ["tools", "interface", "protocol", "abstraction"]
    }
  },

  "anti_patterns": {
    "phoenix_context_in_library": {
      "bad_pseudocode": "lib/my_lib.ex (context) + lib/my_lib/ (internals) in non-web library",
      "why_bad": "Context pattern is for Phoenix web apps, not libraries",
      "correct_pattern": "domain_folder_organization",
      "detection": {
        "has": ["lib/context.ex", "lib/context/"],
        "missing": ["lib/*_web/"]
      },
      "severity": "warning"
    },
    "http_api_for_tools": {
      "bad_pseudocode": "Tools → HTTP REST API → External clients",
      "why_bad": "We use MCP and NATS interfaces, not HTTP API",
      "correct_pattern": "interface_protocol",
      "detection": {
        "has": ["lib/*_web/controllers/api/"]
      },
      "severity": "error"
    },
    "nats_for_database": {
      "bad_pseudocode": "Module → NATS.publish('db.insert') → db_service → PostgreSQL",
      "why_bad": "Use direct Ecto access (10x faster, removed db_service)",
      "correct_pattern": "ecto_direct_access",
      "detection": {
        "has": ["NATS.publish(\"db."]
      },
      "severity": "error",
      "migration_guide": "See DB_SERVICE_REMOVAL.md"
    }
  },

  "quality_signals": {
    "has_specs": {
      "signal": "@spec present for all public functions",
      "weight": 1.0,
      "check": "ast_contains('@spec')"
    },
    "has_docs": {
      "signal": "@moduledoc and @doc present",
      "weight": 1.0,
      "check": "ast_contains('@moduledoc') && ast_contains('@doc')"
    },
    "error_handling": {
      "signal": "Uses {:ok, _} | {:error, _} pattern",
      "weight": 1.0,
      "check": "returns_tagged_tuples()"
    },
    "pattern_quality_score": {
      "formula": "sum(weights * signals_present) / sum(weights)",
      "min_production_score": 0.9
    }
  },

  "pattern_lifecycle": {
    "db_service_pattern": {
      "status": "deprecated",
      "deprecated_date": "2025-10-05",
      "reason": "Replaced by direct Ecto access (10x faster)",
      "migration_path": "ecto_direct_access",
      "removal_date": "2026-01-01"
    },
    "interface_protocol": {
      "status": "active",
      "introduced_date": "2025-10-05",
      "stability": "stable",
      "recommended": true
    },
    "domain_folder_organization": {
      "status": "active",
      "introduced_date": "2025-10-05",
      "stability": "stable",
      "recommended": true
    }
  },

  "examples": {
    "good_code": "defmodule JSONParser do\n  @moduledoc \"\"\"\n  Parses JSON strings with comprehensive error handling.\n\n  ## Examples\n\n      iex> JSONParser.parse(\"{\\\"key\\\": \\\"value\\\"}\")\n      {:ok, %{\"key\" => \"value\"}}\n\n      iex> JSONParser.parse(\"invalid\")\n      {:error, :invalid_json}\n  \"\"\"\n\n  @doc \"\"\"\n  Parses a JSON string into an Elixir map.\n\n  ## Parameters\n\n  - `json` - JSON string to parse\n\n  ## Returns\n\n  - `{:ok, map}` - Successfully parsed JSON\n  - `{:error, reason}` - Parsing failed\n  \"\"\"\n  @spec parse(String.t()) :: {:ok, map()} | {:error, atom()}\n  def parse(json) when is_binary(json) do\n    case Jason.decode(json) do\n      {:ok, data} -> {:ok, data}\n      {:error, _} -> {:error, :invalid_json}\n    end\n  end\n\n  def parse(_), do: {:error, :invalid_input}\nend",

    "bad_code": "def parse(x) do\n  # TODO: add error handling\n  Jason.decode(x)\nend"
  },

  "quality_checklist": [
    "Has @moduledoc with examples",
    "Has @doc for all public functions",
    "Has @spec for all functions",
    "Uses {:ok, _} | {:error, _} pattern",
    "No raise/throw in production code paths",
    "Functions are under 30 lines",
    "Descriptive variable names (no x, y, z)",
    "Guard clauses for validation",
    "Pattern matching used appropriately",
    "No TODO/FIXME/XXX markers",
    "Comprehensive tests (>90% coverage)",
    "Edge cases handled",
    "Error cases tested"
  ],

  "scoring_weights": {
    "has_moduledoc": 1.0,
    "has_function_docs": 1.0,
    "has_type_specs": 1.0,
    "has_tests": 1.0,
    "error_handling": 1.0,
    "no_code_smells": 1.0,
    "naming_quality": 0.8,
    "function_length": 0.6,
    "test_coverage": 1.0
  }
}
