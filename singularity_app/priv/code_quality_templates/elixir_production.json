{
  "name": "Elixir Core Production Quality",
  "spec_version": "2.0",
  "capabilities": [
    "quality",
    "graph",
    "rag"
  ],
  "language": "elixir",
  "quality_level": "production",
  "description": "Core (framework-agnostic) Elixir production quality standards. Domain/framework specific layers (Phoenix, Ecto, messaging, etc.) are added by the prompt engine separately.",
  "extends": [],
  "modules": {
    "extension_note": "This core spec intentionally contains only pure Elixir/OTP guidance. Higher-level concerns are composed elsewhere."
  },
  "requirements": {
    "documentation": {
      "moduledoc": {
        "required": true,
        "min_length": 60,
        "must_include": [
          "overview",
          "examples"
        ]
      },
      "doc": {
        "required_for": [
          "all_public_functions"
        ],
        "min_length": 30,
        "must_include": [
          "description",
          "return_value"
        ]
      },
      "inline_comments": {
        "required_for": [
          "complex_pattern_matching",
          "non_trivial_recursion"
        ],
        "style": "concise"
      },
      "structured_sections": [
        {
          "id": "overview",
          "required": true,
          "min_length": 40,
          "purpose": "High-level what/why in first 2 sentences",
          "must_answer": [
            "What does this module represent?",
            "Why does it exist vs alternatives?"
          ]
        },
        {
          "id": "public_api_contract",
          "required": true,
          "min_length": 60,
          "purpose": "List of stable public functions with concise contract lines",
          "format": "one line per function: name(args) :: return -- short purpose"
        },
        {
          "id": "error_matrix",
          "required": true,
          "min_length": 40,
          "purpose": "Enumerate all {:error, reason} atoms with meaning",
          "format": "reason_atom | scenario"
        },
        {
          "id": "invariants",
          "required": false,
          "min_length": 30,
          "purpose": "State safety & data invariants enforced"
        },
        {
          "id": "performance_notes",
          "required": false,
          "purpose": "Big-O or qualitative perf notes + allocation hotspots"
        },
        {
          "id": "concurrency_semantics",
          "required": false,
          "purpose": "Thread / process safety, GenServer serialization boundaries"
        },
        {
          "id": "examples",
          "required": true,
          "min_examples": 2,
          "purpose": "Executable iex examples covering success + error path"
        }
      ],
      "metadata_fields": {
        "stability": {
          "enum": [
            "experimental",
            "beta",
            "stable",
            "deprecated"
          ],
          "required": true
        },
        "side_effects": {
          "enum": [
            "none",
            "io",
            "network",
            "filesystem",
            "external_process"
          ],
          "multi": true
        },
        "statefulness": {
          "enum": [
            "pure",
            "process_state",
            "ets",
            "persistent"
          ],
          "multi": true
        },
        "idempotency": {
          "enum": [
            "idempotent",
            "non_idempotent"
          ],
          "required": true
        },
        "thread_safety": {
          "enum": [
            "n_a",
            "process_isolated",
            "shared_send_only"
          ],
          "required": true
        },
        "security": {
          "fields": [
            "inputs_validated",
            "taint_sensitive",
            "handles_pii",
            "privileged_calls"
          ],
          "type": "boolean_map"
        },
        "dependencies_local": {
          "type": "list",
          "purpose": "Internal module dependencies (public API only)"
        },
        "dependencies_external": {
          "type": "list",
          "purpose": "Library/runtime dependencies directly invoked"
        }
      },
      "embedding_hints": {
        "stable_anchor_format": "@@MOD:{module}|SEC:{section}@@",
        "deterministic_section_order": true,
        "avoid_noise_phrases": [
          "just",
          "simply",
          "basically"
        ],
        "prefer_explicit_atoms": true
      }
    },
    "type_specs": {
      "required": true,
      "required_for": [
        "all_functions"
      ],
      "dialyzer": "recommended",
      "custom_types": "encouraged"
    },
    "error_handling": {
      "style": "tagged_tuples",
      "required_pattern": "{:ok, value} | {:error, reason}",
      "no_raise_for_flow": true,
      "allowed_raise": [
        "startup_failures",
        "irrecoverable_invariants"
      ],
      "define_error_atoms": true
    },
    "testing": {
      "required": true,
      "coverage_target": 90,
      "must_test": [
        "public_api",
        "error_paths"
      ],
      "types": [
        "unit",
        "property_optional",
        "edge_cases"
      ],
      "async_default": true
    },
    "code_style": {
      "naming": "snake_case",
      "module_naming": "PascalCase",
      "max_function_lines": 30,
      "max_module_lines": 500,
      "max_line_length": 120,
      "prefer_pattern_matching": true,
      "prefer_guard_clauses": true,
      "pipe_operator": "encouraged_small_transform_chains",
      "avoid_nested_with": true
    },
    "code_smells": {
      "forbidden": [
        "TODO",
        "FIXME",
        "HACK"
      ],
      "warn": [
        "deep_nesting",
        "long_functions",
        "god_modules"
      ],
      "long_function_threshold": 30
    },
    "design_principles": {
      "single_responsibility": true,
      "explicit_boundaries": true,
      "prefer_composition_over_inheritance": true,
      "pure_functions_for_business_logic": true
    },
    "complexity": {
      "max_decision_points": 10,
      "refactor_if_exceeds": true
    },
    "stubs": {
      "prohibited": true,
      "note": "All functions shipped to main must have working logic or be clearly feature-flag guarded."
    }
  },
  "prompts": {
    "system_prompt": "You are an expert Elixir developer producing CORE (framework-agnostic) Elixir code: clean, documented, tested, explicit in errors, leveraging OTP appropriately.",
    "code_generation": "Generate core Elixir module for: {task}\nREQUIREMENTS:\n- @moduledoc (overview + example)\n- @doc for every public function\n- @spec for every function\n- Use {:ok, _} | {:error, _} pattern (no raise for control flow)\n- Pattern match + guards for validation\n- Functions <= 30 LOC\n- No TODO/FIXME\nOUTPUT ONLY CODE.",
    "tests": "Generate ExUnit tests for: {code}\nCover: happy paths, edge cases (nil/empty/boundaries), error cases. Ensure isolation and use async when safe. OUTPUT ONLY TEST MODULE.",
    "refactor_quality": "Refactor this Elixir code to production quality core standards: {code}\nAdd missing docs/specs, simplify branching, replace raise with tagged tuples, break up long functions. OUTPUT ONLY REFACTORED CODE."
  },
  "patterns": {
    "genserver_basic": {
      "intent": "Stateful process abstraction with message handling.",
      "pseudocode": "use GenServer -> init(state) -> handle_call/handle_cast -> state transitions",
      "when_to_use": [
        "stateful_logic",
        "infrequent_mutation",
        "coordination"
      ],
      "avoid_if": [
        "pure_stateless_transform"
      ],
      "quality_checks": [
        "terminate/2 only if needed",
        "don’t leak PIDs",
        "reply consistency"
      ]
    },
    "supervision_tree": {
      "intent": "Fault tolerance via hierarchical supervision.",
      "pseudocode": "Supervisor.start_link(children, strategy: :one_for_one)",
      "strategies": [
        "one_for_one",
        "rest_for_one",
        "one_for_all"
      ],
      "guidelines": [
        "keep children small",
        "restart only what’s needed"
      ]
    },
    "application_startup": {
      "intent": "Define start/2 for OTP application lifecycle.",
      "pseudocode": "def start(_type, _args), do: Supervisor.start_link(children, opts)",
      "guidelines": [
        "minimal work in start",
        "fail fast on irrecoverable config"
      ]
    },
    "behaviour_contract": {
      "intent": "Define callback contract for pluggable modules.",
      "pseudocode": "@callback handle(input) :: {:ok, term} | {:error, term}",
      "guidelines": [
        "document callbacks",
        "supply test implementation"
      ],
      "anti": [
        "using protocols when static dispatch sufficient"
      ]
    },
    "protocol_dispatch": {
      "intent": "Polymorphic dispatch on data types.",
      "pseudocode": "defprotocol Encoder; defimpl Encoder, for: Map do ... end",
      "guidelines": [
        "only when extensibility by external types needed"
      ],
      "anti": [
        "protocol explosion for internal variants"
      ]
    },
    "ets_cache": {
      "intent": "In-memory fast lookup table.",
      "pseudocode": ":ets.new(:table, [:set, :public, read_concurrency: true])",
      "guidelines": [
        "guard concurrent access",
        "avoid premature caching"
      ],
      "anti": [
        "storing large binaries unbounded"
      ]
    },
    "with_error_flow": {
      "intent": "Sequential operations with early exit on error.",
      "pseudocode": "with {:ok, a} <- step1(), {:ok, b} <- step2(a) do {:ok, transform(b)} else {:error, r} -> {:error, r} end",
      "guidelines": [
        "limit to ~3-5 steps",
        "log final error context"
      ]
    },
    "task_async": {
      "intent": "Concurrent fire-and-gather pattern.",
      "pseudocode": "tasks = Enum.map(items, &Task.async(fn -> work(&1) end)); Enum.map(tasks, &Task.await/1)",
      "guidelines": [
        "don’t saturate schedulers",
        "timeout control"
      ],
      "anti": [
        "unbounded task spawning"
      ]
    }
  },
  "anti_patterns": {
    "long_function": {
      "symptom": "> 30 lines",
      "why_bad": "Hard to reason about, violates single responsibility.",
      "fix": "Extract pure helper functions."
    },
    "process_mailbox_leak": {
      "symptom": "receive loops without timeouts or selective patterns",
      "why_bad": "Unbounded mailbox growth.",
      "fix": "Use GenServer or add timeout + pattern narrowing."
    },
    "raise_for_control_flow": {
      "symptom": "Using raise to signal expected domain failures",
      "why_bad": "Breaks tagged tuple conventions.",
      "fix": "Return {:error, reason}."
    },
    "global_state_via_module_attribute": {
      "symptom": "@state mutated at compile then treated as runtime",
      "why_bad": "Unexpected immutability / stale values.",
      "fix": "Use proper process or configuration."
    },
    "generic_names": {
      "symptom": "Modules named Util/Helper/Misc",
      "why_bad": "Non-descriptive, hinders discoverability.",
      "fix": "Rename to domain-specific responsibility."
    }
  },
  "pattern_lifecycle": {
    "gen_fsm": {
      "status": "deprecated",
      "replacement": ":gen_statem",
      "note": "Use :gen_statem for newer finite state machines."
    },
    ":erl_prim_loader_usage": {
      "status": "discouraged",
      "note": "Avoid depending on internal OTP loader modules."
    },
    "genserver_basic": {
      "status": "active"
    },
    "supervision_tree": {
      "status": "active"
    }
  },
  "examples": {
    "good_code": "defmodule SafeParser do\n  @moduledoc \"\n  Parses inputs into integers safely.\n  ## Examples\n      iex> SafeParser.parse(\"12\")\n      {:ok, 12}\n      iex> SafeParser.parse(\"x\")\n      {:error, :invalid}\n  \"\n  @spec parse(term) :: {:ok, integer} | {:error, :invalid} | {:error, :type} \n  def parse(input) when is_binary(input) do\n    case Integer.parse(input) do\n      {n, \"\"} -> {:ok, n}\n      _ -> {:error, :invalid}\n    end\n  end\n  def parse(input) when is_integer(input), do: {:ok, input}\n  def parse(_), do: {:error, :type}\nend",
    "bad_code": "defmodule P do\n  def p(x), do: Integer.parse(x) # TODO handle errors later\nend"
  },
  "quality_checklist": [
    "@moduledoc present + example",
    "@doc for every public function",
    "@spec for every function",
    "No raises used for normal domain errors",
    "Functions <= 30 LOC",
    "Meaningful module & function names",
    "Tagged tuple error style consistent",
    "Edge cases covered in tests"
  ],
  "scoring_weights": {
    "docs": 1.0,
    "specs": 1.0,
    "tests": 1.0,
    "error_style": 1.0,
    "structure": 0.8,
    "naming": 0.6
  },
  "rag_indexing": {
    "segmentation_rules": {
      "max_tokens_per_chunk": 450,
      "min_tokens_per_chunk": 120,
      "logical_split_order": [
        "structured_sections",
        "functions",
        "examples",
        "error_matrix"
      ],
      "preserve_section_boundary": true
    },
    "canonical_id_rules": {
      "module_id_format": "elixir://{app}/{module}",
      "function_id_format": "elixir://{app}/{module}.{function}/{arity}",
      "anchor_format": "@@ID:{type}:{value}@@"
    },
    "entity_extraction": {
      "enabled": true,
      "entities": [
        "module",
        "function",
        "error_atom",
        "type",
        "process_pattern"
      ]
    },
    "ranking_weights": {
      "section_priority": {
        "public_api_contract": 1.0,
        "error_matrix": 0.9,
        "overview": 0.85,
        "examples": 0.8,
        "invariants": 0.75
      },
      "freshness": 0.1,
      "stability_bonus": {
        "stable": 0.05,
        "deprecated": -0.2
      }
    },
    "language_facets": [
      "otp",
      "pure",
      "stateful",
      "concurrency",
      "pattern"
    ],
    "cross_linking": {
      "link_pattern": "See also: {module_or_function}",
      "max_links_per_section": 5
    }
  },
  "doc_block_schema": {
    "module": {
      "fields": [
        "overview",
        "public_api_contract",
        "error_matrix",
        "invariants",
        "examples"
      ]
    },
    "function": {
      "fields": [
        "summary",
        "parameters",
        "returns",
        "errors",
        "examples",
        "notes"
      ],
      "parameters_format": "name :: type - purpose",
      "errors_format": "{:error, atom} - meaning"
    }
  },
  "function_doc_requirements": {
    "summary_max_sentences": 2,
    "require_examples": true,
    "require_error_atoms_if_any": true,
    "parameter_doc_required": true,
    "disallow_phrases": [
      "stuff",
      "misc",
      "various"
    ],
    "preferred_verbs": [
      "parse",
      "build",
      "transform",
      "encode",
      "decode",
      "validate"
    ]
  },
  "semantic_anchors": [
    "@@MOD:START@@",
    "@@MOD:END@@",
    "@@SEC:overview@@",
    "@@SEC:public_api_contract@@",
    "@@SEC:error_matrix@@",
    "@@SEC:examples@@"
  ],
  "modular": true,
  "version": 3,
  "last_updated": "2025-10-08",
  "graph_model": {
    "version": 1,
    "purpose": "Guidance for automated extraction into a polyglot code knowledge graph.",
    "node_types": {
      "module": {
        "id_format": "elixir://{app}/{module}",
        "key_props": [
          "stability",
          "statefulness",
          "idempotency"
        ],
        "merge_keys": [
          "name"
        ]
      },
      "function": {
        "id_format": "elixir://{app}/{module}.{function}/{arity}",
        "key_props": [
          "side_effects",
          "idempotency"
        ],
        "merge_keys": [
          "signature_hash"
        ]
      },
      "error_atom": {
        "id_format": "elixir://{app}/{module}#error/{atom}",
        "key_props": [
          "meaning"
        ],
        "merge_keys": [
          "atom"
        ]
      },
      "type_spec": {
        "id_format": "elixir://{app}/{module}#type/{name}",
        "key_props": [
          "definition"
        ],
        "merge_keys": [
          "name"
        ]
      },
      "process_pattern": {
        "id_format": "elixir://{app}/{module}#pattern/{pattern}",
        "key_props": [
          "intent"
        ],
        "merge_keys": [
          "pattern"
        ]
      }
    },
    "edge_types": {
      "calls": {
        "from": "function",
        "to": "function",
        "props": [
          "arity_match",
          "direct"
        ],
        "weight": 0.9
      },
      "declares": {
        "from": "module",
        "to": "function",
        "weight": 1.0
      },
      "uses_error": {
        "from": "function",
        "to": "error_atom",
        "weight": 0.8
      },
      "defines_type": {
        "from": "module",
        "to": "type_spec",
        "weight": 0.85
      },
      "applies_pattern": {
        "from": "module",
        "to": "process_pattern",
        "weight": 0.7
      },
      "wraps_call": {
        "from": "function",
        "to": "function",
        "props": [
          "error_wrapped"
        ],
        "weight": 0.6
      },
      "transforms": {
        "from": "function",
        "to": "type_spec",
        "props": [
          "direction"
        ],
        "weight": 0.65
      }
    },
    "extraction_rules": {
      "function_signature_hash": "md5(module_name <> function_name <> arity <> spec_string)",
      "error_atom_detection": "scan @moduledoc error_matrix + pattern match on {:error, atom}",
      "pattern_detection": "match against known OTP idioms (GenServer, Supervisor, Task.async, with chains)",
      "call_graph": "static AST traversal; exclude macro-expanded remote calls unless resolvable"
    },
    "relation_taxonomy": {
      "stability_inheritance": "function inherits module stability unless overridden",
      "error_propagation": "if function returns {:error, X} and calls Y returning {:error, X}, edge Y -> X (uses_error) forms transitive cluster",
      "pattern_cluster": "modules sharing same process_pattern become implicit cluster"
    },
    "confidence_scoring": {
      "base": 0.75,
      "boosts": {
        "dialyzer_spec_present": 0.1,
        "doc_error_matrix_present": 0.05,
        "examples_cover_error": 0.05
      },
      "penalties": {
        "missing_specs": -0.15,
        "no_error_docs": -0.1
      }
    },
    "integrity_checks": [
      "every function must have declares edge from a module",
      "error_atom must be referenced by at least one function uses_error edge",
      "type_spec without defines_type after 2 passes => mark orphan"
    ],
    "graph_export": {
      "canonical_formats": [
        "graphml",
        "jsonl_edges",
        "neo4j_csv"
      ],
      "batching": {
        "max_nodes_per_file": 50000,
        "max_edges_per_file": 200000
      },
      "file_naming": "graph_export_{date}_{shard}.{ext}",
      "shard_key_priority": [
        "module",
        "function"
      ]
    },
    "query_hints": {
      "find_unstable_public_surface": "MATCH (m:module {stability:'beta'})-[:declares]->(f:function) RETURN f",
      "error_usage_distribution": "MATCH (f:function)-[:uses_error]->(e:error_atom) RETURN e, count(f) ORDER BY count(f) DESC",
      "pattern_adoption": "MATCH (m:module)-[:applies_pattern]->(p:process_pattern) RETURN p, count(m)"
    }
  }
}