impl NamingConventions {
    /// Create a new naming conventions handler
    pub fn new() -> Self {
        let mut naming = Self {
            patterns: HashMap::new(),
            naming_rules: NamingRules::default(),
            descriptions: HashMap::new(),
            search_index: HashMap::new(),
            confidence_threshold: 0.7,
            framework_integration: None,
            agent_integration: None,
            context_analyzer: None,
            learning_system: None,
            codebase_database: None,
            project_id: None,
        };

        // Initialize with basic templates
        naming.initialize_basic_templates();
        naming
    }

    /// Initialize basic naming templates (uses existing JSON templates)
    fn initialize_basic_templates(&mut self) {
        // Load from existing priv/code_quality_templates/ JSON files
        // For now, use hardcoded rules based on existing templates

        // Elixir: snake_case (from elixir_production.json)
        self.naming_rules
            .language_conventions
            .insert("elixir".to_string(), LanguageConvention::Elixir);
        self.naming_rules
            .language_conventions
            .insert("elixir_script".to_string(), LanguageConvention::Elixir);
        self.naming_rules.language_conventions.insert(
            "elixir_script_script".to_string(),
            LanguageConvention::Elixir,
        );
        // File extensions for Elixir
        self.naming_rules
            .language_conventions
            .insert("ex".to_string(), LanguageConvention::Elixir);
        self.naming_rules
            .language_conventions
            .insert("exs".to_string(), LanguageConvention::Elixir);

        // Rust: snake_case (from rust_production.json)
        self.naming_rules
            .language_conventions
            .insert("rust".to_string(), LanguageConvention::Rust);
        // File extension for Rust
        self.naming_rules
            .language_conventions
            .insert("rs".to_string(), LanguageConvention::Rust);

        // TypeScript: camelCase (from typescript_production.json)
        self.naming_rules
            .language_conventions
            .insert("typescript".to_string(), LanguageConvention::TypeScript);
        // File extensions for TypeScript
        self.naming_rules
            .language_conventions
            .insert("ts".to_string(), LanguageConvention::TypeScript);
        self.naming_rules
            .language_conventions
            .insert("tsx".to_string(), LanguageConvention::TypeScript);

        // JavaScript: camelCase (from typescript_production.json)
        self.naming_rules
            .language_conventions
            .insert("javascript".to_string(), LanguageConvention::JavaScript);
        // File extensions for JavaScript
        self.naming_rules
            .language_conventions
            .insert("js".to_string(), LanguageConvention::JavaScript);
        self.naming_rules
            .language_conventions
            .insert("jsx".to_string(), LanguageConvention::JavaScript);

        // Python: snake_case (from python_production.json)
        self.naming_rules
            .language_conventions
            .insert("python".to_string(), LanguageConvention::Python);
        // File extension for Python
        self.naming_rules
            .language_conventions
            .insert("py".to_string(), LanguageConvention::Python);

        // Go: camelCase (from go_production.json)
        self.naming_rules
            .language_conventions
            .insert("go".to_string(), LanguageConvention::Go);
        self.naming_rules
            .language_conventions
            .insert("golang".to_string(), LanguageConvention::Go);
        // File extension for Go
        self.naming_rules
            .language_conventions
            .insert("go".to_string(), LanguageConvention::Go);

        // TODO: Load from priv/code_quality_templates/*.json files
        // This would parse the existing JSON templates for naming rules
    }

    // ============================================================================
    // NAMING SUGGESTION FUNCTIONS
    // ============================================================================

    /// Suggest function names based on description and context
    pub fn suggest_function_names(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_suggestions(description, RenameElementType::Function, context)
    }

    /// Suggest module names based on description and context
    pub fn suggest_module_names(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_suggestions(description, RenameElementType::Module, context)
    }

    /// Suggest variable names based on description and context
    pub fn suggest_variable_names(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_suggestions(description, RenameElementType::Variable, context)
    }

    /// Suggest class names based on description and context
    pub fn suggest_class_names(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_suggestions(description, RenameElementType::Class, context)
    }

    /// Suggest interface names based on description and context
    pub fn suggest_interface_names(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_suggestions(description, RenameElementType::Interface, context)
    }

    /// Suggest filename based on description and context
    pub fn suggest_filename(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_suggestions(description, RenameElementType::File, context)
    }

    /// Suggest directory name based on description and context
    pub fn suggest_directory_name(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_suggestions(description, RenameElementType::Directory, context)
    }

    /// Suggest monorepo name based on description and context
    pub fn suggest_monorepo_name(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_monorepo_suggestions(description, context)
    }

    /// Suggest library name based on description and context
    pub fn suggest_library_name(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_library_suggestions(description, context)
    }

    /// Suggest service name based on description and context
    pub fn suggest_service_name(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_suggestions(description, RenameElementType::Service, context)
    }

    /// Suggest component name based on description and context
    pub fn suggest_component_name(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_suggestions(description, RenameElementType::Component, context)
    }

    /// Suggest package name based on description and context
    pub fn suggest_package_name(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_package_suggestions(description, context)
    }

    /// Suggest database table name based on description and context
    pub fn suggest_table_name(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_database_suggestions(description, context)
    }

    /// Suggest API endpoint name based on description and context
    pub fn suggest_endpoint_name(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_api_suggestions(description, context)
    }

    /// Suggest microservice name based on description and context
    pub fn suggest_microservice_name(
        &self,
        description: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        self.generate_microservice_suggestions(description, context)
    }

    /// Suggest messaging topic name based on description and context
    pub fn suggest_topic_name(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_messaging_suggestions(description, context)
    }

    /// Suggest NATS subject name based on description and context
    pub fn suggest_nats_subject(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_nats_suggestions(description, context)
    }

    /// Suggest Kafka topic name based on description and context
    pub fn suggest_kafka_topic(&self, description: &str, context: Option<&str>) -> Vec<String> {
        self.generate_kafka_suggestions(description, context)
    }

    /// Suggest names based on detected architecture from meta-registry
    pub fn suggest_names_for_architecture(
        &self,
        description: &str,
        architecture: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        self.generate_architecture_suggestions(description, architecture, context)
    }

    // ============================================================================
    // NAMING VALIDATION FUNCTIONS
    // ============================================================================

    /// Validate if a function name follows conventions
    pub fn validate_function_name(&self, name: &str) -> bool {
        // Default: snake_case functions
        self.validate_snake_case(name)
    }

    /// Validate function name for specific language
    pub fn validate_function_name_for_language(&self, name: &str, language: &str) -> bool {
        match language.to_lowercase().as_str() {
            "elixir" | "ex" | "exs" => self.validate_snake_case(name),
            "rust" | "rs" => self.validate_snake_case(name),
            "typescript" | "ts" | "tsx" => self.validate_camel_case(name),
            "javascript" | "js" | "jsx" => self.validate_camel_case(name),
            "gleam" => self.validate_snake_case(name),
            "go" | "golang" => self.validate_camel_case(name),
            "python" | "py" => self.validate_snake_case(name),
            _ => self.validate_snake_case(name),
        }
    }

    /// Validate if a module name follows conventions
    pub fn validate_module_name(&self, name: &str) -> bool {
        // Elixir modules: PascalCase
        self.validate_pascal_case(name)
    }

    /// Validate if a variable name follows conventions
    pub fn validate_variable_name(&self, name: &str) -> bool {
        // Elixir variables: snake_case
        self.validate_snake_case(name)
    }

    /// Validate if a class name follows conventions
    pub fn validate_class_name(&self, name: &str) -> bool {
        self.validate_name(name, CodeElementType::Class)
    }

    /// Validate if an interface name follows conventions
    pub fn validate_interface_name(&self, name: &str) -> bool {
        self.validate_name(name, CodeElementType::Interface)
    }

    /// Validate if a filename follows conventions
    pub fn validate_filename(&self, name: &str) -> bool {
        self.validate_name(name, CodeElementType::File)
    }

    /// Validate if a directory name follows conventions
    pub fn validate_directory_name(&self, name: &str) -> bool {
        self.validate_name(name, CodeElementType::Directory)
    }

    // ============================================================================
    // NAMING CONVENTION DETECTION
    // ============================================================================

    /// Detect what naming convention is being used in code
    pub fn detect_naming_convention(&self, code: &str) -> NamingConvention {
        // Analyze code to detect naming patterns
        if self.has_camel_case_patterns(code) {
            NamingConvention::CamelCase
        } else if self.has_pascal_case_patterns(code) {
            NamingConvention::PascalCase
        } else if self.has_snake_case_patterns(code) {
            NamingConvention::SnakeCase
        } else if self.has_kebab_case_patterns(code) {
            NamingConvention::KebabCase
        } else {
            NamingConvention::Mixed
        }
    }

    /// Detect language-specific naming conventions
    pub fn detect_language_conventions(&self, file_path: &str) -> LanguageConvention {
        let extension = file_path.split('.').last().unwrap_or("");
        match extension {
            "rs" => LanguageConvention::Rust,
            "ex" | "exs" => LanguageConvention::Elixir,
            "js" | "ts" => LanguageConvention::JavaScript,
            "py" => LanguageConvention::Python,
            "java" => LanguageConvention::Java,
            "cs" => LanguageConvention::CSharp,
            _ => LanguageConvention::Unknown,
        }
    }

    /// Detect framework-specific naming conventions
    pub fn detect_framework_conventions(&self, framework: &str) -> FrameworkConventionEnum {
        match framework.to_lowercase().as_str() {
            "phoenix" => FrameworkConventionEnum::Phoenix,
            "actix" => FrameworkConventionEnum::Actix,
            "react" => FrameworkConventionEnum::React,
            "django" => FrameworkConventionEnum::Django,
            "rails" => FrameworkConventionEnum::Rails,
            _ => FrameworkConventionEnum::Unknown,
        }
    }

    // ============================================================================
    // NAMING RULE ENFORCEMENT
    // ============================================================================

    /// Enforce camelCase naming
    pub fn enforce_camel_case(&self, name: &str) -> String {
        self.convert_to_camel_case(name)
    }

    /// Enforce PascalCase naming
    pub fn enforce_pascal_case(&self, name: &str) -> String {
        self.convert_to_pascal_case(name)
    }

    /// Enforce snake_case naming
    pub fn enforce_snake_case(&self, name: &str) -> String {
        self.convert_to_snake_case(name)
    }

    /// Enforce kebab-case naming
    pub fn enforce_kebab_case(&self, name: &str) -> String {
        self.convert_to_kebab_case(name)
    }

    // ============================================================================
    // CONTEXT-AWARE NAMING
    // ============================================================================

    /// Generate names based on context
    pub fn suggest_names_for_context(
        &self,
        description: &str,
        element_type: RenameElementType,
        context: &CodeContext,
    ) -> Vec<String> {
        // Use context to generate more relevant names
        self.generate_contextual_suggestions(description, element_type, context)
    }

    /// Generate names for specific framework
    pub fn suggest_names_for_framework(&self, description: &str, framework: &str) -> Vec<String> {
        // Use framework-specific patterns
        self.generate_framework_suggestions(description, framework)
    }

    /// Generate names for specific domain
    pub fn suggest_names_for_domain(&self, description: &str, domain: &str) -> Vec<String> {
        // Use domain-specific patterns
        self.generate_domain_suggestions(description, domain)
    }

    // ============================================================================
    // NAMING DETECTION & FLAGGING (No Refactoring)
    // ============================================================================

    /// Detect and flag naming violations in code (for QA validation)
    pub fn detect_naming_violations(&self, code: &str) -> NamingDetectionReport {
        let violations = self.find_naming_violations(code);
        let explanations = self.generate_explanations(&violations);
        let quality_score = self.calculate_quality_score(&violations);

        NamingDetectionReport {
            quality_score,
            violations: violations.clone(),
            explanations,
            total_elements: self.count_named_elements(code),
            detection_status: self.determine_detection_status(&violations),
            flagged_for_refactor: self.flag_for_refactor(&violations),
            summary: self.generate_summary(&violations),
        }
    }

    /// Flag violations for refactoring (no actual refactoring)
    pub fn flag_for_refactor(&self, violations: &[NamingViolation]) -> Vec<RefactorFlag> {
        violations
            .iter()
            .map(|violation| RefactorFlag {
                element_type: violation.element_type.clone(),
                name: violation.name.clone(),
                current_name: violation.name.clone(),
                suggested_name: violation.suggested_fix.clone(),
                reason: self.explain_naming_issue(violation),
                priority: self.determine_priority(violation),
                refactor_type: self.determine_refactor_type(violation),
                line_number: violation.line_number.unwrap_or(0) as usize,
            })
            .collect()
    }

    /// Determine detection status (Pass/Warning/Fail)
    pub fn determine_detection_status(&self, violations: &[NamingViolation]) -> DetectionStatus {
        if violations.is_empty() {
            DetectionStatus::Pass
        } else {
            let critical_count = violations
                .iter()
                .filter(|v| self.is_critical_violation(v))
                .count();
            if critical_count > 0 {
                DetectionStatus::Fail
            } else {
                DetectionStatus::Warning
            }
        }
    }

    /// Generate summary of naming issues
    pub fn generate_summary(&self, violations: &[NamingViolation]) -> NamingSummary {
        let mut function_count = 0;
        let mut module_count = 0;
        let mut variable_count = 0;
        let mut critical_count = 0;

        for violation in violations {
            match violation.element_type.as_str() {
                "function" => function_count += 1,
                "module" => module_count += 1,
                "variable" => variable_count += 1,
                _ => {}
            }
            if self.is_critical_violation(violation) {
                critical_count += 1;
            }
        }

        NamingSummary {
            total_violations: violations.len(),
            function_violations: function_count,
            module_violations: module_count,
            variable_violations: variable_count,
            critical_violations: critical_count,
            needs_refactor: violations.len() > 0,
            refactor_priority: if critical_count > 0 {
                "High"
            } else if violations.len() > 5 {
                "Medium"
            } else {
                "Low"
            }
            .to_string(),
        }
    }

    /// Determine priority for refactoring
    fn determine_priority(&self, violation: &NamingViolation) -> RefactorPriority {
        match self.determine_severity(violation) {
            Severity::Critical => RefactorPriority::High,
            Severity::High => RefactorPriority::High,
            Severity::Medium => RefactorPriority::Medium,
            Severity::Low => RefactorPriority::Low,
        }
    }

    /// Determine type of refactoring needed
    fn determine_refactor_type(&self, violation: &NamingViolation) -> RefactorType {
        match violation.element_type.as_str() {
            "function" => RefactorType::RenameFunction,
            "module" => RefactorType::RenameModule,
            "variable" => RefactorType::RenameVariable,
            _ => RefactorType::RenameElement,
        }
    }

    /// Generate detailed explanations for naming issues
    pub fn generate_explanations(&self, violations: &[NamingViolation]) -> Vec<NamingExplanation> {
        violations
            .iter()
            .map(|violation| NamingExplanation {
                element_type: violation.element_type.clone(),
                name: violation.name.clone(),
                issue: violation.message.clone(),
                explanation: self.explain_naming_issue(violation),
                examples: self.provide_examples(violation),
                severity: self.determine_severity(violation),
                fix_suggestion: violation.suggested_fix.clone(),
            })
            .collect()
    }

    /// Determine lint status based on violations
    pub fn determine_lint_status(&self, violations: &[NamingViolation]) -> LintStatus {
        if violations.is_empty() {
            LintStatus::Pass
        } else {
            let critical_count = violations
                .iter()
                .filter(|v| self.is_critical_violation(v))
                .count();
            if critical_count > 0 {
                LintStatus::Fail
            } else {
                LintStatus::Warning
            }
        }
    }

    /// Generate recommendations for improving naming
    pub fn generate_recommendations(
        &self,
        violations: &[NamingViolation],
    ) -> Vec<NamingRecommendation> {
        let mut recommendations = Vec::new();

        // Group violations by type
        let mut function_violations = 0;
        let mut module_violations = 0;
        let mut variable_violations = 0;

        for violation in violations {
            match violation.element_type.as_str() {
                "function" => function_violations += 1,
                "module" => module_violations += 1,
                "variable" => variable_violations += 1,
                _ => {}
            }
        }

        // Generate specific recommendations
        if function_violations > 0 {
            recommendations.push(NamingRecommendation {
                category: "Functions".to_string(),
                issue: format!("{} function naming violations found", function_violations),
                recommendation:
                    "Use camelCase for function names (e.g., calculateTotal, processUserData)"
                        .to_string(),
                examples: vec![
                    "calculateTotal".to_string(),
                    "processUserData".to_string(),
                    "validateInput".to_string(),
                ],
                priority: if function_violations > 5 {
                    Priority::High
                } else {
                    Priority::Medium
                },
            });
        }

        if module_violations > 0 {
            recommendations.push(NamingRecommendation {
                category: "Modules".to_string(),
                issue: format!("{} module naming violations found", module_violations),
                recommendation: "Use PascalCase for module names (e.g., UserManager, DataProcessor)".to_string(),
                examples: vec![
                    "UserManager".to_string(),
                    "DataProcessor".to_string(),
                    "AuthenticationService".to_string(),
                ],
                priority: if module_violations > 3 { Priority::High } else { Priority::Medium },
            });
        }

        if variable_violations > 0 {
            recommendations.push(NamingRecommendation {
                category: "Variables".to_string(),
                issue: format!("{} variable naming violations found", variable_violations),
                recommendation: "Use camelCase for variable names (e.g., userCount, isValid)"
                    .to_string(),
                examples: vec![
                    "userCount".to_string(),
                    "isValid".to_string(),
                    "totalPrice".to_string(),
                ],
                priority: if variable_violations > 10 {
                    Priority::High
                } else {
                    Priority::Low
                },
            });
        }

        recommendations
    }

    /// Explain a specific naming issue
    fn explain_naming_issue(&self, violation: &NamingViolation) -> String {
        match violation.element_type.as_str() {
            "function" => {
                if violation.name.chars().next().unwrap().is_uppercase() {
                    "Function names should start with lowercase letter (camelCase)".to_string()
                } else if violation.name.contains('_') {
                    "Function names should use camelCase, not snake_case".to_string()
                } else if violation.name.contains('-') {
                    "Function names should use camelCase, not kebab-case".to_string()
                } else {
                    "Function name doesn't follow camelCase convention".to_string()
                }
            }
            "module" => {
                if violation.name.chars().next().unwrap().is_lowercase() {
                    "Module names should start with uppercase letter (PascalCase)".to_string()
                } else if violation.name.contains('_') {
                    "Module names should use PascalCase, not snake_case".to_string()
                } else if violation.name.contains('-') {
                    "Module names should use PascalCase, not kebab-case".to_string()
                } else {
                    "Module name doesn't follow PascalCase convention".to_string()
                }
            }
            "variable" => {
                if violation.name.chars().next().unwrap().is_uppercase() {
                    "Variable names should start with lowercase letter (camelCase)".to_string()
                } else if violation.name.contains('_') {
                    "Variable names should use camelCase, not snake_case".to_string()
                } else if violation.name.contains('-') {
                    "Variable names should use camelCase, not kebab-case".to_string()
                } else {
                    "Variable name doesn't follow camelCase convention".to_string()
                }
            }
            _ => "Naming convention violation".to_string(),
        }
    }

    /// Provide examples for naming conventions
    fn provide_examples(&self, violation: &NamingViolation) -> Vec<String> {
        match violation.element_type.as_str() {
            "function" => vec![
                "calculateTotal".to_string(),
                "processUserData".to_string(),
                "validateInput".to_string(),
                "handleError".to_string(),
            ],
            "module" => vec![
                "UserManager".to_string(),
                "DataProcessor".to_string(),
                "AuthenticationService".to_string(),
                "EmailHandler".to_string(),
            ],
            "variable" => vec![
                "userCount".to_string(),
                "isValid".to_string(),
                "totalPrice".to_string(),
                "hasPermission".to_string(),
            ],
            _ => vec![],
        }
    }

    /// Determine severity of a violation
    fn determine_severity(&self, violation: &NamingViolation) -> Severity {
        match violation.element_type.as_str() {
            "function" => {
                if violation.name.is_empty() || violation.name.len() < 2 {
                    Severity::Critical
                } else if violation.name.chars().next().unwrap().is_uppercase() {
                    Severity::High
                } else {
                    Severity::Medium
                }
            }
            "module" => {
                if violation.name.is_empty() || violation.name.len() < 2 {
                    Severity::Critical
                } else if violation.name.chars().next().unwrap().is_lowercase() {
                    Severity::High
                } else {
                    Severity::Medium
                }
            }
            "variable" => {
                if violation.name.is_empty() {
                    Severity::Critical
                } else if violation.name.chars().next().unwrap().is_uppercase() {
                    Severity::High
                } else {
                    Severity::Low
                }
            }
            _ => Severity::Medium,
        }
    }

    /// Check if a violation is critical
    fn is_critical_violation(&self, violation: &NamingViolation) -> bool {
        self.determine_severity(violation) == Severity::Critical
    }

    // ============================================================================
    // NAMING QUALITY ANALYSIS (Legacy - kept for compatibility)
    // ============================================================================

    /// Analyze naming quality in code
    pub fn analyze_naming_quality(&self, code: &str) -> NamingQualityReport {
        let violations = self.find_naming_violations(code);
        let improvements = self.suggest_naming_improvements(code);
        let overall_score = self.calculate_quality_score(&violations);

        NamingQualityReport {
            overall_score,
            violations,
            improvements,
            total_elements: self.count_named_elements(code),
            quality_level: "unknown".to_string(),
        }
    }

    /// Find naming violations in code
    pub fn find_naming_violations(&self, code: &str) -> Vec<NamingViolation> {
        let mut violations = Vec::new();

        // Find function naming violations
        for func in self.extract_functions(code) {
            if !self.validate_function_name(&func.name) {
                violations.push(NamingViolation {
                    element_type: "function".to_string(),
                    name: func.name,
                    violation_type: "naming".to_string(),
                    severity: "low".to_string(),
                    message: "Function name doesn't follow conventions".to_string(),
                    line_number: Some(func.line as u32),
                    suggested_fix: self
                        .suggest_function_names(&func.description, None)
                        .first()
                        .cloned(),
                });
            }
        }

        // Find module naming violations
        for module in self.extract_modules(code) {
            if !self.validate_module_name(&module.name) {
                violations.push(NamingViolation {
                    element_type: "module".to_string(),
                    name: module.name,
                    violation_type: "naming".to_string(),
                    severity: "low".to_string(),
                    message: "Module name doesn't follow conventions".to_string(),
                    line_number: Some(module.line as u32),
                    suggested_fix: self
                        .suggest_module_names(&module.description, None)
                        .first()
                        .cloned(),
                });
            }
        }

        violations
    }

    /// Suggest naming improvements
    pub fn suggest_naming_improvements(&self, code: &str) -> Vec<NamingImprovement> {
        let mut improvements = Vec::new();

        for violation in self.find_naming_violations(code) {
            if let Some(suggestion) = violation.suggested_fix {
                improvements.push(NamingImprovement {
                    original_name: violation.name,
                    improved_name: suggestion,
                    element_type: violation.element_type,
                    improvement_type: "naming".to_string(),
                    confidence: 0.8,
                    explanation: violation.message,
                });
            }
        }

        improvements
    }

    // ============================================================================
    // LANGUAGE-SPECIFIC NAMING
    // ============================================================================

    /// Get Elixir naming rules
    pub fn get_elixir_naming_rules(&self) -> NamingRules {
        NamingRules {
            language_conventions: HashMap::from([
                ("function".to_string(), LanguageConvention::Elixir),
                ("module".to_string(), LanguageConvention::Elixir),
                ("variable".to_string(), LanguageConvention::Elixir),
            ]),
            framework_overrides: HashMap::new(),
            project_patterns: HashMap::new(),
            quality_thresholds: QualityThresholds::default(),
        }
    }

    /// Get Rust naming rules
    pub fn get_rust_naming_rules(&self) -> NamingRules {
        NamingRules {
            language_conventions: HashMap::from([
                ("function".to_string(), LanguageConvention::Rust),
                ("module".to_string(), LanguageConvention::Rust),
                ("variable".to_string(), LanguageConvention::Rust),
            ]),
            framework_overrides: HashMap::new(),
            project_patterns: HashMap::new(),
            quality_thresholds: QualityThresholds::default(),
        }
    }

    /// Get JavaScript naming rules
    pub fn get_javascript_naming_rules(&self) -> NamingRules {
        NamingRules {
            language_conventions: HashMap::from([
                ("function".to_string(), LanguageConvention::JavaScript),
                ("module".to_string(), LanguageConvention::JavaScript),
                ("variable".to_string(), LanguageConvention::JavaScript),
            ]),
            framework_overrides: HashMap::new(),
            project_patterns: HashMap::new(),
            quality_thresholds: QualityThresholds::default(),
        }
    }

    /// Get Python naming rules
    pub fn get_python_naming_rules(&self) -> NamingRules {
        NamingRules {
            language_conventions: HashMap::from([
                ("function".to_string(), LanguageConvention::Python),
                ("module".to_string(), LanguageConvention::Python),
                ("variable".to_string(), LanguageConvention::Python),
            ]),
            framework_overrides: HashMap::new(),
            project_patterns: HashMap::new(),
            quality_thresholds: QualityThresholds::default(),
        }
    }

    // ============================================================================
    // FRAMEWORK-SPECIFIC NAMING
    // ============================================================================

    /// Get Phoenix naming patterns
    pub fn get_phoenix_naming_patterns(&self) -> Vec<String> {
        vec![
            "UserController".to_string(),
            "UserView".to_string(),
            "UserSchema".to_string(),
            "UserContext".to_string(),
        ]
    }

    /// Get Actix naming patterns
    pub fn get_actix_naming_patterns(&self) -> Vec<String> {
        vec![
            "UserHandler".to_string(),
            "UserService".to_string(),
            "UserRepository".to_string(),
            "UserModel".to_string(),
        ]
    }

    /// Get React naming patterns
    pub fn get_react_naming_patterns(&self) -> Vec<String> {
        vec![
            "UserComponent".to_string(),
            "UserHook".to_string(),
            "UserContext".to_string(),
            "UserProvider".to_string(),
        ]
    }

    /// Get Django naming patterns
    pub fn get_django_naming_patterns(&self) -> Vec<String> {
        vec![
            "UserModel".to_string(),
            "UserView".to_string(),
            "UserSerializer".to_string(),
            "UserForm".to_string(),
        ]
    }

    // ============================================================================
    // PRIVATE HELPER METHODS
    // ============================================================================

    /// Generate self-explanatory function suggestions based on action and context
    fn generate_function_suggestions(
        &self,
        base_name: &str,
        description: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        let mut suggestions = Vec::new();

        // Extract action verbs from description
        let actions = self.extract_actions(description);
        let objects = self.extract_objects(description);
        let context_hints = self.extract_context_hints(context);

        // Primary suggestion: clean base name
        suggestions.push(base_name.to_string());

        // Action-based suggestions
        for action in &actions {
            for object in &objects {
                let suggestion = format!("{}_{}", action, object);
                if !suggestions.contains(&suggestion) {
                    suggestions.push(suggestion);
                }
            }
        }

        // Context-aware suggestions
        if let Some(ctx) = context_hints {
            for action in &actions {
                let suggestion = format!("{}_{}", action, ctx);
                if !suggestions.contains(&suggestion) {
                    suggestions.push(suggestion);
                }
            }
        }

        // Domain-specific suggestions
        let domain_suggestions = self.generate_domain_function_suggestions(description, context);
        suggestions.extend(domain_suggestions);

        // Remove duplicates and limit to 5 best suggestions
        suggestions.sort();
        suggestions.dedup();
        suggestions.truncate(5);

        suggestions
    }

    /// Extract action verbs from description
    fn extract_actions(&self, description: &str) -> Vec<String> {
        let action_patterns = [
            "calculate",
            "compute",
            "suggest",
            "validate",
            "extract",
            "generate",
            "create",
            "build",
            "parse",
            "analyze",
            "detect",
            "check",
            "verify",
            "process",
            "handle",
            "manage",
            "store",
            "retrieve",
            "search",
            "find",
            "update",
            "delete",
            "insert",
            "remove",
            "add",
            "get",
            "set",
            "load",
            "save",
            "export",
            "import",
            "transform",
            "convert",
            "format",
            "render",
        ];

        let description_lower = description.to_lowercase();
        let mut actions = Vec::new();

        for pattern in &action_patterns {
            if description_lower.contains(pattern) {
                actions.push(pattern.to_string());
            }
        }

        // If no actions found, use common ones based on context
        if actions.is_empty() {
            if description_lower.contains("name") || description_lower.contains("suggest") {
                actions.push("suggest".to_string());
            } else if description_lower.contains("check") || description_lower.contains("valid") {
                actions.push("validate".to_string());
            } else if description_lower.contains("get") || description_lower.contains("find") {
                actions.push("get".to_string());
            } else {
                actions.push("process".to_string());
            }
        }

        actions
    }

    /// Extract objects/nouns from description
    fn extract_objects(&self, description: &str) -> Vec<String> {
        let object_patterns = [
            "name",
            "names",
            "convention",
            "conventions",
            "function",
            "functions",
            "module",
            "modules",
            "variable",
            "variables",
            "class",
            "classes",
            "interface",
            "interfaces",
            "file",
            "files",
            "directory",
            "directories",
            "service",
            "services",
            "component",
            "components",
            "package",
            "packages",
            "table",
            "tables",
            "endpoint",
            "endpoints",
            "topic",
            "topics",
            "subject",
            "subjects",
            "pattern",
            "patterns",
            "rule",
            "rules",
        ];

        let description_lower = description.to_lowercase();
        let mut objects = Vec::new();

        for pattern in &object_patterns {
            if description_lower.contains(pattern) {
                objects.push(pattern.to_string());
            }
        }

        // If no objects found, extract from description
        if objects.is_empty() {
            let words: Vec<&str> = description_lower.split_whitespace().collect();
            for word in words {
                if word.len() > 3 && !self.is_action_word(word) {
                    objects.push(word.to_string());
                }
            }
        }

        objects
    }

    /// Extract context hints from context string
    fn extract_context_hints(&self, context: Option<&str>) -> Option<String> {
        context.and_then(|ctx| {
            let ctx_lower = ctx.to_lowercase();
            if ctx_lower.contains("elixir") || ctx_lower.contains("ex") {
                Some("elixir".to_string())
            } else if ctx_lower.contains("rust") || ctx_lower.contains("rs") {
                Some("rust".to_string())
            } else if ctx_lower.contains("typescript") || ctx_lower.contains("ts") {
                Some("typescript".to_string())
            } else if ctx_lower.contains("javascript") || ctx_lower.contains("js") {
                Some("javascript".to_string())
            } else if ctx_lower.contains("gleam") {
                Some("gleam".to_string())
            } else if ctx_lower.contains("go") || ctx_lower.contains("golang") {
                Some("go".to_string())
            } else if ctx_lower.contains("python") || ctx_lower.contains("py") {
                Some("python".to_string())
            } else if ctx_lower.contains("naming") {
                Some("naming".to_string())
            } else if ctx_lower.contains("architecture") {
                Some("architecture".to_string())
            } else {
                None
            }
        })
    }

    /// Check if word is an action verb
    fn is_action_word(&self, word: &str) -> bool {
        let action_words = [
            "the", "and", "or", "for", "with", "from", "to", "in", "on", "at", "by", "of", "a",
            "an", "is", "are", "was", "were", "be", "been", "have", "has", "had", "do", "does",
            "did", "will", "would", "could", "should", "may", "might", "can", "must", "shall",
        ];
        action_words.contains(&word)
    }

    /// Generate domain-specific function suggestions
    fn generate_domain_function_suggestions(
        &self,
        description: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        let mut suggestions = Vec::new();
        let description_lower = description.to_lowercase();

        // Naming domain
        if description_lower.contains("name") || description_lower.contains("naming") {
            suggestions.extend(vec![
                "suggest_names".to_string(),
                "generate_names".to_string(),
                "create_names".to_string(),
                "propose_names".to_string(),
                "recommend_names".to_string(),
            ]);
        }

        // Validation domain
        if description_lower.contains("valid") || description_lower.contains("check") {
            suggestions.extend(vec![
                "validate_input".to_string(),
                "check_validity".to_string(),
                "verify_format".to_string(),
                "ensure_valid".to_string(),
            ]);
        }

        // Architecture domain
        if description_lower.contains("architect") || description_lower.contains("pattern") {
            suggestions.extend(vec![
                "detect_patterns".to_string(),
                "analyze_architecture".to_string(),
                "identify_patterns".to_string(),
                "classify_architecture".to_string(),
            ]);
        }

        // Code analysis domain
        if description_lower.contains("code") || description_lower.contains("analyze") {
            suggestions.extend(vec![
                "analyze_code".to_string(),
                "examine_code".to_string(),
                "inspect_code".to_string(),
                "review_code".to_string(),
            ]);
        }

        suggestions
    }

    /// Extract base name from description
    fn extract_base_name(&self, description: &str) -> String {
        // Simple extraction: take first few words and join with underscores
        let words: Vec<String> = description
            .split_whitespace()
            .take(3)
            .map(|w| w.to_lowercase())
            .collect();
        words.join("_")
    }

    /// Generate suggestions for a given element type
    fn generate_suggestions(
        &self,
        description: &str,
        element_type: RenameElementType,
        context: Option<&str>,
    ) -> Vec<String> {
        let base_name = self.extract_base_name(description);

        match element_type {
            RenameElementType::Function => {
                // Generate self-explanatory function names based on action and context
                self.generate_function_suggestions(&base_name, description, context)
            }
            RenameElementType::Module => {
                // Default: PascalCase modules (Elixir, TypeScript classes)
                let pascal_case = self.to_pascal_case(&base_name);
                vec![
                    pascal_case.clone(),
                    format!("{}Module", pascal_case),
                    format!("{}Service", pascal_case),
                    format!("{}Handler", pascal_case),
                    format!("{}Manager", pascal_case),
                ]
            }
            RenameElementType::Variable => {
                // Default: snake_case variables (Elixir, Rust, Gleam)
                vec![
                    base_name.clone(),
                    format!("{}_var", base_name),
                    format!("current_{}", base_name),
                    format!("{}_value", base_name),
                    format!("{}_data", base_name),
                ]
            }
            _ => vec![base_name],
        }
    }

    // Small wrappers for previously referenced generate_* functions
    fn generate_messaging_suggestions(
        &self,
        description: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        // Default to microservice/topic style suggestions
        self.generate_microservice_suggestions(description, context)
    }

    fn generate_nats_suggestions(&self, description: &str, context: Option<&str>) -> Vec<String> {
        // NATS subjects follow dot-separated formats; convert kebab to dots
        let mut suggestions = Vec::new();
        for s in self.generate_microservice_suggestions(description, context) {
            suggestions.push(s.replace('-', "."));
        }
        suggestions
    }

    fn generate_kafka_suggestions(&self, description: &str, context: Option<&str>) -> Vec<String> {
        // Kafka topics are similar to NATS but often kebab-case; reuse microservice suggestions
        self.generate_microservice_suggestions(description, context)
    }

    fn generate_architecture_suggestions(
        &self,
        description: &str,
        _architecture: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        // For now, delegate to microservice suggestions
        self.generate_microservice_suggestions(description, context)
    }

    fn validate_name(&self, name: &str, _element_type: CodeElementType) -> bool {
        // Default validation: accept snake_case or camelCase depending on simple heuristic
        // Reuse filename validation for simplicity
        self.validate_filename(name)
    }

    /// Generate suggestions for specific language
    pub fn suggest_names_for_language(
        &self,
        description: &str,
        element_type: RenameElementType,
        language: &str,
    ) -> Vec<String> {
        let base_name = description
            .to_lowercase()
            .replace(" ", "_")
            .replace("-", "_");

        match language.to_lowercase().as_str() {
            "elixir" | "ex" | "exs" => self.generate_elixir_suggestions(&base_name, element_type),
            "rust" | "rs" => self.generate_rust_suggestions(&base_name, element_type),
            "typescript" | "ts" | "tsx" => {
                self.generate_typescript_suggestions(&base_name, element_type)
            }
            "javascript" | "js" | "jsx" => {
                self.generate_javascript_suggestions(&base_name, element_type)
            }
            "gleam" => self.generate_gleam_suggestions(&base_name, element_type),
            "go" | "golang" => self.generate_go_suggestions(&base_name, element_type),
            "python" | "py" => self.generate_python_suggestions(&base_name, element_type),
            _ => self.generate_suggestions(description, element_type, None),
        }
    }

    /// Generate Elixir naming suggestions
    fn generate_elixir_suggestions(
        &self,
        base_name: &str,
        element_type: RenameElementType,
    ) -> Vec<String> {
        match element_type {
            RenameElementType::Function => {
                // Elixir: snake_case functions
                vec![
                    base_name.to_string(),
                    format!("{}_function", base_name),
                    format!("handle_{}", base_name),
                    format!("process_{}", base_name),
                ]
            }
            RenameElementType::Module => {
                // Elixir: PascalCase modules
                let pascal_case = self.to_pascal_case(base_name);
                vec![
                    pascal_case.clone(),
                    format!("{}Module", pascal_case),
                    format!("{}Service", pascal_case),
                    format!("{}Handler", pascal_case),
                ]
            }
            RenameElementType::Variable => {
                // Elixir: snake_case variables
                vec![
                    base_name.to_string(),
                    format!("{}_var", base_name),
                    format!("current_{}", base_name),
                ]
            }
            RenameElementType::File => {
                // Elixir: snake_case files
                vec![
                    format!("{}.ex", base_name),
                    format!("{}_test.ex", base_name),
                    format!("{}_test.exs", base_name),
                ]
            }
            RenameElementType::Directory => {
                // Elixir: snake_case directories
                vec![
                    base_name.to_string(),
                    format!("{}_lib", base_name),
                    format!("{}_test", base_name),
                ]
            }
            _ => vec![base_name.to_string()],
        }
    }

    /// Generate Rust naming suggestions
    fn generate_rust_suggestions(
        &self,
        base_name: &str,
        element_type: RenameElementType,
    ) -> Vec<String> {
        match element_type {
            RenameElementType::Function => {
                // Rust: snake_case functions
                vec![
                    base_name.to_string(),
                    format!("{}_function", base_name),
                    format!("handle_{}", base_name),
                    format!("process_{}", base_name),
                ]
            }
            RenameElementType::Module => {
                // Rust: snake_case modules
                vec![
                    base_name.to_string(),
                    format!("{}_module", base_name),
                    format!("{}_service", base_name),
                    format!("{}_handler", base_name),
                ]
            }
            RenameElementType::Variable => {
                // Rust: snake_case variables
                vec![
                    base_name.to_string(),
                    format!("{}_var", base_name),
                    format!("current_{}", base_name),
                ]
            }
            _ => vec![base_name.to_string()],
        }
    }

    /// Generate TypeScript naming suggestions
    fn generate_typescript_suggestions(
        &self,
        base_name: &str,
        element_type: RenameElementType,
    ) -> Vec<String> {
        match element_type {
            RenameElementType::Function => {
                // TypeScript: camelCase functions
                let camel_case = self.to_camel_case(base_name);
                vec![
                    camel_case.clone(),
                    format!("{}Function", camel_case),
                    format!("handle{}", self.to_pascal_case(base_name)),
                ]
            }
            RenameElementType::Module => {
                // TypeScript: PascalCase classes/modules
                let pascal_case = self.to_pascal_case(base_name);
                vec![
                    pascal_case.clone(),
                    format!("{}Module", pascal_case),
                    format!("{}Service", pascal_case),
                    format!("{}Handler", pascal_case),
                ]
            }
            RenameElementType::Variable => {
                // TypeScript: camelCase variables
                let camel_case = self.to_camel_case(base_name);
                vec![
                    camel_case.clone(),
                    format!("{}Var", camel_case),
                    format!("current{}", self.to_pascal_case(base_name)),
                ]
            }
            _ => vec![base_name.to_string()],
        }
    }

    /// Generate Gleam naming suggestions
    fn generate_gleam_suggestions(
        &self,
        base_name: &str,
        element_type: RenameElementType,
    ) -> Vec<String> {
        match element_type {
            RenameElementType::Function => {
                // Gleam: snake_case functions
                vec![
                    base_name.to_string(),
                    format!("{}_function", base_name),
                    format!("handle_{}", base_name),
                    format!("process_{}", base_name),
                ]
            }
            RenameElementType::Module => {
                // Gleam: snake_case modules
                vec![
                    base_name.to_string(),
                    format!("{}_module", base_name),
                    format!("{}_service", base_name),
                    format!("{}_handler", base_name),
                ]
            }
            RenameElementType::Variable => {
                // Gleam: snake_case variables
                vec![
                    base_name.to_string(),
                    format!("{}_var", base_name),
                    format!("current_{}", base_name),
                ]
            }
            _ => vec![base_name.to_string()],
        }
    }

    /// Generate Go naming suggestions
    fn generate_go_suggestions(
        &self,
        base_name: &str,
        element_type: RenameElementType,
    ) -> Vec<String> {
        match element_type {
            RenameElementType::Function => {
                // Go: camelCase functions (exported start with uppercase)
                let camel_case = self.to_camel_case(base_name);
                vec![
                    camel_case.clone(),
                    format!("{}Func", camel_case),
                    format!("Handle{}", self.to_pascal_case(base_name)),
                    format!("Process{}", self.to_pascal_case(base_name)),
                ]
            }
            RenameElementType::Module => {
                // Go: PascalCase packages
                let pascal_case = self.to_pascal_case(base_name);
                vec![
                    pascal_case.clone(),
                    format!("{}Package", pascal_case),
                    format!("{}Service", pascal_case),
                    format!("{}Handler", pascal_case),
                ]
            }
            RenameElementType::Variable => {
                // Go: camelCase variables
                let camel_case = self.to_camel_case(base_name);
                vec![
                    camel_case.clone(),
                    format!("{}Var", camel_case),
                    format!("current{}", self.to_pascal_case(base_name)),
                    format!("{}Value", camel_case),
                ]
            }
            _ => vec![base_name.to_string()],
        }
    }

    /// Generate Python naming suggestions
    fn generate_python_suggestions(
        &self,
        base_name: &str,
        element_type: RenameElementType,
    ) -> Vec<String> {
        match element_type {
            RenameElementType::Function => {
                // Python: snake_case functions
                vec![
                    base_name.to_string(),
                    format!("{}_function", base_name),
                    format!("handle_{}", base_name),
                    format!("process_{}", base_name),
                ]
            }
            RenameElementType::Module => {
                // Python: PascalCase classes
                let pascal_case = self.to_pascal_case(base_name);
                vec![
                    pascal_case.clone(),
                    format!("{}Class", pascal_case),
                    format!("{}Service", pascal_case),
                    format!("{}Handler", pascal_case),
                ]
            }
            RenameElementType::Variable => {
                // Python: snake_case variables
                vec![
                    base_name.to_string(),
                    format!("{}_var", base_name),
                    format!("current_{}", base_name),
                ]
            }
            _ => vec![base_name.to_string()],
        }
    }

    /// Generate JavaScript naming suggestions
    fn generate_javascript_suggestions(
        &self,
        base_name: &str,
        element_type: RenameElementType,
    ) -> Vec<String> {
        match element_type {
            RenameElementType::Function => {
                // JavaScript: camelCase functions
                let camel_case = self.to_camel_case(base_name);
                vec![
                    camel_case.clone(),
                    format!("{}Func", camel_case),
                    format!("handle{}", self.to_pascal_case(base_name)),
                    format!("process{}", self.to_pascal_case(base_name)),
                ]
            }
            RenameElementType::Module => {
                // JavaScript: PascalCase classes/modules
                let pascal_case = self.to_pascal_case(base_name);
                vec![
                    pascal_case.clone(),
                    format!("{}Module", pascal_case),
                    format!("{}Service", pascal_case),
                    format!("{}Handler", pascal_case),
                ]
            }
            RenameElementType::Variable => {
                // JavaScript: camelCase variables
                let camel_case = self.to_camel_case(base_name);
                vec![
                    camel_case.clone(),
                    format!("{}Var", camel_case),
                    format!("current{}", self.to_pascal_case(base_name)),
                    format!("{}Value", camel_case),
                ]
            }
            _ => vec![base_name.to_string()],
        }
    }

    /// Convert to camelCase (Elixir functions)
    fn to_camel_case(&self, name: &str) -> String {
        let words: Vec<&str> = name.split(['_', '-', ' ']).collect();
        let mut result = String::new();

        for (i, word) in words.iter().enumerate() {
            if i == 0 {
                result.push_str(&word.to_lowercase());
            } else {
                let capitalized = word
                    .chars()
                    .next()
                    .unwrap()
                    .to_uppercase()
                    .collect::<String>()
                    + &word[1..].to_lowercase();
                result.push_str(&capitalized);
            }
        }

        result
    }

    /// Convert to PascalCase (Elixir modules)
    fn to_pascal_case(&self, name: &str) -> String {
        let words: Vec<&str> = name.split(['_', '-', ' ']).collect();
        words
            .iter()
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    Some(first) => {
                        first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase()
                    }
                    None => String::new(),
                }
            })
            .collect()
    }

    /// Convert to camelCase
    fn convert_to_camel_case(&self, name: &str) -> String {
        let words: Vec<&str> = name.split(['_', '-', ' ']).collect();
        let mut result = String::new();

        for (i, word) in words.iter().enumerate() {
            if i == 0 {
                result.push_str(&word.to_lowercase());
            } else {
                let capitalized = word
                    .chars()
                    .next()
                    .unwrap()
                    .to_uppercase()
                    .collect::<String>()
                    + &word[1..].to_lowercase();
                result.push_str(&capitalized);
            }
        }

        result
    }

    /// Convert to PascalCase
    fn convert_to_pascal_case(&self, name: &str) -> String {
        let words: Vec<&str> = name.split(['_', '-', ' ']).collect();
        words
            .iter()
            .map(|word| {
                word.chars()
                    .next()
                    .unwrap()
                    .to_uppercase()
                    .collect::<String>()
                    + &word[1..].to_lowercase()
            })
            .collect()
    }

    /// Convert to snake_case
    fn convert_to_snake_case(&self, name: &str) -> String {
        name.chars()
            .map(|c| {
                if c.is_uppercase() {
                    format!("_{}", c.to_lowercase())
                } else {
                    c.to_string()
                }
            })
            .collect::<String>()
            .trim_start_matches('_')
            .to_string()
    }

    /// Convert to kebab-case
    fn convert_to_kebab_case(&self, name: &str) -> String {
        self.convert_to_snake_case(name).replace('_', "-")
    }

    /// Convert to kebab-case (public method)
    fn to_kebab_case(&self, input: &str) -> String {
        self.convert_to_kebab_case(input)
    }

    /// Convert to snake_case (public method)
    fn to_snake_case(&self, input: &str) -> String {
        self.convert_to_snake_case(input)
    }

    /// Validate snake_case naming
    fn validate_snake_case(&self, name: &str) -> bool {
        if name.is_empty() || name.len() > 100 {
            return false;
        }

        // Must start with lowercase letter
        if !name.chars().next().unwrap().is_lowercase() {
            return false;
        }

        // Can contain lowercase letters, numbers, and underscores
        name.chars()
            .all(|c| c.is_lowercase() || c.is_numeric() || c == '_')
    }

    /// Validate PascalCase naming
    fn validate_pascal_case(&self, name: &str) -> bool {
        if name.is_empty() || name.len() > 100 {
            return false;
        }

        // Must start with uppercase letter
        if !name.chars().next().unwrap().is_uppercase() {
            return false;
        }

        // Can contain letters and numbers, no underscores
        name.chars().all(|c| c.is_alphabetic() || c.is_numeric())
    }

    /// Validate camelCase naming
    fn validate_camel_case(&self, name: &str) -> bool {
        if name.is_empty() || name.len() > 100 {
            return false;
        }

        // Must start with lowercase letter
        if !name.chars().next().unwrap().is_lowercase() {
            return false;
        }

        // Can contain letters and numbers, no underscores
        name.chars().all(|c| c.is_alphabetic() || c.is_numeric())
    }

    /// Check for camelCase patterns
    fn has_camel_case_patterns(&self, code: &str) -> bool {
        code.contains("camelCase") || code.contains("functionName")
    }

    /// Check for PascalCase patterns
    fn has_pascal_case_patterns(&self, code: &str) -> bool {
        code.contains("PascalCase") || code.contains("ClassName")
    }

    /// Check for snake_case patterns
    fn has_snake_case_patterns(&self, code: &str) -> bool {
        code.contains("snake_case") || code.contains("function_name")
    }

    /// Check for kebab-case patterns
    fn has_kebab_case_patterns(&self, code: &str) -> bool {
        code.contains("kebab-case") || code.contains("function-name")
    }

    /// Generate contextual suggestions
    fn generate_contextual_suggestions(
        &self,
        description: &str,
        element_type: RenameElementType,
        context: &CodeContext,
    ) -> Vec<String> {
        // Use context to generate more relevant names
        self.generate_suggestions(description, element_type, None)
    }

    /// Generate framework suggestions
    fn generate_framework_suggestions(&self, description: &str, framework: &str) -> Vec<String> {
        // Use framework-specific patterns
        self.generate_suggestions(description, RenameElementType::Function, None)
    }

    /// Generate domain suggestions
    fn generate_domain_suggestions(&self, description: &str, domain: &str) -> Vec<String> {
        // Use domain-specific patterns
        self.generate_suggestions(description, RenameElementType::Function, None)
    }

    /// Generate complex monorepo naming suggestions (HashiCorp, Google style)
    fn generate_monorepo_suggestions(
        &self,
        description: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        let base_name = self.extract_base_name(description);
        let mut suggestions = Vec::new();

        // HashiCorp-style naming patterns
        if description.to_lowercase().contains("hashicorp")
            || description.to_lowercase().contains("hash")
            || context.map_or(false, |c| c.to_lowercase().contains("hashicorp"))
        {
            // HashiCorp patterns: terraform, consul, vault, nomad, waypoint
            suggestions.extend(vec![
                format!("{}", base_name.to_lowercase()),
                format!("{}-{}", base_name.to_lowercase(), "core"),
                format!("{}-{}", base_name.to_lowercase(), "cli"),
                format!("{}-{}", base_name.to_lowercase(), "sdk"),
                format!("{}-{}", base_name.to_lowercase(), "api"),
                format!("{}-{}", base_name.to_lowercase(), "server"),
                format!("{}-{}", base_name.to_lowercase(), "agent"),
                format!("{}-{}", base_name.to_lowercase(), "client"),
                format!("{}-{}", base_name.to_lowercase(), "provider"),
                format!("{}-{}", base_name.to_lowercase(), "plugin"),
            ]);
        }

        // Google-style naming patterns
        if description.to_lowercase().contains("google")
            || description.to_lowercase().contains("gcp")
            || context.map_or(false, |c| c.to_lowercase().contains("google"))
        {
            // Google patterns: kubernetes, tensorflow, protobuf, gRPC
            suggestions.extend(vec![
                format!("{}", base_name.to_lowercase()),
                format!("{}-{}", base_name.to_lowercase(), "k8s"),
                format!("{}-{}", base_name.to_lowercase(), "tf"),
                format!("{}-{}", base_name.to_lowercase(), "pb"),
                format!("{}-{}", base_name.to_lowercase(), "grpc"),
                format!("{}-{}", base_name.to_lowercase(), "api"),
                format!("{}-{}", base_name.to_lowercase(), "sdk"),
                format!("{}-{}", base_name.to_lowercase(), "client"),
                format!("{}-{}", base_name.to_lowercase(), "server"),
                format!("{}-{}", base_name.to_lowercase(), "operator"),
            ]);
        }
    }

    /// Generate database naming suggestions (tables, columns, indexes)
    fn generate_database_suggestions(
        &self,
        description: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        let base_name = self.extract_base_name(description);
        vec![base_name.to_snake_case()]
    }

    /// Generate API naming suggestions (endpoints, routes, resources)
    fn generate_api_suggestions(
        &self,
        description: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        let base_name = self.extract_base_name(description);
        vec![base_name.to_kebab_case()]
    }

    /// Generate microservice naming suggestions
    fn generate_microservice_suggestions(
        &self,
        description: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        let base_name = self.extract_base_name(description);
        vec![format!("{}-service", base_name.to_kebab_case())]
    }

    /// Generate messaging naming suggestions
    fn generate_messaging_suggestions(
        &self,
        description: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        let base_name = self.extract_base_name(description);
        vec![base_name.to_kebab_case()]
    }

    /// Generate NATS subject naming suggestions
    fn generate_nats_suggestions(
        &self,
        description: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        let base_name = self.extract_base_name(description);
        vec![base_name.to_kebab_case()]
    }

    /// Generate Kafka topic naming suggestions
    fn generate_kafka_suggestions(
        &self,
        description: &str,
        context: Option<&str>,
    ) -> Vec<String> {
        let base_name = self.extract_base_name(description);
        vec![base_name.to_kebab_case()]
    }
}
