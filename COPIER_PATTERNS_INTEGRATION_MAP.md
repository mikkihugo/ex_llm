# Copier Patterns - Integration Map

**Where and How to Apply the Extracted Patterns**

## Quick Answer

**Use these patterns in 4 places:**

1. **QualityCodeGenerator** - Track what templates generate what code
2. **Self-Improving Agent** - Track template improvements over time
3. **Template System** - Add questions and migrations to existing templates
4. **Code Generation Tools** - Enable bulk file generation

---

## 1. QualityCodeGenerator Integration

**File:** `lib/singularity/storage/code/generators/quality_code_generator.ex`

### Current Flow (Without Patterns)
```elixir
QualityCodeGenerator.generate(
  task: "Parse JSON API",
  language: "elixir",
  quality: :production
)
# => {:ok, %{code: "...", docs: "...", specs: "...", tests: "..."}}
# ❌ No tracking - can't answer "what template generated this?"
# ❌ No questions - always uses same approach
# ❌ Can't upgrade when template improves
```

### New Flow (With Patterns)

#### A. Add Questions to Templates

**Before:** Static template with no customization
```json
{
  "language": "elixir",
  "quality_level": "production",
  "system_prompt": "Generate a JSON parser..."
}
```

**After:** Interactive template with questions
```json
{
  "language": "elixir",
  "quality_level": "production",
  "questions": [
    {
      "var_name": "parser_type",
      "type": "str",
      "help": "JSON parsing approach?",
      "choices": ["Jason (fast)", "Poison (compatible)", "Custom parser"],
      "default": "Jason (fast)"
    },
    {
      "var_name": "validation",
      "type": "bool",
      "help": "Include schema validation?",
      "default": true
    },
    {
      "var_name": "error_handling",
      "type": "str",
      "help": "Error handling strategy?",
      "choices": ["Raise exceptions", "Return {:error, reason}", "Both"],
      "default": "Return {:error, reason}",
      "when": "{{validation}}"
    }
  ],
  "system_prompt": "Generate a JSON parser using {{parser_type}}.\n{{#if validation}}Include schema validation.{{/if}}\nError handling: {{error_handling}}"
}
```

**Integration Code:**

```elixir
# lib/singularity/storage/code/generators/quality_code_generator.ex

def generate(opts) do
  task = Keyword.fetch!(opts, :task)
  language = Keyword.get(opts, :language, "elixir")

  # Load template with questions
  with {:ok, template} <- load_template(language),
       {:ok, answers} <- ask_template_questions(template, task, opts),
       {:ok, code} <- generate_with_answers(template, answers),
       {:ok, _} <- track_generation(template, answers, code, opts) do
    {:ok, code}
  end
end

defp ask_template_questions(template, task, opts) do
  questions = get_in(template, ["questions"]) || []

  if Enum.empty?(questions) do
    {:ok, %{}}  # No questions, use defaults
  else
    # Use LLM to answer based on task context
    TemplateQuestion.ask_via_llm(questions,
      context: %{
        task: task,
        language: template["language"],
        user_preferences: opts[:preferences] || %{}
      }
    )
  end
end

defp track_generation(template, answers, code, opts) do
  file_path = opts[:output_path] || "generated_code.ex"

  TemplateGeneration.record(
    template_id: "quality_template:#{template["language"]}-#{template["quality_level"]}",
    template_version: template["version"] || "1.0.0",
    file_path: file_path,
    answers: answers,
    success: true
  )
end
```

**Usage:**
```elixir
# User request
"Generate a JSON parser with validation"

# System now:
# 1. Loads elixir-production template
# 2. Asks questions via LLM: parser_type? validation? error_handling?
# 3. Generates code with user preferences
# 4. Tracks what template/answers created what code
# 5. Can regenerate later when template improves!
```

#### B. Add Migrations to Templates

**Scenario:** You improve the elixir-production template v1.0 → v2.0

**Template with migrations:**
```json
{
  "version": "2.0.0",
  "migrations": [
    {
      "version": "2.0.0",
      "before": [
        "# Backup old file",
        "cp {{_file_path}} {{_file_path}}.backup"
      ],
      "after": [
        "# Format with new style",
        "mix format {{_file_path}}",
        "# Run tests",
        "mix test {{_test_file}}"
      ]
    }
  ]
}
```

**Auto-upgrade command:**
```bash
# Upgrade ALL files generated by old template
mix template.upgrade quality_template:elixir-production --to 2.0.0

# Output:
# Upgrading lib/my_app/parser.ex to version 2.0.0...
# ✓ Running before migrations: backup created
# ✓ Regenerating code with new template
# ✓ Running after migrations: formatted, tests passed
# ✓ Migration successful!
```

---

## 2. Self-Improving Agent Integration

**File:** `lib/singularity/agents/self_improving_agent.ex`

### Use Case: Track Template Success Rates

**Problem:** Agent generates code using templates, but doesn't know which templates work best.

**Solution:** Use TemplateGeneration to track success and learn.

```elixir
# In SelfImprovingAgent.ex

defp improve_code_generation_capability(state) do
  # Get template usage statistics
  template_stats = get_template_statistics()

  # Find poorly performing templates
  poor_templates = Enum.filter(template_stats, fn {template_id, stats} ->
    stats.success_rate < 0.8  # Less than 80% success
  end)

  # Trigger improvements for poor templates
  Enum.each(poor_templates, fn {template_id, stats} ->
    improve_template(template_id, stats)
  end)
end

defp get_template_statistics do
  # Get all quality templates
  {:ok, templates} = ArtifactStore.list(artifact_type: "quality_template")

  Enum.map(templates, fn template ->
    template_id = "quality_template:#{template.identifier}"

    # Get generations from this template
    generations = TemplateGeneration.list_by_template(template_id)

    success_rate = TemplateGeneration.calculate_success_rate(generations)
    total_uses = length(generations)

    recent_failures =
      generations
      |> Enum.filter(&(!&1.success))
      |> Enum.take(5)

    {template_id, %{
      success_rate: success_rate,
      total_uses: total_uses,
      recent_failures: recent_failures,
      last_used: List.first(generations)&.generated_at
    }}
  end)
  |> Enum.into(%{})
end

defp improve_template(template_id, stats) do
  Logger.info("Self-improving template #{template_id} (success: #{stats.success_rate})")

  # Analyze what went wrong
  failure_patterns = analyze_failures(stats.recent_failures)

  # Generate improved template version
  {:ok, improved} = generate_improved_template(template_id, failure_patterns)

  # Save as new version
  {:ok, _} = ArtifactStore.update(template_id, improved)

  Logger.info("✓ Template improved and saved as v#{improved.version}")
end
```

**Result:** Agent automatically improves templates that fail frequently!

---

## 3. Template System Integration

**Files:** Templates in `templates_data/code_generation/`

### Add Questions to Existing Templates

**Example: Elixir GenServer Template**

**Before:**
```json
{
  "artifact_type": "quality_template",
  "identifier": "elixir-genserver",
  "content": {
    "system_prompt": "Generate a GenServer module..."
  }
}
```

**After:**
```json
{
  "artifact_type": "quality_template",
  "identifier": "elixir-genserver",
  "version": "2.0.0",
  "content": {
    "questions": [
      {
        "var_name": "state_type",
        "type": "str",
        "help": "What type of state?",
        "choices": ["Map", "Struct", "ETS table", "Agent"],
        "default": "Map"
      },
      {
        "var_name": "supervision",
        "type": "bool",
        "help": "Include in supervision tree?",
        "default": true
      },
      {
        "var_name": "callbacks",
        "type": "yaml",
        "multiselect": true,
        "help": "Which callbacks to implement?",
        "choices": ["handle_call", "handle_cast", "handle_info", "terminate"],
        "default": ["handle_call", "handle_cast"]
      }
    ],
    "system_prompt": "Generate GenServer with {{state_type}} state.\n{{#if supervision}}Include start_link and child_spec.{{/if}}\nImplement: {{#each callbacks}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}"
  }
}
```

### Add Migrations for Template Evolution

**Scenario:** You change GenServer template to use new OTP best practices

```json
{
  "version": "2.1.0",
  "migrations": [
    {
      "version": "2.1.0",
      "before": [
        "# Add TODO comment for manual review",
        "sed -i '1i# TODO: Review OTP changes from template v2.1.0' {{_file_path}}"
      ],
      "after": [
        "mix format {{_file_path}}",
        "mix compile --warnings-as-errors {{_file_path}}"
      ]
    }
  ]
}
```

---

## 4. Code Generation Tools Integration

**File:** `lib/singularity/tools/code_generation.ex`

### Add Bulk Generation Tool

**New Tool:** Generate multiple related files at once

```elixir
# In code_generation.ex

defp code_generate_bulk_tool do
  Tool.new!(%{
    name: "code_generate_bulk",
    description: """
    Generate multiple related files from one template using Solid {{#each}}.

    Example: Generate CRUD API endpoints for multiple resources.
    """,
    parameters: [
      %{
        name: "template_id",
        type: :string,
        required: true,
        description: "Template with {{#each}} bulk generation"
      },
      %{
        name: "items",
        type: :array,
        required: true,
        description: "List of items to generate files for"
      }
    ],
    execute: &execute_bulk_generation/1
  })
end

defp execute_bulk_generation(%{template_id: template_id, items: items}) do
  # Load template with {{#each}} syntax
  {:ok, template} = TemplateService.get_template(template_id)

  # Render with items
  {:ok, rendered} = Renderer.render_with_solid(template_id, %{items: items})

  # Parse bulk output into multiple files
  {:ok, files} = SolidYieldHelper.parse_bulk_output(rendered)

  # Track each generated file
  Enum.each(files, fn {path, code} ->
    TemplateGeneration.record(
      template_id: template_id,
      template_version: template["version"],
      file_path: path,
      answers: %{items: items}
    )

    # Write file
    File.write!(path, code)
  end)

  {:ok, %{
    files_generated: map_size(files),
    files: Map.keys(files)
  }}
end
```

**Usage:**
```elixir
# Agent call
code_generate_bulk(
  template_id: "phoenix-crud-endpoints",
  items: ["User", "Post", "Comment"]
)

# Generates:
# lib/my_app_web/controllers/user_controller.ex
# lib/my_app_web/controllers/post_controller.ex
# lib/my_app_web/controllers/comment_controller.ex
# test/my_app_web/controllers/user_controller_test.exs
# test/my_app_web/controllers/post_controller_test.exs
# test/my_app_web/controllers/comment_controller_test.exs
```

---

## 5. Living Knowledge Base Integration

**How patterns enhance your learning system:**

### Before (Without Patterns)
```
Template exists in templates_data/
↓
Agent uses template to generate code
↓
Code works or fails
↓
❌ No record of what template was used
❌ Can't analyze template performance
❌ Can't upgrade old code when template improves
```

### After (With Patterns)
```
Template exists with questions + migrations
↓
Agent asks questions via LLM
↓
Generates code with user preferences
↓
✅ Records: template_id + version + answers + success/failure
↓
Self-Improving Agent analyzes template stats
↓
Poor performing templates get improved
↓
mix template.upgrade auto-upgrades old code
↓
Living Knowledge Base learns what works!
```

---

## Concrete Implementation Plan

### Phase 1: Basic Tracking (1-2 hours)

**1. Add tracking to QualityCodeGenerator:**
```elixir
# After generating code in generate_with_template/5
TemplateGeneration.record(
  template_id: "quality_template:#{language}-#{quality}",
  template_version: "1.0.0",
  file_path: opts[:output_path],
  answers: %{task: task, quality: quality},
  success: true
)
```

**2. Run migration:**
```bash
cd singularity
mix ecto.migrate
```

**3. Test:**
```elixir
QualityCodeGenerator.generate(
  task: "Parse JSON",
  language: "elixir",
  output_path: "lib/parser.ex"
)

# Check tracking worked
{:ok, gen} = TemplateGeneration.find_by_file("lib/parser.ex")
gen.template_id  # => "quality_template:elixir-production"
```

### Phase 2: Add Questions (2-3 hours)

**1. Pick one high-use template:**
- `elixir-genserver`
- `elixir-production`
- `rust-production`

**2. Add questions section:**
```json
{
  "questions": [
    {"var_name": "...", "type": "...", "choices": [...]}
  ]
}
```

**3. Integrate in QualityCodeGenerator:**
```elixir
{:ok, answers} = TemplateQuestion.ask_via_llm(questions, context: task)
```

**4. Test with real agent:**
```elixir
# Agent calls
Tools.execute("code_generate", %{
  task: "Create a worker GenServer",
  language: "elixir"
})
# Now asks questions and tracks answers!
```

### Phase 3: Self-Improvement (2-3 hours)

**1. Add to SelfImprovingAgent:**
```elixir
defp analyze_template_performance(state) do
  template_stats = get_template_statistics()

  poor_templates = Enum.filter(template_stats, fn {_, stats} ->
    stats.success_rate < 0.8
  end)

  if length(poor_templates) > 0 do
    Logger.warning("Found #{length(poor_templates)} poor performing templates")
    # Trigger improvement workflow
  end
end
```

**2. Schedule periodic checks:**
```elixir
# Check template performance every hour
Process.send_after(self(), :check_template_performance, :timer.hours(1))
```

### Phase 4: Migrations (Optional, later)

**1. Add migration to a template:**
```json
{
  "version": "2.0.0",
  "migrations": [...]
}
```

**2. Test upgrade:**
```bash
mix template.upgrade quality_template:elixir-genserver --to 2.0.0 --dry-run
```

---

## ROI Analysis

### Time Investment
- **Phase 1 (Tracking):** 1-2 hours
- **Phase 2 (Questions):** 2-3 hours per template
- **Phase 3 (Self-Improvement):** 2-3 hours
- **Total:** 5-8 hours for full integration

### Benefits
1. **Track template performance** - Know what works
2. **Auto-improve templates** - Self-Improving Agent fixes bad templates
3. **Personalized generation** - Questions match user needs
4. **Easy upgrades** - One command updates all generated code
5. **Learning system** - Living Knowledge Base gets smarter

### When to Skip
- ❌ Templates used < 5 times (not worth questions)
- ❌ One-off code generation (no need to track)
- ❌ Throwaway prototypes (no need for quality)

### When to Use
- ✅ High-use templates (elixir-genserver, rust-production)
- ✅ Agent-driven generation (need tracking for learning)
- ✅ Production code (want to upgrade when templates improve)

---

## Quick Reference

**Track generation:**
```elixir
TemplateGeneration.record(template_id: "...", answers: %{}, file_path: "...")
```

**Find what generated a file:**
```elixir
{:ok, gen} = TemplateGeneration.find_by_file("lib/my_file.ex")
```

**Calculate template success:**
```elixir
success_rate = TemplateGeneration.calculate_success_rate("quality_template:elixir-genserver")
```

**Upgrade old code:**
```bash
mix template.upgrade quality_template:elixir-genserver --to 2.0.0
```

**Add questions to template:**
```json
{"questions": [{"var_name": "...", "type": "str", "choices": [...]}]}
```
