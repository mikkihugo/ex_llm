{
  "name": "Rust",
  "category": "language",
  "version": "1.0",
  "detector_signatures": {
    "config_files": ["Cargo.toml", "Cargo.lock"],
    "file_extensions": [".rs"],
    "patterns": [
      "fn\\s+\\w+",
      "use\\s+\\w+::",
      "impl\\s+\\w+",
      "struct\\s+\\w+",
      "enum\\s+\\w+",
      "trait\\s+\\w+",
      "pub\\s+fn",
      "async\\s+fn"
    ],
    "import_patterns": [
      "use\\s+([a-zA-Z_][a-zA-Z0-9_:]*)",
      "extern\\s+crate\\s+([a-zA-Z_][a-zA-Z0-9_]*)"
    ],
    "dependencies": {
      "file": "Cargo.toml",
      "section": "dependencies",
      "common_packages": ["tokio", "serde", "anyhow", "thiserror"]
    }
  },
  "framework_hints": {
    "actix-web": {
      "patterns": ["HttpServer::", "App::new", "@actix"],
      "confidence_boost": 0.3
    },
    "rocket": {
      "patterns": ["#\\[launch\\]", "#\\[get\\(", "#\\[post\\(", "Rocket::"],
      "confidence_boost": 0.3
    },
    "axum": {
      "patterns": ["Router::", "axum::", "ServiceExt"],
      "confidence_boost": 0.3
    }
  },
  "build_commands": {
    "default": "cargo build",
    "dev": "cargo run",
    "test": "cargo test",
    "check": "cargo check"
  },
  "metadata": {
    "ecosystem": "cargo",
    "package_manager": "cargo",
    "typical_structure": ["src/", "tests/", "benches/", "examples/"]
  },
  "llm_support": {
    "analysis_prompts": {
      "detect_async_patterns": "Analyze this Rust codebase for async/await patterns, tokio usage, and concurrency primitives",
      "detect_ownership_patterns": "Identify ownership patterns: Arc, Rc, RefCell, Mutex, RwLock usage",
      "security_analysis": "Check for unsafe blocks, potential memory leaks, and panic handling"
    },
    "prompt_bits": {
      "context": "Rust is a systems programming language focused on safety, speed, and concurrency. Key features include ownership, borrowing, lifetimes, and zero-cost abstractions.",
      "best_practices": [
        "Use ownership system to prevent memory errors",
        "Prefer Result<T, E> over panic for error handling",
        "Use async/await with tokio for concurrent operations",
        "Minimize unsafe code and document why it's needed"
      ],
      "common_mistakes": [
        "Fighting the borrow checker instead of understanding ownership",
        "Overusing Arc<Mutex<T>> when simpler patterns work",
        "Not handling errors with Result",
        "Blocking async runtime with synchronous operations"
      ]
    },
    "code_snippets": {
      "basic_server": {
        "description": "Basic Actix-web HTTP server",
        "code": "use actix_web::{web, App, HttpServer};\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/\", web::get().to(index))\n    })\n    .bind((\"127.0.0.1\", 8080))?\n    .run()\n    .await\n}",
        "patterns": ["actix-web", "async", "HttpServer"],
        "github_examples": [
          "https://github.com/actix/examples/blob/master/basics/basics"
        ]
      },
      "error_handling": {
        "description": "Idiomatic error handling with Result and anyhow",
        "code": "use anyhow::{Context, Result};\n\nfn process_file(path: &str) -> Result<String> {\n    let content = std::fs::read_to_string(path)\n        .context(\"Failed to read file\")?;\n    Ok(content)\n}",
        "patterns": ["Result", "anyhow", "error handling"],
        "best_practice": true
      },
      "async_concurrent": {
        "description": "Async/await with tokio for concurrent operations",
        "code": "use tokio::task;\n\n#[tokio::main]\nasync fn main() {\n    let handles: Vec<_> = (0..10)\n        .map(|i| task::spawn(async move {\n            process_item(i).await\n        }))\n        .collect();\n    \n    for handle in handles {\n        handle.await.unwrap();\n    }\n}",
        "patterns": ["tokio", "async", "spawn", "concurrent"],
        "github_examples": [
          "https://github.com/tokio-rs/tokio/tree/master/examples"
        ]
      },
      "shared_state": {
        "description": "Thread-safe shared state with Arc and Mutex",
        "code": "use std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet counter = Arc::new(Mutex::new(0));\nlet mut handles = vec![];\n\nfor _ in 0..10 {\n    let counter = Arc::clone(&counter);\n    let handle = thread::spawn(move || {\n        let mut num = counter.lock().unwrap();\n        *num += 1;\n    });\n    handles.push(handle);\n}",
        "patterns": ["Arc", "Mutex", "thread-safe"],
        "use_case": "shared mutable state across threads"
      }
    },
    "fact_sources": {
      "github_repos": [
        "actix/actix-web",
        "tokio-rs/tokio",
        "hyperium/hyper",
        "serde-rs/serde"
      ],
      "documentation": [
        "https://doc.rust-lang.org/book/",
        "https://rust-lang.github.io/async-book/"
      ],
      "common_crates": {
        "web": ["actix-web", "rocket", "axum", "warp"],
        "async": ["tokio", "async-std", "smol"],
        "serialization": ["serde", "serde_json", "bincode"],
        "error_handling": ["anyhow", "thiserror", "eyre"]
      }
    }
  }
}
