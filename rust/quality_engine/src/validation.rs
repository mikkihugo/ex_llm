//! Instructor-based validation for quality rules and linting results
//!
//! Provides structured schema validation for quality rules generated by AI
//! and linting results from multiple language-specific linters.
//!
//! # Features
//!
//! - Structured quality rule validation
//! - Regex pattern validation
//! - Linting result validation
//! - Severity level enforcement
//! - AI confidence tracking
//!
//! # Examples
//!
//! ```rust,no_run
//! use quality_engine::validation::{ValidatedQualityRule, validate_quality_rule};
//!
//! let rule = ValidatedQualityRule {
//!     rule_name: "no_unused_variables".to_string(),
//!     pattern: r"let\s+\w+\s*=\s*(?!.*\1)".to_string(),
//!     severity: "warning".to_string(),
//!     message: "Variable declared but never used".to_string(),
//!     ai_confidence: Some(0.89),
//! };
//!
//! match validate_quality_rule(&rule) {
//!     Ok(_) => println!("Rule is valid"),
//!     Err(e) => eprintln!("Validation error: {}", e),
//! }
//! ```

use regex;
use serde::{Deserialize, Serialize};

/// Validated quality rule for code linting
///
/// Represents a single linting rule that can be applied to source code.
/// All rules are validated for proper structure and pattern validity.
///
/// # Fields
///
/// - `rule_name`: Unique identifier for the rule
/// - `pattern`: Regex pattern for matching violations
/// - `severity`: One of "error", "warning", or "info"
/// - `message`: Human-readable error message
/// - `ai_confidence`: Optional confidence score (0.0-1.0) if AI-generated
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidatedQualityRule {
    /// Name of the quality rule (must be unique)
    #[serde(rename = "rule_name")]
    pub rule_name: String,

    /// Regex pattern for matching code violations
    #[serde(rename = "pattern")]
    pub pattern: String,

    /// Severity level: "error", "warning", or "info"
    /// - error: Must fix before release
    /// - warning: Should fix but not blocking
    /// - info: Nice to have, informational
    #[serde(rename = "severity")]
    pub severity: String,

    /// Human-readable message shown to developers
    #[serde(rename = "message")]
    pub message: String,

    /// AI confidence score (0.0-1.0) if AI-generated
    /// Higher confidence means more reliable rule
    /// None if manually created
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ai_confidence: Option<f64>,
}

/// Result of applying quality rules to code
///
/// Contains all violations found and aggregate quality metrics.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LintingResult {
    /// List of individual violations found
    #[serde(rename = "violations")]
    pub violations: Vec<LintingViolation>,

    /// Summary of linting results
    #[serde(rename = "summary")]
    pub summary: String,

    /// Overall quality score (0.0-1.0)
    /// Calculated from: 1.0 - (severity_weight * violation_count / file_lines)
    /// Higher score = better quality
    #[serde(rename = "quality_score")]
    pub quality_score: f64,
}

/// Individual code quality violation
///
/// Represents a single issue found by applying a quality rule.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LintingViolation {
    /// Path to file where violation occurred (relative to project root)
    #[serde(rename = "file")]
    pub file: String,

    /// Line number where violation starts (1-indexed)
    #[serde(rename = "line")]
    pub line: usize,

    /// Column number where violation starts (1-indexed)
    #[serde(rename = "column")]
    pub column: usize,

    /// Severity of violation: "error", "warning", or "info"
    #[serde(rename = "severity")]
    pub severity: String,

    /// Description of the violation
    #[serde(rename = "message")]
    pub message: String,

    /// ID of the rule that triggered this violation
    #[serde(rename = "rule_id")]
    pub rule_id: String,

    /// Suggested fix (if available)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggested_fix: Option<String>,
}

/// Configuration for linting a specific file/codebase
///
/// Used when applying quality rules to code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LintingConfig {
    /// Rules to apply
    pub rules: Vec<ValidatedQualityRule>,

    /// Minimum severity to report: "error", "warning", or "info"
    /// Violations below this level are filtered out
    pub min_severity: String,

    /// Maximum number of violations to report
    /// Limits results when processing large codebases
    pub max_violations: Option<usize>,

    /// Whether to generate suggested fixes
    pub generate_fixes: bool,
}

/// Validation helper functions
pub mod validate {
    use super::*;

    /// Validate rule name is non-empty and follows naming conventions
    pub fn rule_name(name: &str) -> Result<(), String> {
        if name.trim().is_empty() {
            return Err("Rule name cannot be empty".to_string());
        }

        if !name.chars().all(|c| c.is_alphanumeric() || c == '_') {
            return Err(format!(
                "Rule name '{}' must contain only alphanumeric characters and underscores",
                name
            ));
        }

        if name.len() > 100 {
            return Err(format!(
                "Rule name '{}' is too long (max 100 characters)",
                name
            ));
        }

        Ok(())
    }

    /// Validate pattern is valid regex
    pub fn regex_pattern(pattern: &str) -> Result<(), String> {
        if pattern.trim().is_empty() {
            return Err("Pattern cannot be empty".to_string());
        }

        match regex::Regex::new(pattern) {
            Ok(_) => Ok(()),
            Err(e) => Err(format!("Invalid regex pattern '{}': {}", pattern, e)),
        }
    }

    /// Validate severity level
    pub fn severity(severity: &str) -> Result<(), String> {
        match severity {
            "error" | "warning" | "info" => Ok(()),
            _ => Err(format!(
                "Invalid severity '{}', must be 'error', 'warning', or 'info'",
                severity
            )),
        }
    }

    /// Validate message is non-empty
    pub fn message(msg: &str) -> Result<(), String> {
        if msg.trim().is_empty() {
            return Err("Message cannot be empty".to_string());
        }

        if msg.len() > 500 {
            return Err(format!(
                "Message is too long (max 500 characters): {}",
                msg.len()
            ));
        }

        Ok(())
    }

    /// Validate confidence score (0.0-1.0)
    pub fn confidence(score: f64) -> Result<(), String> {
        if score < 0.0 || score > 1.0 {
            return Err(format!(
                "Confidence must be between 0.0 and 1.0, got {}",
                score
            ));
        }
        Ok(())
    }

    /// Validate quality score (0.0-1.0)
    pub fn quality_score(score: f64) -> Result<(), String> {
        if score < 0.0 || score > 1.0 {
            return Err(format!(
                "Quality score must be between 0.0 and 1.0, got {}",
                score
            ));
        }
        Ok(())
    }

    /// Validate file path is non-empty
    pub fn file_path(path: &str) -> Result<(), String> {
        if path.trim().is_empty() {
            return Err("File path cannot be empty".to_string());
        }
        Ok(())
    }

    /// Validate line number is valid (>= 1)
    pub fn line_number(line: usize) -> Result<(), String> {
        if line == 0 {
            return Err("Line number must be >= 1".to_string());
        }
        Ok(())
    }

    /// Validate column number is valid (>= 1)
    pub fn column_number(column: usize) -> Result<(), String> {
        if column == 0 {
            return Err("Column number must be >= 1".to_string());
        }
        Ok(())
    }
}

/// Validate a quality rule
///
/// Checks all fields for validity:
/// - Rule name follows naming conventions
/// - Pattern is valid regex
/// - Severity is one of the allowed values
/// - Message is non-empty
/// - AI confidence (if provided) is in valid range
///
/// # Arguments
///
/// * `rule` - The quality rule to validate
///
/// # Returns
///
/// * `Ok(())` if validation passes
/// * `Err(String)` with description of first validation error
pub fn validate_quality_rule(rule: &ValidatedQualityRule) -> Result<(), String> {
    validate::rule_name(&rule.rule_name)?;
    validate::regex_pattern(&rule.pattern)?;
    validate::severity(&rule.severity)?;
    validate::message(&rule.message)?;

    if let Some(confidence) = rule.ai_confidence {
        validate::confidence(confidence)?;
    }

    Ok(())
}

/// Validate a linting violation
///
/// Checks all fields for validity.
pub fn validate_violation(violation: &LintingViolation) -> Result<(), String> {
    validate::file_path(&violation.file)?;
    validate::line_number(violation.line)?;
    validate::column_number(violation.column)?;
    validate::severity(&violation.severity)?;
    validate::message(&violation.message)?;
    validate::rule_name(&violation.rule_id)?;

    Ok(())
}

/// Validate linting results
///
/// Checks:
/// - Quality score is in valid range (0.0-1.0)
/// - Summary is non-empty
/// - All violations are valid
/// - Violations are sorted by file, then line, then column
///
/// # Arguments
///
/// * `result` - The linting result to validate
///
/// # Returns
///
/// * `Ok(())` if validation passes
/// * `Err(String)` with description of first validation error
pub fn validate_linting_result(result: &LintingResult) -> Result<(), String> {
    validate::quality_score(result.quality_score)?;

    if result.summary.trim().is_empty() {
        return Err("Summary cannot be empty".to_string());
    }

    if result.summary.len() > 1000 {
        return Err(format!(
            "Summary is too long (max 1000 characters): {}",
            result.summary.len()
        ));
    }

    // Validate each violation
    for (i, violation) in result.violations.iter().enumerate() {
        validate_violation(violation)
            .map_err(|e| format!("Violation #{} invalid: {}", i + 1, e))?;
    }

    // Check ordering (optional but recommended)
    let mut prev: Option<(&str, usize, usize)> = None;
    for violation in &result.violations {
        if let Some((prev_file, prev_line, prev_col)) = prev {
            let current = (violation.file.as_str(), violation.line, violation.column);
            if current < (prev_file, prev_line, prev_col) {
                tracing::warn!(
                    "Violations not sorted: {} after {}",
                    format!("{}:{}:{}", violation.file, violation.line, violation.column),
                    format!("{}:{}:{}", prev_file, prev_line, prev_col)
                );
            }
        }
        prev = Some((violation.file.as_str(), violation.line, violation.column));
    }

    Ok(())
}

/// Validate linting configuration
pub fn validate_config(config: &LintingConfig) -> Result<(), String> {
    if config.rules.is_empty() {
        return Err("At least one rule must be provided".to_string());
    }

    // Validate all rules
    for (i, rule) in config.rules.iter().enumerate() {
        validate_quality_rule(rule)
            .map_err(|e| format!("Rule #{} invalid: {}", i + 1, e))?;
    }

    validate::severity(&config.min_severity)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_quality_rule_valid() {
        let rule = ValidatedQualityRule {
            rule_name: "no_unused_vars".to_string(),
            pattern: r"let\s+\w+".to_string(),
            severity: "warning".to_string(),
            message: "Unused variable detected".to_string(),
            ai_confidence: Some(0.85),
        };

        assert!(validate_quality_rule(&rule).is_ok());
    }

    #[test]
    fn test_rule_name_validation() {
        assert!(validate::rule_name("valid_rule_1").is_ok());
        assert!(validate::rule_name("").is_err());
        assert!(validate::rule_name("rule-with-dash").is_err());
    }

    #[test]
    fn test_severity_validation() {
        assert!(validate::severity("error").is_ok());
        assert!(validate::severity("warning").is_ok());
        assert!(validate::severity("info").is_ok());
        assert!(validate::severity("debug").is_err());
    }

    #[test]
    fn test_regex_pattern_validation() {
        assert!(validate::regex_pattern(r"\w+").is_ok());
        assert!(validate::regex_pattern("[invalid").is_err());
        assert!(validate::regex_pattern("").is_err());
    }

    #[test]
    fn test_validate_violation() {
        let violation = LintingViolation {
            file: "src/main.rs".to_string(),
            line: 42,
            column: 5,
            severity: "warning".to_string(),
            message: "Test violation".to_string(),
            rule_id: "test_rule".to_string(),
            suggested_fix: None,
        };

        assert!(validate_violation(&violation).is_ok());
    }

    #[test]
    fn test_validate_linting_result() {
        let result = LintingResult {
            violations: vec![LintingViolation {
                file: "src/main.rs".to_string(),
                line: 10,
                column: 1,
                severity: "warning".to_string(),
                message: "Test".to_string(),
                rule_id: "test".to_string(),
                suggested_fix: None,
            }],
            summary: "Found 1 violation".to_string(),
            quality_score: 0.95,
        };

        assert!(validate_linting_result(&result).is_ok());
    }

    #[test]
    fn test_quality_score_range() {
        assert!(validate::quality_score(0.5).is_ok());
        assert!(validate::quality_score(1.5).is_err());
        assert!(validate::quality_score(-0.1).is_err());
    }
}
