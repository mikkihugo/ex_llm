{
  "id": "rust-microservice-generator",
  "name": "Rust Microservice Generator",
  "description": "Generates Rust microservices using AI signatures optimized for LLM coders",
  "steps": [
    {
      "name": "sparc-phase-1-research",
      "operation": {
        "type": "generate",
        "generate": "sparc-research"
      }
    },
    {
      "name": "sparc-phase-2-architecture",
      "operation": {
        "type": "generate", 
        "generate": "sparc-architecture"
      }
    },
    {
      "name": "sparc-phase-3-security",
      "operation": {
        "type": "generate",
        "generate": "sparc-security"
      }
    },
    {
      "name": "sparc-phase-4-performance",
      "operation": {
        "type": "generate",
        "generate": "sparc-performance"
      }
    },
    {
      "name": "sparc-phase-5-implementation",
      "operation": {
        "type": "generate",
        "generate": "rust-microservice"
      }
    }
  ],
  "metadata": {
    "version": "1.0.0",
    "author": "SPARC Team",
    "created_at": "2024-01-15T10:00:00Z",
    "updated_at": "2024-01-15T10:00:00Z",
    "tags": ["rust", "microservice", "dspy", "llm-coder", "code-generation"],
    "performance": {
      "avg_execution_time_ms": 150.0,
      "memory_usage_bytes": 3145728,
      "complexity": 8
    }
  },
  "ai_signature": {
    "name": "rust_microservice_generator",
    "inputs": {
      "business_domain": "The business domain context (e.g., e-commerce, finance)",
      "entity_name": "The entity name in snake_case (e.g., user, product)",
      "security_level": "Security requirements (low, medium, high)",
      "performance_profile": "Performance characteristics (low-latency, high-throughput)",
      "architecture_pattern": "Architecture pattern (microservice, monolith, event-driven)"
    },
    "outputs": {
      "rust_code": "Generated Rust microservice code with annotations",
      "dependencies": "Required Cargo dependencies",
      "tests": "Generated test code",
      "documentation": "Code documentation and comments"
    },
    "instruction": "Generate a complete Rust microservice with business domain annotations, security validation, performance optimization, error handling, logging, and comprehensive tests. The code should be production-ready and optimized for LLM coders."
  },
  "template_content": "//! @business-domain {{business_domain}}\n//! @architecture-pattern {{architecture_pattern}}\n//! @architecture-layer business-logic\n//! @security-level {{security_level}}\n//! @performance-profile {{performance_profile}}\n//! @quality-level production-ready\n//! @ai-signature rust_microservice_generator\n//! @llm-coder-optimized true\n\nuse serde::{Deserialize, Serialize};\nuse anyhow::Result;\nuse tracing::{info, error, warn};\nuse uuid::Uuid;\nuse chrono::{DateTime, Utc};\n\n/// @business-entity {{entity_name}}\n/// @architecture-component {{architecture_pattern}}\n/// @security-pattern authentication\n/// @performance-optimization connection-pooling\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct {{EntityName}} {\n    /// @business-field {{entity_name}}_id\n    /// @security-validation input-sanitization\n    pub id: String,\n    pub name: String,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n/// @business-entity {{EntityName}}Data\n/// @security-pattern data-transfer-object\n/// @ai-output rust_code: dto_definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct {{EntityName}}Data {\n    /// @business-field {{entity_name}}_name\n    /// @security-validation input-sanitization\n    pub name: String,\n}\n\n/// @business-operation create_{{entity_name}}\n/// @architecture-pattern repository\n/// @security-operation {{security_level}}\n/// @performance-metric latency\n/// @ai-output rust_code: business_logic\nimpl {{EntityName}} {\n    /// @business-workflow create_{{entity_name}}_workflow\n    /// @test-scenario happy-path\n    /// @test-scenario error-handling\n    /// @ai-output tests: unit_tests\n    pub async fn create(&self, data: {{EntityName}}Data) -> Result<{{EntityName}}> {\n        info!(\"Creating {{entity_name}} with data: {:?}\", data);\n        \n        // @performance-critical-section\n        // @security-validation input-sanitization\n        let entity = {{EntityName}} {\n            id: Uuid::new_v4().to_string(),\n            name: data.name,\n            created_at: Utc::now(),\n            updated_at: Utc::now(),\n        };\n        \n        // @performance-bottleneck database-queries\n        // @security-audit sql-injection-check\n        self.repository.save(&entity).await?;\n        \n        Ok(entity)\n    }\n    \n    /// @business-operation new_{{entity_name}}\n    /// @architecture-pattern factory\n    /// @test-scenario edge-case-empty-data\n    /// @ai-output tests: factory_tests\n    pub fn new(name: String) -> Self {\n        Self {\n            id: Uuid::new_v4().to_string(),\n            name,\n            created_at: Utc::now(),\n            updated_at: Utc::now(),\n        }\n    }\n}\n\n/// @architecture-pattern repository\n/// @architecture-boundary database\n/// @performance-optimization connection-pooling\n/// @ai-output dependencies: database_deps\npub struct {{EntityName}}Repository {\n    connection: DatabaseConnection,\n}\n\nimpl {{EntityName}}Repository {\n    /// @business-operation save_{{entity_name}}\n    /// @security-operation data-persistence\n    /// @performance-critical-section\n    /// @ai-output rust_code: repository_impl\n    pub async fn save(&self, entity: &{{EntityName}}) -> Result<()> {\n        // Implementation\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// @test-scenario happy-path\n    /// @ai-output tests: happy_path_test\n    #[tokio::test]\n    async fn test_create_{{entity_name}}() {\n        let entity = {{EntityName}}::new(\"test\".to_string());\n        assert_eq!(entity.name, \"test\");\n        assert!(!entity.id.is_empty());\n    }\n\n    /// @test-scenario error-handling\n    /// @ai-output tests: error_handling_test\n    #[tokio::test]\n    async fn test_create_{{entity_name}}_with_empty_name() {\n        let entity = {{EntityName}}::new(\"\".to_string());\n        assert_eq!(entity.name, \"\");\n    }\n}"
}
